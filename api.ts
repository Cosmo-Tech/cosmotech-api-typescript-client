/* tslint:disable */
/* eslint-disable */
/**
 * Cosmo Tech Platform API
 * Cosmo Tech Platform API
 *
 * The version of the OpenAPI document: 3.2.6
 * Contact: platform@cosmotech.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * a RBAC by component
 * @export
 * @interface ComponentRolePermissions
 */
export interface ComponentRolePermissions {
    /**
     * 
     * @type {string}
     * @memberof ComponentRolePermissions
     */
    'component'?: string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ComponentRolePermissions
     */
    'roles'?: { [key: string]: Array<string>; };
}
/**
 * a version of a Connector
 * @export
 * @interface Connector
 */
export interface Connector {
    /**
     * the Connector version unique identifier
     * @type {string}
     * @memberof Connector
     */
    'id'?: string;
    /**
     * the Connector key which group Connector versions
     * @type {string}
     * @memberof Connector
     */
    'key'?: string;
    /**
     * the Connector name
     * @type {string}
     * @memberof Connector
     */
    'name'?: string;
    /**
     * the Connector description
     * @type {string}
     * @memberof Connector
     */
    'description'?: string;
    /**
     * the registry repository containing the image
     * @type {string}
     * @memberof Connector
     */
    'repository'?: string;
    /**
     * the Connector version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof Connector
     */
    'version'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Connector
     */
    'tags'?: Array<string>;
    /**
     * the user id which own this connector version
     * @type {string}
     * @memberof Connector
     */
    'ownerId'?: string;
    /**
     * an optional URL link to connector page
     * @type {string}
     * @memberof Connector
     */
    'url'?: string;
    /**
     * whether or not the connector uses Azure Managed Identity
     * @type {boolean}
     * @memberof Connector
     */
    'azureManagedIdentity'?: boolean;
    /**
     * whether to authenticate against Azure using the app registration credentials provided by the customer
     * @type {boolean}
     * @memberof Connector
     */
    'azureAuthenticationWithCustomerAppRegistration'?: boolean;
    /**
     * 
     * @type {Array<IoTypesEnum>}
     * @memberof Connector
     */
    'ioTypes'?: Array<IoTypesEnum>;
    /**
     * the list of connector parameters groups
     * @type {Array<ConnectorParameterGroup>}
     * @memberof Connector
     */
    'parameterGroups'?: Array<ConnectorParameterGroup>;
}
/**
 * a connector parameter
 * @export
 * @interface ConnectorParameter
 */
export interface ConnectorParameter {
    /**
     * the connector parameter id
     * @type {string}
     * @memberof ConnectorParameter
     */
    'id': string;
    /**
     * the list of translated parameter group labels
     * @type {string}
     * @memberof ConnectorParameter
     */
    'label': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof ConnectorParameter
     */
    'valueType'?: string;
    /**
     * the list of available and valid values for the parameter
     * @type {Array<string>}
     * @memberof ConnectorParameter
     */
    'options'?: Array<string>;
    /**
     * the default value
     * @type {string}
     * @memberof ConnectorParameter
     */
    'default'?: string;
    /**
     * associated environment variable in connector image
     * @type {string}
     * @memberof ConnectorParameter
     */
    'envVar'?: string;
}
/**
 * a connector parameters group
 * @export
 * @interface ConnectorParameterGroup
 */
export interface ConnectorParameterGroup {
    /**
     * the connector parameter group id
     * @type {string}
     * @memberof ConnectorParameterGroup
     */
    'id': string;
    /**
     * the list of translated parameter group labels
     * @type {string}
     * @memberof ConnectorParameterGroup
     */
    'label': string;
    /**
     * the list of parameters
     * @type {Array<ConnectorParameter>}
     * @memberof ConnectorParameterGroup
     */
    'parameters': Array<ConnectorParameter>;
}
/**
 * define cpus and memory needs
 * @export
 * @interface ContainerResourceSizeInfo
 */
export interface ContainerResourceSizeInfo {
    /**
     * define cpu needs
     * @type {string}
     * @memberof ContainerResourceSizeInfo
     */
    'cpu': string;
    /**
     * define memory needs
     * @type {string}
     * @memberof ContainerResourceSizeInfo
     */
    'memory': string;
}
/**
 * a description object for resource requests and limits (default same configuration as basic sizing)
 * @export
 * @interface ContainerResourceSizing
 */
export interface ContainerResourceSizing {
    /**
     * 
     * @type {ContainerResourceSizeInfo}
     * @memberof ContainerResourceSizing
     */
    'requests': ContainerResourceSizeInfo;
    /**
     * 
     * @type {ContainerResourceSizeInfo}
     * @memberof ContainerResourceSizing
     */
    'limits': ContainerResourceSizeInfo;
}
/**
 * a Dataset
 * @export
 * @interface Dataset
 */
export interface Dataset {
    /**
     * the Dataset unique identifier
     * @type {string}
     * @memberof Dataset
     */
    'id'?: string;
    /**
     * the Dataset name
     * @type {string}
     * @memberof Dataset
     */
    'name'?: string;
    /**
     * the Dataset description
     * @type {string}
     * @memberof Dataset
     */
    'description'?: string;
    /**
     * the User id which own this Dataset
     * @type {string}
     * @memberof Dataset
     */
    'ownerId'?: string;
    /**
     * the name of the owner
     * @type {string}
     * @memberof Dataset
     */
    'ownerName'?: string;
    /**
     * the Organization Id related to this Dataset
     * @type {string}
     * @memberof Dataset
     */
    'organizationId'?: string;
    /**
     * the Dataset id which is the parent of this Dataset
     * @type {string}
     * @memberof Dataset
     */
    'parentId'?: string;
    /**
     * list of workspace linked to this dataset
     * @type {Array<string>}
     * @memberof Dataset
     */
    'linkedWorkspaceIdList'?: Array<string>;
    /**
     * the twin graph id
     * @type {string}
     * @memberof Dataset
     */
    'twingraphId'?: string;
    /**
     * is this the main dataset
     * @type {boolean}
     * @memberof Dataset
     */
    'main'?: boolean;
    /**
     * the Dataset creation date
     * @type {number}
     * @memberof Dataset
     */
    'creationDate'?: number;
    /**
     * the last time a refresh was done
     * @type {number}
     * @memberof Dataset
     */
    'refreshDate'?: number;
    /**
     * 
     * @type {DatasetSourceType}
     * @memberof Dataset
     */
    'sourceType'?: DatasetSourceType;
    /**
     * 
     * @type {SourceInfo}
     * @memberof Dataset
     */
    'source'?: SourceInfo;
    /**
     * 
     * @type {IngestionStatusEnum}
     * @memberof Dataset
     */
    'ingestionStatus'?: IngestionStatusEnum | null;
    /**
     * 
     * @type {TwincacheStatusEnum}
     * @memberof Dataset
     */
    'twincacheStatus'?: TwincacheStatusEnum | null;
    /**
     * the list of queries
     * @type {Array<string>}
     * @memberof Dataset
     */
    'queries'?: Array<string>;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Dataset
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {DatasetConnector}
     * @memberof Dataset
     */
    'connector'?: DatasetConnector;
    /**
     * the list of other Datasets ids to compose as fragments
     * @type {Array<string>}
     * @memberof Dataset
     */
    'fragmentsIds'?: Array<string>;
    /**
     * the validator id
     * @type {string}
     * @memberof Dataset
     */
    'validatorId'?: string;
    /**
     * the list of compatible Solutions versions
     * @type {Array<DatasetCompatibility>}
     * @memberof Dataset
     */
    'compatibility'?: Array<DatasetCompatibility>;
    /**
     * 
     * @type {DatasetSecurity}
     * @memberof Dataset
     */
    'security'?: DatasetSecurity;
}


/**
 * a Dataset access control item
 * @export
 * @interface DatasetAccessControl
 */
export interface DatasetAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof DatasetAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof DatasetAccessControl
     */
    'role': string;
}
/**
 * a Dataset compatibility constraint to a Solution version open range
 * @export
 * @interface DatasetCompatibility
 */
export interface DatasetCompatibility {
    /**
     * the Solution key which group Solution versions
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'solutionKey': string;
    /**
     * the Solution minimum version compatibility (version included)
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'minimumVersion'?: string;
    /**
     * the Solution maximum version compatibility (version included)
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'maximumVersion'?: string;
}
/**
 * the Connector setup bound to a Dataset
 * @export
 * @interface DatasetConnector
 */
export interface DatasetConnector {
    /**
     * the Connector id
     * @type {string}
     * @memberof DatasetConnector
     */
    'id'?: string;
    /**
     * the Connector name
     * @type {string}
     * @memberof DatasetConnector
     */
    'name'?: string;
    /**
     * the Connector version
     * @type {string}
     * @memberof DatasetConnector
     */
    'version'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DatasetConnector
     */
    'parametersValues'?: { [key: string]: string; };
}
/**
 * the Dataset Copy Parameters
 * @export
 * @interface DatasetCopyParameters
 */
export interface DatasetCopyParameters {
    /**
     * the source Dataset id
     * @type {string}
     * @memberof DatasetCopyParameters
     */
    'sourceId'?: string;
    /**
     * the target Dataset id
     * @type {string}
     * @memberof DatasetCopyParameters
     */
    'targetId'?: string;
    /**
     * freeform options to path to connectors
     * @type {{ [key: string]: any; }}
     * @memberof DatasetCopyParameters
     */
    'options'?: { [key: string]: any; };
}
/**
 * the Dataset Role
 * @export
 * @interface DatasetRole
 */
export interface DatasetRole {
    /**
     * the Dataset Role
     * @type {string}
     * @memberof DatasetRole
     */
    'role': string;
}
/**
 * the search options
 * @export
 * @interface DatasetSearch
 */
export interface DatasetSearch {
    /**
     * the dataset tag list to search
     * @type {Array<string>}
     * @memberof DatasetSearch
     */
    'datasetTags': Array<string>;
}
/**
 * the dataset security information
 * @export
 * @interface DatasetSecurity
 */
export interface DatasetSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof DatasetSecurity
     */
    'default': string;
    /**
     * the list which can access this Dataset with detailed access control information
     * @type {Array<DatasetAccessControl>}
     * @memberof DatasetSecurity
     */
    'accessControlList': Array<DatasetAccessControl>;
}
/**
 * the Dataset Source Type
 * @export
 * @enum {string}
 */

export const DatasetSourceType = {
    Adt: 'ADT',
    AzureStorage: 'AzureStorage',
    File: 'File',
    None: 'None',
    Twincache: 'Twincache',
    Etl: 'ETL'
} as const;

export type DatasetSourceType = typeof DatasetSourceType[keyof typeof DatasetSourceType];


/**
 * a twin graph hash
 * @export
 * @interface DatasetTwinGraphHash
 */
export interface DatasetTwinGraphHash {
    /**
     * the hash of the graph
     * @type {string}
     * @memberof DatasetTwinGraphHash
     */
    'hash'?: string;
}
/**
 * a twin graph query in cypher language
 * @export
 * @interface DatasetTwinGraphInfo
 */
export interface DatasetTwinGraphInfo {
    /**
     * the import job id
     * @type {string}
     * @memberof DatasetTwinGraphInfo
     */
    'jobId'?: string;
    /**
     * the Dataset id
     * @type {string}
     * @memberof DatasetTwinGraphInfo
     */
    'datasetId'?: string;
    /**
     * Twingraph status
     * @type {string}
     * @memberof DatasetTwinGraphInfo
     */
    'status'?: string;
}
/**
 * a twin graph query in cypher language
 * @export
 * @interface DatasetTwinGraphQuery
 */
export interface DatasetTwinGraphQuery {
    /**
     * the query in cypher language
     * @type {string}
     * @memberof DatasetTwinGraphQuery
     */
    'query': string;
}
/**
 * Configuration of scenario runs deletion automatic mecanism
 * @export
 * @interface DeleteHistoricalData
 */
export interface DeleteHistoricalData {
    /**
     * Activate or Deactivate historical data deletion
     * @type {boolean}
     * @memberof DeleteHistoricalData
     */
    'enable': boolean;
    /**
     * define the polling frequency of scenario run status (in millis)
     * @type {number}
     * @memberof DeleteHistoricalData
     */
    'pollFrequency'?: number;
    /**
     * define the polling timeout
     * @type {number}
     * @memberof DeleteHistoricalData
     */
    'timeOut'?: number;
}
/**
 * 
 * @export
 * @interface FileUploadMetadata
 */
export interface FileUploadMetadata {
    /**
     * 
     * @type {string}
     * @memberof FileUploadMetadata
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileUploadMetadata
     */
    'size'?: number;
}
/**
 * files read on upload
 * @export
 * @interface FileUploadValidation
 */
export interface FileUploadValidation {
    /**
     * list of filename found on nodes folder
     * @type {Array<FileUploadMetadata>}
     * @memberof FileUploadValidation
     */
    'nodes'?: Array<FileUploadMetadata>;
    /**
     * list of filename found on edges folder
     * @type {Array<FileUploadMetadata>}
     * @memberof FileUploadValidation
     */
    'edges'?: Array<FileUploadMetadata>;
}
/**
 * 
 * @export
 * @interface GraphProperties
 */
export interface GraphProperties {
    /**
     * the type of the relationship
     * @type {string}
     * @memberof GraphProperties
     */
    'type'?: string;
    /**
     * the source node of the relationship
     * @type {string}
     * @memberof GraphProperties
     */
    'source'?: string;
    /**
     * the target node of the relationship
     * @type {string}
     * @memberof GraphProperties
     */
    'target'?: string;
    /**
     * the name of the graph data object
     * @type {string}
     * @memberof GraphProperties
     */
    'name'?: string;
    /**
     * the parameters of the graph data object
     * @type {string}
     * @memberof GraphProperties
     */
    'params'?: string;
}
/**
 * the Dataset ingestion status
 * @export
 * @enum {string}
 */

export const IngestionStatusEnum = {
    None: 'NONE',
    Pending: 'PENDING',
    Error: 'ERROR',
    Success: 'SUCCESS'
} as const;

export type IngestionStatusEnum = typeof IngestionStatusEnum[keyof typeof IngestionStatusEnum];


/**
 * The read and write capabilities of connector
 * @export
 * @enum {string}
 */

export const IoTypesEnum = {
    Read: 'read',
    Write: 'write'
} as const;

export type IoTypesEnum = typeof IoTypesEnum[keyof typeof IoTypesEnum];


/**
 * an Organization
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * the Organization unique identifier
     * @type {string}
     * @memberof Organization
     */
    'id'?: string;
    /**
     * the Organization name
     * @type {string}
     * @memberof Organization
     */
    'name'?: string;
    /**
     * the Owner User Id
     * @type {string}
     * @memberof Organization
     */
    'ownerId'?: string;
    /**
     * 
     * @type {OrganizationServices}
     * @memberof Organization
     */
    'services'?: OrganizationServices;
    /**
     * 
     * @type {OrganizationSecurity}
     * @memberof Organization
     */
    'security'?: OrganizationSecurity;
}
/**
 * a Organization access control item
 * @export
 * @interface OrganizationAccessControl
 */
export interface OrganizationAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof OrganizationAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof OrganizationAccessControl
     */
    'role': string;
}
/**
 * the Organization Role
 * @export
 * @interface OrganizationRole
 */
export interface OrganizationRole {
    /**
     * the Organization Role
     * @type {string}
     * @memberof OrganizationRole
     */
    'role': string;
}
/**
 * the Organization security information
 * @export
 * @interface OrganizationSecurity
 */
export interface OrganizationSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof OrganizationSecurity
     */
    'default': string;
    /**
     * the list which can access this Organization with detailed access control information
     * @type {Array<OrganizationAccessControl>}
     * @memberof OrganizationSecurity
     */
    'accessControlList': Array<OrganizationAccessControl>;
}
/**
 * a cloud service resource
 * @export
 * @interface OrganizationService
 */
export interface OrganizationService {
    /**
     * the cloud service name
     * @type {string}
     * @memberof OrganizationService
     */
    'cloudService'?: string;
    /**
     * the platform base uri for this service
     * @type {string}
     * @memberof OrganizationService
     */
    'baseUri'?: string;
    /**
     * the Platform service associated to the resource
     * @type {string}
     * @memberof OrganizationService
     */
    'platformService'?: string;
    /**
     * the Organization specific uri for this service resource
     * @type {string}
     * @memberof OrganizationService
     */
    'resourceUri'?: string;
    /**
     * a freeform credentials object. Structure depends on service
     * @type {{ [key: string]: any; }}
     * @memberof OrganizationService
     */
    'credentials'?: { [key: string]: any; };
}
/**
 * the cloud service resources of the Organization
 * @export
 * @interface OrganizationServices
 */
export interface OrganizationServices {
    /**
     * a freeform credentials object for the Organization tenant. Structure depends on cloud provider
     * @type {{ [key: string]: any; }}
     * @memberof OrganizationServices
     */
    'tenantCredentials'?: { [key: string]: any; };
    /**
     * 
     * @type {OrganizationService}
     * @memberof OrganizationServices
     */
    'storage'?: OrganizationService;
    /**
     * 
     * @type {OrganizationService}
     * @memberof OrganizationServices
     */
    'solutionsContainerRegistry'?: OrganizationService;
}
/**
 * the result of a SQL Query
 * @export
 * @interface QueryResult
 */
export interface QueryResult {
    /**
     * the list of results
     * @type {Array<{ [key: string]: any; }>}
     * @memberof QueryResult
     */
    'result'?: Array<{ [key: string]: any; }>;
}
/**
 * define cpus and memory needs
 * @export
 * @interface ResourceSizeInfo
 */
export interface ResourceSizeInfo {
    /**
     * define cpu needs
     * @type {string}
     * @memberof ResourceSizeInfo
     */
    'cpu': string;
    /**
     * define memory needs
     * @type {string}
     * @memberof ResourceSizeInfo
     */
    'memory': string;
}
/**
 * a Run with only base properties
 * @export
 * @interface Run
 */
export interface Run {
    /**
     * the Run
     * @type {string}
     * @memberof Run
     */
    'id'?: string;
    /**
     * 
     * @type {RunState}
     * @memberof Run
     */
    'state'?: RunState;
    /**
     * the Organization id
     * @type {string}
     * @memberof Run
     */
    'organizationId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof Run
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech Simulation Run Id
     * @type {string}
     * @memberof Run
     */
    'csmSimulationRun'?: string;
    /**
     * the base name for workflow name generation
     * @type {string}
     * @memberof Run
     */
    'generateName'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof Run
     */
    'workflowName'?: string;
    /**
     * the user id which own this run
     * @type {string}
     * @memberof Run
     */
    'ownerId'?: string;
    /**
     * the Workspace Id
     * @type {string}
     * @memberof Run
     */
    'workspaceId'?: string;
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof Run
     */
    'workspaceKey'?: string;
    /**
     * the Runner Id
     * @type {string}
     * @memberof Run
     */
    'runnerId'?: string;
    /**
     * the Solution Id
     * @type {string}
     * @memberof Run
     */
    'solutionId'?: string;
    /**
     * the Solution Run Template id
     * @type {string}
     * @memberof Run
     */
    'runTemplateId'?: string;
    /**
     * the compute size needed for this Analysis. Standard sizes are basic and highcpu. Default is basic
     * @type {string}
     * @memberof Run
     */
    'computeSize'?: string;
    /**
     * the Run creation date
     * @type {string}
     * @memberof Run
     */
    'createdAt'?: string;
    /**
     * the list of Dataset Id associated to this Run
     * @type {Array<string>}
     * @memberof Run
     */
    'datasetList'?: Array<string>;
    /**
     * the list of Run Template parameters values
     * @type {Array<RunTemplateParameterValue>}
     * @memberof Run
     */
    'parametersValues'?: Array<RunTemplateParameterValue>;
    /**
     * the node label request
     * @type {string}
     * @memberof Run
     */
    'nodeLabel'?: string;
    /**
     * the containers list. This information is not returned by the API.
     * @type {Array<RunContainer>}
     * @memberof Run
     */
    'containers'?: Array<RunContainer>;
}


/**
 * a Run container description
 * @export
 * @interface RunContainer
 */
export interface RunContainer {
    /**
     * the container Id
     * @type {string}
     * @memberof RunContainer
     */
    'id'?: string;
    /**
     * the container name
     * @type {string}
     * @memberof RunContainer
     */
    'name': string;
    /**
     * the metadata labels
     * @type {{ [key: string]: string; }}
     * @memberof RunContainer
     */
    'labels'?: { [key: string]: string; };
    /**
     * environment variable map
     * @type {{ [key: string]: string; }}
     * @memberof RunContainer
     */
    'envVars'?: { [key: string]: string; };
    /**
     * the container image URI
     * @type {string}
     * @memberof RunContainer
     */
    'image': string;
    /**
     * the container entry point
     * @type {string}
     * @memberof RunContainer
     */
    'entrypoint'?: string;
    /**
     * the list of run arguments for the container
     * @type {Array<string>}
     * @memberof RunContainer
     */
    'runArgs'?: Array<string>;
    /**
     * the list of dependencies container name to run this container
     * @type {Array<string>}
     * @memberof RunContainer
     */
    'dependencies'?: Array<string>;
    /**
     * whether or not this container is a Cosmo Tech solution container
     * @type {boolean}
     * @memberof RunContainer
     */
    'solutionContainer'?: boolean;
    /**
     * the node label request
     * @type {string}
     * @memberof RunContainer
     */
    'nodeLabel'?: string;
    /**
     * 
     * @type {ContainerResourceSizing}
     * @memberof RunContainer
     */
    'runSizing'?: ContainerResourceSizing;
    /**
     * the list of artifacts
     * @type {Array<RunContainerArtifact>}
     * @memberof RunContainer
     */
    'artifacts'?: Array<RunContainerArtifact>;
}
/**
 * a runner run container artifact
 * @export
 * @interface RunContainerArtifact
 */
export interface RunContainerArtifact {
    /**
     * the artifact name
     * @type {string}
     * @memberof RunContainerArtifact
     */
    'name'?: string;
    /**
     * the artifact path (relative to /var/csmoutput)
     * @type {string}
     * @memberof RunContainerArtifact
     */
    'path'?: string;
}
/**
 * logs for a given container
 * @export
 * @interface RunContainerLogs
 */
export interface RunContainerLogs {
    /**
     * the node Id which has executed this log
     * @type {string}
     * @memberof RunContainerLogs
     */
    'nodeId'?: string;
    /**
     * the container name
     * @type {string}
     * @memberof RunContainerLogs
     */
    'containerName'?: string;
    /**
     * the list of children node id
     * @type {Array<string>}
     * @memberof RunContainerLogs
     */
    'children'?: Array<string>;
    /**
     * the node logs in plain text
     * @type {string}
     * @memberof RunContainerLogs
     */
    'logs'?: string;
}
/**
 * Run Data to send
 * @export
 * @interface RunData
 */
export interface RunData {
    /**
     * Database name
     * @type {string}
     * @memberof RunData
     */
    'database_name'?: string;
    /**
     * Table name
     * @type {string}
     * @memberof RunData
     */
    'table_name'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof RunData
     */
    'data'?: Array<{ [key: string]: any; }>;
}
/**
 * a data result query in SQL
 * @export
 * @interface RunDataQuery
 */
export interface RunDataQuery {
    /**
     * the query in SQL
     * @type {string}
     * @memberof RunDataQuery
     */
    'query': string;
}
/**
 * the run logs returned by all containers
 * @export
 * @interface RunLogs
 */
export interface RunLogs {
    /**
     * the Run Id
     * @type {string}
     * @memberof RunLogs
     */
    'runId'?: string;
    /**
     * the container map of logs
     * @type {{ [key: string]: RunContainerLogs; }}
     * @memberof RunLogs
     */
    'containers'?: { [key: string]: RunContainerLogs; };
}
/**
 * the memory and CPU requested by the pod
 * @export
 * @interface RunResourceRequested
 */
export interface RunResourceRequested {
    /**
     * the cpu requested
     * @type {number}
     * @memberof RunResourceRequested
     */
    'cpu'?: number;
    /**
     * the memory requested
     * @type {number}
     * @memberof RunResourceRequested
     */
    'memory'?: number;
}
/**
 * the search options
 * @export
 * @interface RunSearch
 */
export interface RunSearch {
    /**
     * the Solution Id to search
     * @type {string}
     * @memberof RunSearch
     */
    'solutionId'?: string;
    /**
     * the Solution Analysis Id to search
     * @type {string}
     * @memberof RunSearch
     */
    'runTemplateId'?: string;
    /**
     * the Workspace Id to search
     * @type {string}
     * @memberof RunSearch
     */
    'workspaceId'?: string;
    /**
     * the Runner Id to search
     * @type {string}
     * @memberof RunSearch
     */
    'runnerId'?: string;
    /**
     * 
     * @type {RunSearchState}
     * @memberof RunSearch
     */
    'state'?: RunSearchState;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof RunSearch
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof RunSearch
     */
    'workflowName'?: string;
    /**
     * the owner Id to search
     * @type {string}
     * @memberof RunSearch
     */
    'ownerId'?: string;
}


/**
 * the state to search
 * @export
 * @enum {string}
 */

export const RunSearchState = {
    FetchingDatasets: 'FetchingDatasets',
    FetchingScenarioParameters: 'FetchingScenarioParameters',
    ApplyingScenarioParameters: 'ApplyingScenarioParameters',
    ValidatingScenarioData: 'ValidatingScenarioData',
    SendingScenarioDataToDataWarehouse: 'SendingScenarioDataToDataWarehouse',
    PreRun: 'PreRun',
    Running: 'Running',
    PostRun: 'PostRun',
    Success: 'Success',
    Failed: 'Failed'
} as const;

export type RunSearchState = typeof RunSearchState[keyof typeof RunSearchState];


/**
 * the parameters to run directly containers
 * @export
 * @interface RunStartContainers
 */
export interface RunStartContainers {
    /**
     * the base name for workflow name generation
     * @type {string}
     * @memberof RunStartContainers
     */
    'generateName'?: string;
    /**
     * Cosmo Tech Simulation Run Id
     * @type {string}
     * @memberof RunStartContainers
     */
    'csmSimulationId': string;
    /**
     * the node label request
     * @type {string}
     * @memberof RunStartContainers
     */
    'nodeLabel'?: string;
    /**
     * the workflow labels
     * @type {{ [key: string]: string; }}
     * @memberof RunStartContainers
     */
    'labels'?: { [key: string]: string; };
    /**
     * the containerslist
     * @type {Array<RunContainer>}
     * @memberof RunStartContainers
     */
    'containers': Array<RunContainer>;
}
/**
 * the Run end-to-end state
 * @export
 * @enum {string}
 */

export const RunState = {
    Running: 'Running',
    Successful: 'Successful',
    Failed: 'Failed',
    Unknown: 'Unknown'
} as const;

export type RunState = typeof RunState[keyof typeof RunState];


/**
 * a Run status
 * @export
 * @interface RunStatus
 */
export interface RunStatus {
    /**
     * the Run id
     * @type {string}
     * @memberof RunStatus
     */
    'id'?: string;
    /**
     * the Organization id
     * @type {string}
     * @memberof RunStatus
     */
    'organizationId'?: string;
    /**
     * the Workspace id
     * @type {string}
     * @memberof RunStatus
     */
    'workspaceId'?: string;
    /**
     * the Runner id
     * @type {string}
     * @memberof RunStatus
     */
    'runnerId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof RunStatus
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof RunStatus
     */
    'workflowName'?: string;
    /**
     * the Run start Date Time
     * @type {string}
     * @memberof RunStatus
     */
    'startTime'?: string;
    /**
     * the Run end Date Time
     * @type {string}
     * @memberof RunStatus
     */
    'endTime'?: string;
    /**
     * high-level summary of where the workflow is in its lifecycle
     * @type {string}
     * @memberof RunStatus
     */
    'phase'?: string;
    /**
     * progress to completion
     * @type {string}
     * @memberof RunStatus
     */
    'progress'?: string;
    /**
     * a  human readable message indicating details about why the workflow is in this condition
     * @type {string}
     * @memberof RunStatus
     */
    'message'?: string;
    /**
     * estimatedDuration in seconds
     * @type {number}
     * @memberof RunStatus
     */
    'estimatedDuration'?: number;
    /**
     * status of Run nodes
     * @type {Array<RunStatusNode>}
     * @memberof RunStatus
     */
    'nodes'?: Array<RunStatusNode>;
    /**
     * 
     * @type {RunState}
     * @memberof RunStatus
     */
    'state'?: RunState;
}


/**
 * status of a Run Node
 * @export
 * @interface RunStatusNode
 */
export interface RunStatusNode {
    /**
     * the node id
     * @type {string}
     * @memberof RunStatusNode
     */
    'id'?: string;
    /**
     * the node unique name
     * @type {string}
     * @memberof RunStatusNode
     */
    'name'?: string;
    /**
     * the Run container name
     * @type {string}
     * @memberof RunStatusNode
     */
    'containerName'?: string;
    /**
     * the list of outbound nodes
     * @type {Array<string>}
     * @memberof RunStatusNode
     */
    'outboundNodes'?: Array<string>;
    /**
     * 
     * @type {RunResourceRequested}
     * @memberof RunStatusNode
     */
    'resourcesDuration'?: RunResourceRequested;
    /**
     * estimatedDuration in seconds
     * @type {number}
     * @memberof RunStatusNode
     */
    'estimatedDuration'?: number;
    /**
     * HostNodeName name of the Kubernetes node on which the Pod is running, if applicable
     * @type {string}
     * @memberof RunStatusNode
     */
    'hostNodeName'?: string;
    /**
     * a human readable message indicating details about why the node is in this condition
     * @type {string}
     * @memberof RunStatusNode
     */
    'message'?: string;
    /**
     * high-level summary of where the node is in its lifecycle
     * @type {string}
     * @memberof RunStatusNode
     */
    'phase'?: string;
    /**
     * progress to completion
     * @type {string}
     * @memberof RunStatusNode
     */
    'progress'?: string;
    /**
     * the node start time
     * @type {string}
     * @memberof RunStatusNode
     */
    'startTime'?: string;
    /**
     * the node end time
     * @type {string}
     * @memberof RunStatusNode
     */
    'endTime'?: string;
}
/**
 * a Solution Run Template
 * @export
 * @interface RunTemplate
 */
export interface RunTemplate {
    /**
     * the Solution Run Template id
     * @type {string}
     * @memberof RunTemplate
     */
    'id': string;
    /**
     * the Run Template name
     * @type {string}
     * @memberof RunTemplate
     * @deprecated
     */
    'name'?: string;
    /**
     * a translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplate
     */
    'labels'?: { [key: string]: string; };
    /**
     * the Run Template description
     * @type {string}
     * @memberof RunTemplate
     */
    'description'?: string;
    /**
     * the Cosmo Tech simulation name. This information is send to the Engine. Mandatory information if no Engine is defined
     * @type {string}
     * @memberof RunTemplate
     */
    'csmSimulation'?: string;
    /**
     * the list of Run Template tags
     * @type {Array<string>}
     * @memberof RunTemplate
     */
    'tags'?: Array<string>;
    /**
     * the compute size needed for this Run Template. Standard sizes are basic and highcpu. Default is basic
     * @type {string}
     * @memberof RunTemplate
     */
    'computeSize'?: string;
    /**
     * 
     * @type {RunTemplateResourceSizing}
     * @memberof RunTemplate
     */
    'runSizing'?: RunTemplateResourceSizing;
    /**
     * set to true if the run template does not want to check data ingestion state (no probes or not control plane)
     * @type {boolean}
     * @memberof RunTemplate
     */
    'noDataIngestionState'?: boolean;
    /**
     * whether or not the fetch dataset step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'fetchDatasets'?: boolean;
    /**
     * whether or not the scenario data download transform step step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'scenarioDataDownloadTransform'?: boolean;
    /**
     * whether or not the fetch parameters step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'fetchScenarioParameters'?: boolean;
    /**
     * whether or not the apply parameter step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'applyParameters'?: boolean;
    /**
     * whether or not the validate step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'validateData'?: boolean;
    /**
     * whether or not the Datasets values are send to the DataWarehouse prior to Simulation Run. If not set follow the Workspace setting
     * @type {boolean}
     * @memberof RunTemplate
     */
    'sendDatasetsToDataWarehouse'?: boolean;
    /**
     * whether or not the input parameters values are send to the DataWarehouse prior to Simulation Run. If not set follow the Workspace setting
     * @type {boolean}
     * @memberof RunTemplate
     */
    'sendInputParametersToDataWarehouse'?: boolean;
    /**
     * whether or not the pre-run step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'preRun'?: boolean;
    /**
     * whether or not the run step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'run'?: boolean;
    /**
     * whether or not the post-run step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'postRun'?: boolean;
    /**
     * whether or not to store the scenario parameters in json instead of csv
     * @type {boolean}
     * @memberof RunTemplate
     */
    'parametersJson'?: boolean;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'parametersHandlerSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'datasetValidatorSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'preRunSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'runSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'postRunSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'scenariodataTransformSource'?: RunTemplateStepSource;
    /**
     * the ordered list of parameters groups for the Run Template
     * @type {Array<string>}
     * @memberof RunTemplate
     */
    'parameterGroups'?: Array<string>;
    /**
     * whether or not to stack adjacent scenario run steps in one container run which will chain steps
     * @type {boolean}
     * @memberof RunTemplate
     */
    'stackSteps'?: boolean;
    /**
     * an optional URL to the git repository
     * @type {string}
     * @memberof RunTemplate
     */
    'gitRepositoryUrl'?: string;
    /**
     * an optional git branch name
     * @type {string}
     * @memberof RunTemplate
     */
    'gitBranchName'?: string;
    /**
     * an optional directory where to find the run template source
     * @type {string}
     * @memberof RunTemplate
     */
    'runTemplateSourceDir'?: string;
    /**
     * 
     * @type {RunTemplateOrchestrator}
     * @memberof RunTemplate
     */
    'orchestratorType'?: RunTemplateOrchestrator;
    /**
     * an optional duration in seconds in which a workflow is allowed to run
     * @type {number}
     * @memberof RunTemplate
     */
    'executionTimeout'?: number;
    /**
     * 
     * @type {DeleteHistoricalData}
     * @memberof RunTemplate
     */
    'deleteHistoricalData'?: DeleteHistoricalData;
}


/**
 * the Run Template step handler identifier
 * @export
 * @enum {string}
 */

export const RunTemplateHandlerId = {
    ParametersHandler: 'parameters_handler',
    Validator: 'validator',
    Prerun: 'prerun',
    Engine: 'engine',
    Postrun: 'postrun',
    ScenariodataTransform: 'scenariodata_transform'
} as const;

export type RunTemplateHandlerId = typeof RunTemplateHandlerId[keyof typeof RunTemplateHandlerId];


/**
 * the Orchestrator to use for the Run Template
 * @export
 * @enum {string}
 */

export const RunTemplateOrchestrator = {
    ArgoWorkflow: 'argoWorkflow',
    CsmOrc: 'csmOrc'
} as const;

export type RunTemplateOrchestrator = typeof RunTemplateOrchestrator[keyof typeof RunTemplateOrchestrator];


/**
 * a Run Template Parameter
 * @export
 * @interface RunTemplateParameter
 */
export interface RunTemplateParameter {
    /**
     * the Parameter id
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'id': string;
    /**
     * a translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameter
     */
    'labels'?: { [key: string]: string; };
    /**
     * the variable type for the parameter. Basic types or special type %DATASETID%
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'varType'?: string;
    /**
     * the default value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'defaultValue'?: string;
    /**
     * the minimum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'minValue'?: string;
    /**
     * the maximum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'maxValue'?: string;
    /**
     * a regex to validate the value
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'regexValidation'?: string;
    /**
     * freeform options
     * @type {{ [key: string]: any; }}
     * @memberof RunTemplateParameter
     */
    'options'?: { [key: string]: any; };
}
/**
 * a Parameter Group for a Run Template
 * @export
 * @interface RunTemplateParameterGroup
 */
export interface RunTemplateParameterGroup {
    /**
     * the Parameter Group id
     * @type {string}
     * @memberof RunTemplateParameterGroup
     */
    'id': string;
    /**
     * a translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameterGroup
     */
    'labels'?: { [key: string]: string; };
    /**
     * does the group define a table
     * @type {boolean}
     * @memberof RunTemplateParameterGroup
     */
    'isTable'?: boolean;
    /**
     * freeform options
     * @type {{ [key: string]: any; }}
     * @memberof RunTemplateParameterGroup
     */
    'options'?: { [key: string]: any; };
    /**
     * the Run Template Group parent Id
     * @type {string}
     * @memberof RunTemplateParameterGroup
     */
    'parentId'?: string;
    /**
     * an ordered list of Run Template Parameters
     * @type {Array<string>}
     * @memberof RunTemplateParameterGroup
     */
    'parameters'?: Array<string>;
}
/**
 * the value of Analysis parameter for a Runner for this Run
 * @export
 * @interface RunTemplateParameterValue
 */
export interface RunTemplateParameterValue {
    /**
     * the parameter Id
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'parameterId': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'value': string;
}
/**
 * a description object for resource requests and limits (default same configuration as basic sizing)
 * @export
 * @interface RunTemplateResourceSizing
 */
export interface RunTemplateResourceSizing {
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunTemplateResourceSizing
     */
    'requests': ResourceSizeInfo;
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunTemplateResourceSizing
     */
    'limits': ResourceSizeInfo;
}
/**
 * the source local, cloud or git repository
 * @export
 * @enum {string}
 */

export const RunTemplateStepSource = {
    Cloud: 'cloud',
    Git: 'git',
    Local: 'local',
    Platform: 'platform'
} as const;

export type RunTemplateStepSource = typeof RunTemplateStepSource[keyof typeof RunTemplateStepSource];


/**
 * a Runner with base information
 * @export
 * @interface Runner
 */
export interface Runner {
    /**
     * the Runner unique identifier
     * @type {string}
     * @memberof Runner
     */
    'id'?: string;
    /**
     * the Runner name
     * @type {string}
     * @memberof Runner
     */
    'name'?: string;
    /**
     * the Runner description
     * @type {string}
     * @memberof Runner
     */
    'description'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Runner
     */
    'tags'?: Array<string>;
    /**
     * the Runner parent id
     * @type {string}
     * @memberof Runner
     */
    'parentId'?: string;
    /**
     * the user id which own this Runner
     * @type {string}
     * @memberof Runner
     */
    'ownerId'?: string;
    /**
     * the runner root id
     * @type {string}
     * @memberof Runner
     */
    'rootId'?: string;
    /**
     * the Solution Id associated with this Runner
     * @type {string}
     * @memberof Runner
     */
    'solutionId'?: string;
    /**
     * the Solution Run Template Id associated with this Runner
     * @type {string}
     * @memberof Runner
     */
    'runTemplateId'?: string;
    /**
     * the associated Organization Id
     * @type {string}
     * @memberof Runner
     */
    'organizationId'?: string;
    /**
     * the associated Workspace Id
     * @type {string}
     * @memberof Runner
     */
    'workspaceId'?: string;
    /**
     * the Runner creation date
     * @type {number}
     * @memberof Runner
     */
    'creationDate'?: number;
    /**
     * the last time a Runner was updated
     * @type {number}
     * @memberof Runner
     */
    'lastUpdate'?: number;
    /**
     * the name of the owner
     * @type {string}
     * @memberof Runner
     */
    'ownerName'?: string;
    /**
     * the Solution name
     * @type {string}
     * @memberof Runner
     */
    'solutionName'?: string;
    /**
     * the Solution Run Template name associated with this Runner
     * @type {string}
     * @memberof Runner
     */
    'runTemplateName'?: string;
    /**
     * the list of Dataset Id associated to this Runner Run Template
     * @type {Array<string>}
     * @memberof Runner
     */
    'datasetList'?: Array<string>;
    /**
     * 
     * @type {RunnerResourceSizing}
     * @memberof Runner
     */
    'runSizing'?: RunnerResourceSizing;
    /**
     * the list of Solution Run Template parameters values
     * @type {Array<RunnerRunTemplateParameterValue>}
     * @memberof Runner
     */
    'parametersValues'?: Array<RunnerRunTemplateParameterValue>;
    /**
     * last run id from current runner
     * @type {string}
     * @memberof Runner
     */
    'lastRunId'?: string;
    /**
     * 
     * @type {RunnerValidationStatus}
     * @memberof Runner
     */
    'validationStatus'?: RunnerValidationStatus;
    /**
     * 
     * @type {RunnerSecurity}
     * @memberof Runner
     */
    'security'?: RunnerSecurity;
}


/**
 * a Runner access control item
 * @export
 * @interface RunnerAccessControl
 */
export interface RunnerAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof RunnerAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof RunnerAccessControl
     */
    'role': string;
}
/**
 * the difference between the values of a parameter
 * @export
 * @interface RunnerChangedParameterValue
 */
export interface RunnerChangedParameterValue {
    /**
     * the parameter id the values refer to
     * @type {string}
     * @memberof RunnerChangedParameterValue
     */
    'parameterId'?: string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof RunnerChangedParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value for the reference Runner
     * @type {string}
     * @memberof RunnerChangedParameterValue
     */
    'value'?: string;
    /**
     * the parameter value for the compared Runner
     * @type {string}
     * @memberof RunnerChangedParameterValue
     */
    'comparedValue'?: string;
}
/**
 * the result of the comparison of two runners
 * @export
 * @interface RunnerComparisonResult
 */
export interface RunnerComparisonResult {
    /**
     * the Runner Id which is the reference for the comparison
     * @type {string}
     * @memberof RunnerComparisonResult
     */
    'runnerId'?: string;
    /**
     * the Runner Id the reference Runner is compared to
     * @type {string}
     * @memberof RunnerComparisonResult
     */
    'comparedRunnerId'?: string;
    /**
     * the list of changed values for parameters
     * @type {Array<RunnerChangedParameterValue>}
     * @memberof RunnerComparisonResult
     */
    'changedValues'?: Array<RunnerChangedParameterValue>;
}
/**
 * Runner data download job info
 * @export
 * @interface RunnerDataDownloadInfo
 */
export interface RunnerDataDownloadInfo {
    /**
     * the Runner Data Download URL
     * @type {string}
     * @memberof RunnerDataDownloadInfo
     */
    'url'?: string;
}
/**
 * Runner data download job
 * @export
 * @interface RunnerDataDownloadJob
 */
export interface RunnerDataDownloadJob {
    /**
     * the Runner Data Download job identifier
     * @type {string}
     * @memberof RunnerDataDownloadJob
     */
    'id'?: string;
}
/**
 * a description object for resource requests and limits (default same configuration as basic sizing)
 * @export
 * @interface RunnerResourceSizing
 */
export interface RunnerResourceSizing {
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunnerResourceSizing
     */
    'requests': ResourceSizeInfo;
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunnerResourceSizing
     */
    'limits': ResourceSizeInfo;
}
/**
 * the Runner Role
 * @export
 * @interface RunnerRole
 */
export interface RunnerRole {
    /**
     * the Runner Role
     * @type {string}
     * @memberof RunnerRole
     */
    'role': string;
}
/**
 * the value of a Solution Run Template parameter for a Runner
 * @export
 * @interface RunnerRunTemplateParameterValue
 */
export interface RunnerRunTemplateParameterValue {
    /**
     * the parameter Id
     * @type {string}
     * @memberof RunnerRunTemplateParameterValue
     */
    'parameterId': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof RunnerRunTemplateParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value
     * @type {string}
     * @memberof RunnerRunTemplateParameterValue
     */
    'value': string;
    /**
     * whether or not the value is inherited from parent or has been changed
     * @type {boolean}
     * @memberof RunnerRunTemplateParameterValue
     */
    'isInherited'?: boolean;
}
/**
 * the Runner security information
 * @export
 * @interface RunnerSecurity
 */
export interface RunnerSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof RunnerSecurity
     */
    'default': string;
    /**
     * the list which can access this Runner with detailed access control information
     * @type {Array<RunnerAccessControl>}
     * @memberof RunnerSecurity
     */
    'accessControlList': Array<RunnerAccessControl>;
}
/**
 * the validation status of the runner
 * @export
 * @enum {string}
 */

export const RunnerValidationStatus = {
    Draft: 'Draft',
    Rejected: 'Rejected',
    Unknown: 'Unknown',
    Validated: 'Validated'
} as const;

export type RunnerValidationStatus = typeof RunnerValidationStatus[keyof typeof RunnerValidationStatus];


/**
 * a Scenario with base information
 * @export
 * @interface Scenario
 */
export interface Scenario {
    /**
     * the Scenario unique identifier
     * @type {string}
     * @memberof Scenario
     */
    'id'?: string;
    /**
     * the Scenario name
     * @type {string}
     * @memberof Scenario
     */
    'name'?: string;
    /**
     * the Scenario description
     * @type {string}
     * @memberof Scenario
     */
    'description'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Scenario
     */
    'tags'?: Array<string>;
    /**
     * the Scenario parent id
     * @type {string}
     * @memberof Scenario
     */
    'parentId'?: string;
    /**
     * the user id which own this Scenario
     * @type {string}
     * @memberof Scenario
     */
    'ownerId'?: string;
    /**
     * the scenario root id
     * @type {string}
     * @memberof Scenario
     */
    'rootId'?: string;
    /**
     * the Solution Id associated with this Scenario
     * @type {string}
     * @memberof Scenario
     */
    'solutionId'?: string;
    /**
     * the Solution Run Template Id associated with this Scenario
     * @type {string}
     * @memberof Scenario
     */
    'runTemplateId'?: string;
    /**
     * the associated Organization Id
     * @type {string}
     * @memberof Scenario
     */
    'organizationId'?: string;
    /**
     * the associated Workspace Id
     * @type {string}
     * @memberof Scenario
     */
    'workspaceId'?: string;
    /**
     * 
     * @type {ScenarioJobState}
     * @memberof Scenario
     */
    'state'?: ScenarioJobState;
    /**
     * the Scenario creation date
     * @type {number}
     * @memberof Scenario
     */
    'creationDate'?: number;
    /**
     * the last time a Scenario was updated
     * @type {number}
     * @memberof Scenario
     */
    'lastUpdate'?: number;
    /**
     * the name of the owner
     * @type {string}
     * @memberof Scenario
     */
    'ownerName'?: string;
    /**
     * the Solution name
     * @type {string}
     * @memberof Scenario
     */
    'solutionName'?: string;
    /**
     * the Solution Run Template name associated with this Scenario
     * @type {string}
     * @memberof Scenario
     */
    'runTemplateName'?: string;
    /**
     * the list of Dataset Id associated to this Scenario Run Template
     * @type {Array<string>}
     * @memberof Scenario
     */
    'datasetList'?: Array<string>;
    /**
     * 
     * @type {ScenarioResourceSizing}
     * @memberof Scenario
     */
    'runSizing'?: ScenarioResourceSizing;
    /**
     * the list of Solution Run Template parameters values
     * @type {Array<ScenarioRunTemplateParameterValue>}
     * @memberof Scenario
     */
    'parametersValues'?: Array<ScenarioRunTemplateParameterValue>;
    /**
     * 
     * @type {ScenarioLastRun}
     * @memberof Scenario
     */
    'lastRun'?: ScenarioLastRun;
    /**
     * 
     * @type {ScenarioLastRun}
     * @memberof Scenario
     */
    'parentLastRun'?: ScenarioLastRun;
    /**
     * 
     * @type {ScenarioLastRun}
     * @memberof Scenario
     */
    'rootLastRun'?: ScenarioLastRun;
    /**
     * 
     * @type {ScenarioValidationStatus}
     * @memberof Scenario
     */
    'validationStatus'?: ScenarioValidationStatus;
    /**
     * 
     * @type {ScenarioSecurity}
     * @memberof Scenario
     */
    'security'?: ScenarioSecurity;
}


/**
 * a Scenario access control item
 * @export
 * @interface ScenarioAccessControl
 */
export interface ScenarioAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof ScenarioAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof ScenarioAccessControl
     */
    'role': string;
}
/**
 * the difference between the values of a parameter
 * @export
 * @interface ScenarioChangedParameterValue
 */
export interface ScenarioChangedParameterValue {
    /**
     * the parameter id the values refer to
     * @type {string}
     * @memberof ScenarioChangedParameterValue
     */
    'parameterId'?: string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof ScenarioChangedParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value for the reference Scenario
     * @type {string}
     * @memberof ScenarioChangedParameterValue
     */
    'value'?: string;
    /**
     * the parameter value for the compared Scenario
     * @type {string}
     * @memberof ScenarioChangedParameterValue
     */
    'comparedValue'?: string;
}
/**
 * the result of the comparison of two scenarios
 * @export
 * @interface ScenarioComparisonResult
 */
export interface ScenarioComparisonResult {
    /**
     * the Scenario Id which is the reference for the comparison
     * @type {string}
     * @memberof ScenarioComparisonResult
     */
    'scenarioId'?: string;
    /**
     * the Scenario Id the reference Scenario is compared to
     * @type {string}
     * @memberof ScenarioComparisonResult
     */
    'comparedScenarioId'?: string;
    /**
     * the list of changed values for parameters
     * @type {Array<ScenarioChangedParameterValue>}
     * @memberof ScenarioComparisonResult
     */
    'changedValues'?: Array<ScenarioChangedParameterValue>;
}
/**
 * Scenario data download job info
 * @export
 * @interface ScenarioDataDownloadInfo
 */
export interface ScenarioDataDownloadInfo {
    /**
     * the Scenario Data Download URL
     * @type {string}
     * @memberof ScenarioDataDownloadInfo
     */
    'url'?: string;
    /**
     * 
     * @type {ScenarioJobState}
     * @memberof ScenarioDataDownloadInfo
     */
    'state'?: ScenarioJobState;
}


/**
 * Scenario data download job
 * @export
 * @interface ScenarioDataDownloadJob
 */
export interface ScenarioDataDownloadJob {
    /**
     * the Scenario Data Download job identifier
     * @type {string}
     * @memberof ScenarioDataDownloadJob
     */
    'id'?: string;
}
/**
 * the Scenario job state
 * @export
 * @enum {string}
 */

export const ScenarioJobState = {
    Created: 'Created',
    Running: 'Running',
    Successful: 'Successful',
    Failed: 'Failed',
    Unknown: 'Unknown',
    DataIngestionInProgress: 'DataIngestionInProgress'
} as const;

export type ScenarioJobState = typeof ScenarioJobState[keyof typeof ScenarioJobState];


/**
 * 
 * @export
 * @interface ScenarioLastRun
 */
export interface ScenarioLastRun {
    /**
     * the last Scenario Run id
     * @type {string}
     * @memberof ScenarioLastRun
     */
    'scenarioRunId'?: string;
    /**
     * the last Cosmo Tech Simulation Run id
     * @type {string}
     * @memberof ScenarioLastRun
     */
    'csmSimulationRun'?: string;
    /**
     * the last Workflow Id
     * @type {string}
     * @memberof ScenarioLastRun
     */
    'workflowId'?: string;
    /**
     * the last Workflow name
     * @type {string}
     * @memberof ScenarioLastRun
     */
    'workflowName'?: string;
}
/**
 * a description object for resource requests and limits (default same configuration as basic sizing)
 * @export
 * @interface ScenarioResourceSizing
 */
export interface ScenarioResourceSizing {
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof ScenarioResourceSizing
     */
    'requests': ResourceSizeInfo;
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof ScenarioResourceSizing
     */
    'limits': ResourceSizeInfo;
}
/**
 * the Scenario Role
 * @export
 * @interface ScenarioRole
 */
export interface ScenarioRole {
    /**
     * the Scenario Role
     * @type {string}
     * @memberof ScenarioRole
     */
    'role': string;
}
/**
 * a ScenarioRun with only base properties
 * @export
 * @interface ScenarioRun
 */
export interface ScenarioRun {
    /**
     * the ScenarioRun
     * @type {string}
     * @memberof ScenarioRun
     */
    'id'?: string;
    /**
     * 
     * @type {ScenarioRunState}
     * @memberof ScenarioRun
     */
    'state'?: ScenarioRunState;
    /**
     * the Organization id
     * @type {string}
     * @memberof ScenarioRun
     */
    'organizationId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof ScenarioRun
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech Simulation Run Id
     * @type {string}
     * @memberof ScenarioRun
     */
    'csmSimulationRun'?: string;
    /**
     * the base name for workflow name generation
     * @type {string}
     * @memberof ScenarioRun
     */
    'generateName'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof ScenarioRun
     */
    'workflowName'?: string;
    /**
     * the user id which own this scenariorun
     * @type {string}
     * @memberof ScenarioRun
     */
    'ownerId'?: string;
    /**
     * the Workspace Id
     * @type {string}
     * @memberof ScenarioRun
     */
    'workspaceId'?: string;
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof ScenarioRun
     */
    'workspaceKey'?: string;
    /**
     * the Scenario Id
     * @type {string}
     * @memberof ScenarioRun
     */
    'scenarioId'?: string;
    /**
     * the Solution Id
     * @type {string}
     * @memberof ScenarioRun
     */
    'solutionId'?: string;
    /**
     * the Solution Run Template id
     * @type {string}
     * @memberof ScenarioRun
     */
    'runTemplateId'?: string;
    /**
     * the compute size needed for this Analysis. Standard sizes are basic and highcpu. Default is basic
     * @type {string}
     * @memberof ScenarioRun
     */
    'computeSize'?: string;
    /**
     * the MAJOR.MINOR version used to build the solution solution
     * @type {string}
     * @memberof ScenarioRun
     */
    'sdkVersion'?: string;
    /**
     * the ScenarioRun creation date
     * @type {string}
     * @memberof ScenarioRun
     */
    'createdAt'?: string;
    /**
     * set to true if the run template does not use any Datawarehouse consumers (AMQP consumers for Azure)
     * @type {boolean}
     * @memberof ScenarioRun
     */
    'noDataIngestionState'?: boolean;
    /**
     * the list of Dataset Id associated to this Analysis
     * @type {Array<string>}
     * @memberof ScenarioRun
     */
    'datasetList'?: Array<string>;
    /**
     * the list of Run Template parameters values
     * @type {Array<RunTemplateParameterValue>}
     * @memberof ScenarioRun
     */
    'parametersValues'?: Array<RunTemplateParameterValue>;
    /**
     * whether or not the Datasets values are send to the DataWarehouse prior to Simulation Run. If not set follow the Workspace setting
     * @type {boolean}
     * @memberof ScenarioRun
     */
    'sendDatasetsToDataWarehouse'?: boolean;
    /**
     * whether or not the input parameters values are send to the DataWarehouse prior to Simulation Run. If not set follow the Workspace setting
     * @type {boolean}
     * @memberof ScenarioRun
     */
    'sendInputParametersToDataWarehouse'?: boolean;
    /**
     * the node label request
     * @type {string}
     * @memberof ScenarioRun
     */
    'nodeLabel'?: string;
    /**
     * the containers list. This information is not returned by the API.
     * @type {Array<ScenarioRunContainer>}
     * @memberof ScenarioRun
     */
    'containers'?: Array<ScenarioRunContainer>;
}


/**
 * a ScenarioRun container description
 * @export
 * @interface ScenarioRunContainer
 */
export interface ScenarioRunContainer {
    /**
     * the container Id
     * @type {string}
     * @memberof ScenarioRunContainer
     */
    'id'?: string;
    /**
     * the container name
     * @type {string}
     * @memberof ScenarioRunContainer
     */
    'name': string;
    /**
     * the metadata labels
     * @type {{ [key: string]: string; }}
     * @memberof ScenarioRunContainer
     */
    'labels'?: { [key: string]: string; };
    /**
     * environment variable map
     * @type {{ [key: string]: string; }}
     * @memberof ScenarioRunContainer
     */
    'envVars'?: { [key: string]: string; };
    /**
     * the container image URI
     * @type {string}
     * @memberof ScenarioRunContainer
     */
    'image': string;
    /**
     * the container entry point
     * @type {string}
     * @memberof ScenarioRunContainer
     */
    'entrypoint'?: string;
    /**
     * the list of run arguments for the container
     * @type {Array<string>}
     * @memberof ScenarioRunContainer
     */
    'runArgs'?: Array<string>;
    /**
     * the list of dependencies container name to run this container
     * @type {Array<string>}
     * @memberof ScenarioRunContainer
     */
    'dependencies'?: Array<string>;
    /**
     * whether or not this container is a Cosmo Tech solution container
     * @type {boolean}
     * @memberof ScenarioRunContainer
     */
    'solutionContainer'?: boolean;
    /**
     * the node label request
     * @type {string}
     * @memberof ScenarioRunContainer
     */
    'nodeLabel'?: string;
    /**
     * 
     * @type {ContainerResourceSizing}
     * @memberof ScenarioRunContainer
     */
    'runSizing'?: ContainerResourceSizing;
    /**
     * the list of artifacts
     * @type {Array<ScenarioRunContainerArtifact>}
     * @memberof ScenarioRunContainer
     */
    'artifacts'?: Array<ScenarioRunContainerArtifact>;
}
/**
 * a scenario run container artifact
 * @export
 * @interface ScenarioRunContainerArtifact
 */
export interface ScenarioRunContainerArtifact {
    /**
     * the artifact name
     * @type {string}
     * @memberof ScenarioRunContainerArtifact
     */
    'name'?: string;
    /**
     * the artifact path (relative to /var/csmoutput)
     * @type {string}
     * @memberof ScenarioRunContainerArtifact
     */
    'path'?: string;
}
/**
 * logs for a given container
 * @export
 * @interface ScenarioRunContainerLogs
 */
export interface ScenarioRunContainerLogs {
    /**
     * the node Id which has executed this log
     * @type {string}
     * @memberof ScenarioRunContainerLogs
     */
    'nodeId'?: string;
    /**
     * the container name
     * @type {string}
     * @memberof ScenarioRunContainerLogs
     */
    'containerName'?: string;
    /**
     * the list of children node id
     * @type {Array<string>}
     * @memberof ScenarioRunContainerLogs
     */
    'children'?: Array<string>;
    /**
     * the node logs in plain text
     * @type {string}
     * @memberof ScenarioRunContainerLogs
     */
    'logs'?: string;
}
/**
 * the scenariorun logs returned by all containers
 * @export
 * @interface ScenarioRunLogs
 */
export interface ScenarioRunLogs {
    /**
     * the ScenarioRun Id
     * @type {string}
     * @memberof ScenarioRunLogs
     */
    'scenariorunId'?: string;
    /**
     * the container map of logs
     * @type {{ [key: string]: ScenarioRunContainerLogs; }}
     * @memberof ScenarioRunLogs
     */
    'containers'?: { [key: string]: ScenarioRunContainerLogs; };
}
/**
 * the memory and CPU requested by the pod
 * @export
 * @interface ScenarioRunResourceRequested
 */
export interface ScenarioRunResourceRequested {
    /**
     * the cpu requested
     * @type {number}
     * @memberof ScenarioRunResourceRequested
     */
    'cpu'?: number;
    /**
     * the memory requested
     * @type {number}
     * @memberof ScenarioRunResourceRequested
     */
    'memory'?: number;
}
/**
 * the search options
 * @export
 * @interface ScenarioRunSearch
 */
export interface ScenarioRunSearch {
    /**
     * the Solution Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'solutionId'?: string;
    /**
     * the Solution Analysis Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'runTemplateId'?: string;
    /**
     * the Workspace Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'workspaceId'?: string;
    /**
     * the Scenario Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'scenarioId'?: string;
    /**
     * 
     * @type {ScenarioRunSearchState}
     * @memberof ScenarioRunSearch
     */
    'state'?: ScenarioRunSearchState;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'workflowName'?: string;
    /**
     * the owner Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'ownerId'?: string;
}


/**
 * the state to search
 * @export
 * @enum {string}
 */

export const ScenarioRunSearchState = {
    FetchingDatasets: 'FetchingDatasets',
    FetchingScenarioParameters: 'FetchingScenarioParameters',
    ApplyingScenarioParameters: 'ApplyingScenarioParameters',
    ValidatingScenarioData: 'ValidatingScenarioData',
    SendingScenarioDataToDataWarehouse: 'SendingScenarioDataToDataWarehouse',
    PreRun: 'PreRun',
    Running: 'Running',
    PostRun: 'PostRun',
    Success: 'Success',
    Failed: 'Failed'
} as const;

export type ScenarioRunSearchState = typeof ScenarioRunSearchState[keyof typeof ScenarioRunSearchState];


/**
 * the parameters to run directly containers
 * @export
 * @interface ScenarioRunStartContainers
 */
export interface ScenarioRunStartContainers {
    /**
     * the base name for workflow name generation
     * @type {string}
     * @memberof ScenarioRunStartContainers
     */
    'generateName'?: string;
    /**
     * Cosmo Tech Simulation Run Id
     * @type {string}
     * @memberof ScenarioRunStartContainers
     */
    'csmSimulationId': string;
    /**
     * the node label request
     * @type {string}
     * @memberof ScenarioRunStartContainers
     */
    'nodeLabel'?: string;
    /**
     * the workflow labels
     * @type {{ [key: string]: string; }}
     * @memberof ScenarioRunStartContainers
     */
    'labels'?: { [key: string]: string; };
    /**
     * the containerslist
     * @type {Array<ScenarioRunContainer>}
     * @memberof ScenarioRunStartContainers
     */
    'containers': Array<ScenarioRunContainer>;
}
/**
 * the ScenarioRun end-to-end state
 * @export
 * @enum {string}
 */

export const ScenarioRunState = {
    Running: 'Running',
    Successful: 'Successful',
    Failed: 'Failed',
    Unknown: 'Unknown',
    DataIngestionInProgress: 'DataIngestionInProgress',
    DataIngestionFailure: 'DataIngestionFailure'
} as const;

export type ScenarioRunState = typeof ScenarioRunState[keyof typeof ScenarioRunState];


/**
 * a ScenarioRun status
 * @export
 * @interface ScenarioRunStatus
 */
export interface ScenarioRunStatus {
    /**
     * the ScenarioRun id
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'id'?: string;
    /**
     * the ScenarioRun id
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'organizationId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'workflowName'?: string;
    /**
     * the ScenarioRun start Date Time
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'startTime'?: string;
    /**
     * the ScenarioRun end Date Time
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'endTime'?: string;
    /**
     * high-level summary of where the workflow is in its lifecycle
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'phase'?: string;
    /**
     * progress to completion
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'progress'?: string;
    /**
     * a  human readable message indicating details about why the workflow is in this condition
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'message'?: string;
    /**
     * estimatedDuration in seconds
     * @type {number}
     * @memberof ScenarioRunStatus
     */
    'estimatedDuration'?: number;
    /**
     * status of ScenarioRun nodes
     * @type {Array<ScenarioRunStatusNode>}
     * @memberof ScenarioRunStatus
     */
    'nodes'?: Array<ScenarioRunStatusNode>;
    /**
     * 
     * @type {ScenarioRunState}
     * @memberof ScenarioRunStatus
     */
    'state'?: ScenarioRunState;
}


/**
 * status of a ScenarioRun Node
 * @export
 * @interface ScenarioRunStatusNode
 */
export interface ScenarioRunStatusNode {
    /**
     * the node id
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'id'?: string;
    /**
     * the node unique name
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'name'?: string;
    /**
     * the ScenarioRun container name
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'containerName'?: string;
    /**
     * the list of outbound nodes
     * @type {Array<string>}
     * @memberof ScenarioRunStatusNode
     */
    'outboundNodes'?: Array<string>;
    /**
     * 
     * @type {ScenarioRunResourceRequested}
     * @memberof ScenarioRunStatusNode
     */
    'resourcesDuration'?: ScenarioRunResourceRequested;
    /**
     * estimatedDuration in seconds
     * @type {number}
     * @memberof ScenarioRunStatusNode
     */
    'estimatedDuration'?: number;
    /**
     * HostNodeName name of the Kubernetes node on which the Pod is running, if applicable
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'hostNodeName'?: string;
    /**
     * a human readable message indicating details about why the node is in this condition
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'message'?: string;
    /**
     * high-level summary of where the node is in its lifecycle
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'phase'?: string;
    /**
     * progress to completion
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'progress'?: string;
    /**
     * the node start time
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'startTime'?: string;
    /**
     * the node end time
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'endTime'?: string;
}
/**
 * the value of a Solution Run Template parameter for a Scenario
 * @export
 * @interface ScenarioRunTemplateParameterValue
 */
export interface ScenarioRunTemplateParameterValue {
    /**
     * the parameter Id
     * @type {string}
     * @memberof ScenarioRunTemplateParameterValue
     */
    'parameterId': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof ScenarioRunTemplateParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value
     * @type {string}
     * @memberof ScenarioRunTemplateParameterValue
     */
    'value': string;
    /**
     * whether or not the value is inherited from parent or has been changed
     * @type {boolean}
     * @memberof ScenarioRunTemplateParameterValue
     */
    'isInherited'?: boolean;
}
/**
 * the Scenario security information
 * @export
 * @interface ScenarioSecurity
 */
export interface ScenarioSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof ScenarioSecurity
     */
    'default': string;
    /**
     * the list which can access this Scenario with detailed access control information
     * @type {Array<ScenarioAccessControl>}
     * @memberof ScenarioSecurity
     */
    'accessControlList': Array<ScenarioAccessControl>;
}
/**
 * the validation status of the scenario
 * @export
 * @enum {string}
 */

export const ScenarioValidationStatus = {
    Draft: 'Draft',
    Rejected: 'Rejected',
    Unknown: 'Unknown',
    Validated: 'Validated'
} as const;

export type ScenarioValidationStatus = typeof ScenarioValidationStatus[keyof typeof ScenarioValidationStatus];


/**
 * 
 * @export
 * @interface SendRunDataRequest
 */
export interface SendRunDataRequest {
    /**
     * 
     * @type {string}
     * @memberof SendRunDataRequest
     */
    'id'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof SendRunDataRequest
     */
    'data'?: Array<{ [key: string]: any; }>;
}
/**
 * a version of a Solution
 * @export
 * @interface Solution
 */
export interface Solution {
    /**
     * the Solution version unique identifier
     * @type {string}
     * @memberof Solution
     */
    'id'?: string;
    /**
     * the Organization unique identifier
     * @type {string}
     * @memberof Solution
     */
    'organizationId'?: string;
    /**
     * the Solution key which group Solution versions
     * @type {string}
     * @memberof Solution
     */
    'key'?: string;
    /**
     * the Solution name
     * @type {string}
     * @memberof Solution
     */
    'name'?: string;
    /**
     * the Solution description
     * @type {string}
     * @memberof Solution
     */
    'description'?: string;
    /**
     * the registry repository containing the image
     * @type {string}
     * @memberof Solution
     */
    'repository'?: string;
    /**
     * set to true if the runtemplate wants to always pull the image
     * @type {boolean}
     * @memberof Solution
     */
    'alwaysPull'?: boolean;
    /**
     * the main Cosmo Tech simulator name used in standard Run Template
     * @type {string}
     * @memberof Solution
     */
    'csmSimulator'?: string;
    /**
     * the Solution version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof Solution
     */
    'version'?: string;
    /**
     * the User id which own this Solution
     * @type {string}
     * @memberof Solution
     */
    'ownerId'?: string;
    /**
     * the MAJOR.MINOR version used to build this solution
     * @type {string}
     * @memberof Solution
     */
    'sdkVersion'?: string;
    /**
     * an optional URL link to solution page
     * @type {string}
     * @memberof Solution
     */
    'url'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Solution
     */
    'tags'?: Array<string>;
    /**
     * the list of Run Template Parameters
     * @type {Array<RunTemplateParameter>}
     * @memberof Solution
     */
    'parameters'?: Array<RunTemplateParameter>;
    /**
     * the list of parameters groups for the Run Templates
     * @type {Array<RunTemplateParameterGroup>}
     * @memberof Solution
     */
    'parameterGroups'?: Array<RunTemplateParameterGroup>;
    /**
     * list of Run Template
     * @type {Array<RunTemplate>}
     * @memberof Solution
     */
    'runTemplates'?: Array<RunTemplate>;
    /**
     * 
     * @type {SolutionSecurity}
     * @memberof Solution
     */
    'security'?: SolutionSecurity;
}
/**
 * a Solution access control item
 * @export
 * @interface SolutionAccessControl
 */
export interface SolutionAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof SolutionAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof SolutionAccessControl
     */
    'role': string;
}
/**
 * the Solution Role
 * @export
 * @interface SolutionRole
 */
export interface SolutionRole {
    /**
     * the Solution Role
     * @type {string}
     * @memberof SolutionRole
     */
    'role': string;
}
/**
 * the Solution security information
 * @export
 * @interface SolutionSecurity
 */
export interface SolutionSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof SolutionSecurity
     */
    'default': string;
    /**
     * the list which can access this Solution with detailed access control information
     * @type {Array<SolutionAccessControl>}
     * @memberof SolutionSecurity
     */
    'accessControlList': Array<SolutionAccessControl>;
}
/**
 * Source job import information
 * @export
 * @interface SourceInfo
 */
export interface SourceInfo {
    /**
     * the source name containing the files to import
     * @type {string}
     * @memberof SourceInfo
     */
    'name'?: string;
    /**
     * the source location containing the files to import
     * @type {string}
     * @memberof SourceInfo
     */
    'location': string;
    /**
     * the source location containing the files to import
     * @type {string}
     * @memberof SourceInfo
     */
    'path'?: string;
    /**
     * indicate the last import jobId
     * @type {string}
     * @memberof SourceInfo
     */
    'jobId'?: string;
}
/**
 * a twin graph query in cypher language
 * @export
 * @interface SubDatasetGraphQuery
 */
export interface SubDatasetGraphQuery {
    /**
     * the name of the subdataset
     * @type {string}
     * @memberof SubDatasetGraphQuery
     */
    'name'?: string;
    /**
     * the description of the subdataset
     * @type {string}
     * @memberof SubDatasetGraphQuery
     */
    'description'?: string;
    /**
     * the query in cypher language
     * @type {Array<string>}
     * @memberof SubDatasetGraphQuery
     */
    'queries'?: Array<string>;
    /**
     * is this the main dataset
     * @type {boolean}
     * @memberof SubDatasetGraphQuery
     */
    'main'?: boolean;
}
/**
 * Processing result
 * @export
 * @interface TwinGraphBatchResult
 */
export interface TwinGraphBatchResult {
    /**
     * 
     * @type {number}
     * @memberof TwinGraphBatchResult
     */
    'totalLines': number;
    /**
     * 
     * @type {number}
     * @memberof TwinGraphBatchResult
     */
    'processedLines': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TwinGraphBatchResult
     */
    'errors': Array<string>;
}
/**
 * a twin graph hash
 * @export
 * @interface TwinGraphHash
 */
export interface TwinGraphHash {
    /**
     * the hash of the graph
     * @type {string}
     * @memberof TwinGraphHash
     */
    'hash'?: string;
}
/**
 * a twin graph query in cypher language
 * @export
 * @interface TwinGraphQuery
 */
export interface TwinGraphQuery {
    /**
     * Twin graph version
     * @type {string}
     * @memberof TwinGraphQuery
     */
    'version'?: string;
    /**
     * the query in cypher language
     * @type {string}
     * @memberof TwinGraphQuery
     */
    'query': string;
}
/**
 * the twincache data status
 * @export
 * @enum {string}
 */

export const TwincacheStatusEnum = {
    Empty: 'EMPTY',
    Full: 'FULL'
} as const;

export type TwincacheStatusEnum = typeof TwincacheStatusEnum[keyof typeof TwincacheStatusEnum];


/**
 * a Validator to validate a Dataset
 * @export
 * @interface Validator
 */
export interface Validator {
    /**
     * the Validator id
     * @type {string}
     * @memberof Validator
     */
    'id': string;
    /**
     * the Validator name
     * @type {string}
     * @memberof Validator
     */
    'name': string;
    /**
     * the Validator description
     * @type {string}
     * @memberof Validator
     */
    'description'?: string;
    /**
     * the registry repository containing the Validator image
     * @type {string}
     * @memberof Validator
     */
    'repository': string;
    /**
     * the Validator version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof Validator
     */
    'version': string;
    /**
     * the User id which own this Validator
     * @type {string}
     * @memberof Validator
     */
    'ownerId'?: string;
    /**
     * an optional URL link to Validator page
     * @type {string}
     * @memberof Validator
     */
    'url'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Validator
     */
    'tags'?: Array<string>;
}
/**
 * a Workspace
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * Workspace unique identifier generated by the API
     * @type {string}
     * @memberof Workspace
     */
    'id'?: string;
    /**
     * Organization unique identifier under which the workspace resides
     * @type {string}
     * @memberof Workspace
     */
    'organizationId'?: string;
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof Workspace
     */
    'key': string;
    /**
     * Workspace name. This name is display in the sample webApp
     * @type {string}
     * @memberof Workspace
     */
    'name': string;
    /**
     * the Workspace description
     * @type {string}
     * @memberof Workspace
     */
    'description'?: string;
    /**
     * list of dataset linked to this dataset
     * @type {Array<string>}
     * @memberof Workspace
     */
    'linkedDatasetIdList'?: Array<string>;
    /**
     * the Workspace version MAJOR.MINOR.PATCH.
     * @type {string}
     * @memberof Workspace
     */
    'version'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Workspace
     */
    'tags'?: Array<string>;
    /**
     * the user id which own this workspace. set by the API from Authentification service receved id
     * @type {string}
     * @memberof Workspace
     */
    'ownerId'?: string;
    /**
     * 
     * @type {WorkspaceSolution}
     * @memberof Workspace
     */
    'solution': WorkspaceSolution;
    /**
     * 
     * @type {WorkspaceWebApp}
     * @memberof Workspace
     */
    'webApp'?: WorkspaceWebApp;
    /**
     * default setting for all Scenarios and Run Templates to set whether or not the Dataset values and the input parameters values are send to the DataWarehouse prior to the ScenarioRun
     * @type {boolean}
     * @memberof Workspace
     */
    'sendInputToDataWarehouse'?: boolean;
    /**
     * Set this property to true to use a dedicated Azure Event Hub Namespace for this Workspace. The Event Hub Namespace must be named \\\'<organization_id\\>-<workspace_id\\>\\\' (in lower case). This Namespace must also contain two Event Hubs named \\\'probesmeasures\\\' and \\\'scenariorun\\\'.
     * @type {boolean}
     * @memberof Workspace
     */
    'useDedicatedEventHubNamespace'?: boolean;
    /**
     * the Dedicated Event Hub SAS key name, default to RootManageSharedAccessKey. Use the /secret endpoint to set the key value
     * @type {string}
     * @memberof Workspace
     */
    'dedicatedEventHubSasKeyName'?: string;
    /**
     * the Event Hub authentication strategy, SHARED_ACCESS_POLICY or TENANT_CLIENT_CREDENTIALS. Default to the one defined for the tenant.
     * @type {string}
     * @memberof Workspace
     */
    'dedicatedEventHubAuthenticationStrategy'?: string;
    /**
     * default setting for all Scenarios and Run Templates to set whether or not the ScenarioRun is send to the Event Hub
     * @type {boolean}
     * @memberof Workspace
     */
    'sendScenarioRunToEventHub'?: boolean;
    /**
     * Set this property to false to not send scenario metada to Azure Event Hub Namespace for this Workspace. The Event Hub Namespace must be named \\\'<organization_id\\>-<workspace_id\\>\\\' (in lower case). This Namespace must also contain two Event Hubs named \\\'scenariometadata\\\' and \\\'scenariorunmetadata\\\'.
     * @type {boolean}
     * @memberof Workspace
     */
    'sendScenarioMetadataToEventHub'?: boolean;
    /**
     * Activate the copy of dataset on scenario creation, meaning that each scenario created in this workspace will make this copy. when false, scenario use directly the dataset specified.
     * @type {boolean}
     * @memberof Workspace
     */
    'datasetCopy'?: boolean;
    /**
     * 
     * @type {WorkspaceSecurity}
     * @memberof Workspace
     */
    'security'?: WorkspaceSecurity;
}
/**
 * a Workspace access control item
 * @export
 * @interface WorkspaceAccessControl
 */
export interface WorkspaceAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof WorkspaceAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof WorkspaceAccessControl
     */
    'role': string;
}
/**
 * a Workspace File resource
 * @export
 * @interface WorkspaceFile
 */
export interface WorkspaceFile {
    /**
     * the Workspace File name
     * @type {string}
     * @memberof WorkspaceFile
     */
    'fileName'?: string;
}
/**
 * the Workspace Role
 * @export
 * @interface WorkspaceRole
 */
export interface WorkspaceRole {
    /**
     * the Workspace Role
     * @type {string}
     * @memberof WorkspaceRole
     */
    'role': string;
}
/**
 * the secret definition
 * @export
 * @interface WorkspaceSecret
 */
export interface WorkspaceSecret {
    /**
     * the dedicated event hub shared access key
     * @type {string}
     * @memberof WorkspaceSecret
     */
    'dedicatedEventHubKey'?: string;
}
/**
 * the workspace security information
 * @export
 * @interface WorkspaceSecurity
 */
export interface WorkspaceSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof WorkspaceSecurity
     */
    'default': string;
    /**
     * the list which can access this Workspace with detailed access control information
     * @type {Array<WorkspaceAccessControl>}
     * @memberof WorkspaceSecurity
     */
    'accessControlList': Array<WorkspaceAccessControl>;
}
/**
 * the Workspace Solution configuration
 * @export
 * @interface WorkspaceSolution
 */
export interface WorkspaceSolution {
    /**
     * the Solution Id attached to this workspace
     * @type {string}
     * @memberof WorkspaceSolution
     */
    'solutionId'?: string;
    /**
     * the list of Solution Run Template Id to filter
     * @type {Array<string>}
     * @memberof WorkspaceSolution
     */
    'runTemplateFilter'?: Array<string>;
    /**
     * a map of RunTemplateId/DatasetId to set a default dataset for a Run Template
     * @type {{ [key: string]: any; }}
     * @memberof WorkspaceSolution
     */
    'defaultRunTemplateDataset'?: { [key: string]: any; };
}
/**
 * a Workspace Web Application
 * @export
 * @interface WorkspaceWebApp
 */
export interface WorkspaceWebApp {
    /**
     * the Workspace Web Application URL
     * @type {string}
     * @memberof WorkspaceWebApp
     */
    'url': string;
    /**
     * a map of iframeKey/iframeURL
     * @type {{ [key: string]: any; }}
     * @memberof WorkspaceWebApp
     */
    'iframes'?: { [key: string]: any; };
    /**
     * free form options for Web Application
     * @type {{ [key: string]: any; }}
     * @memberof WorkspaceWebApp
     */
    'options'?: { [key: string]: any; };
}

/**
 * ConnectorApi - axios parameter creator
 * @export
 */
export const ConnectorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllConnectors: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findConnectorById: async (connectorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('findConnectorById', 'connectorId', connectorId)
            const localVarPath = `/connectors/{connector_id}`
                .replace(`{${"connector_id"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorName the Connector name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findConnectorByName: async (connectorName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorName' is not null or undefined
            assertParamExists('findConnectorByName', 'connectorName', connectorName)
            const localVarPath = `/connectors/name/{connector_name}`
                .replace(`{${"connector_name"}}`, encodeURIComponent(String(connectorName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerConnector: async (connector: Connector, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connector' is not null or undefined
            assertParamExists('registerConnector', 'connector', connector)
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connector, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterConnector: async (connectorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('unregisterConnector', 'connectorId', connectorId)
            const localVarPath = `/connectors/{connector_id}`
                .replace(`{${"connector_id"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorApi - functional programming interface
 * @export
 */
export const ConnectorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllConnectors(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Connector>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllConnectors(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorApi.findAllConnectors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findConnectorById(connectorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findConnectorById(connectorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorApi.findConnectorById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorName the Connector name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findConnectorByName(connectorName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findConnectorByName(connectorName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorApi.findConnectorByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerConnector(connector: Connector, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerConnector(connector, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorApi.registerConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unregisterConnector(connectorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unregisterConnector(connectorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorApi.unregisterConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectorApi - factory interface
 * @export
 */
export const ConnectorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllConnectors(page?: number, size?: number, options?: any): AxiosPromise<Array<Connector>> {
            return localVarFp.findAllConnectors(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findConnectorById(connectorId: string, options?: any): AxiosPromise<Connector> {
            return localVarFp.findConnectorById(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorName the Connector name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findConnectorByName(connectorName: string, options?: any): AxiosPromise<Connector> {
            return localVarFp.findConnectorByName(connectorName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerConnector(connector: Connector, options?: any): AxiosPromise<Connector> {
            return localVarFp.registerConnector(connector, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterConnector(connectorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unregisterConnector(connectorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorApi - object-oriented interface
 * @export
 * @class ConnectorApi
 * @extends {BaseAPI}
 */
export class ConnectorApi extends BaseAPI {
    /**
     * 
     * @summary List all Connectors
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public findAllConnectors(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).findAllConnectors(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a connector
     * @param {string} connectorId the Connector identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public findConnectorById(connectorId: string, options?: RawAxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).findConnectorById(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a connector
     * @param {string} connectorName the Connector name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public findConnectorByName(connectorName: string, options?: RawAxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).findConnectorByName(connectorName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new connector
     * @param {Connector} connector the Connector to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public registerConnector(connector: Connector, options?: RawAxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).registerConnector(connector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unregister a connector
     * @param {string} connectorId the Connector identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public unregisterConnector(connectorId: string, options?: RawAxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).unregisterConnector(connectorId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatasetApi - axios parameter creator
 * @export
 */
export const DatasetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a control access to the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDatasetAccessControl: async (organizationId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('addDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'datasetAccessControl' is not null or undefined
            assertParamExists('addDatasetAccessControl', 'datasetAccessControl', datasetAccessControl)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceDatasetCompatibilityElements: async (organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'datasetId', datasetId)
            // verify required parameter 'datasetCompatibility' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'datasetCompatibility', datasetCompatibility)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/compatibility`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetCompatibility, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Not implemented!
         * @summary Copy a Dataset to another Dataset.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyDataset: async (organizationId: string, datasetCopyParameters: DatasetCopyParameters, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('copyDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetCopyParameters' is not null or undefined
            assertParamExists('copyDataset', 'datasetCopyParameters', datasetCopyParameters)
            const localVarPath = `/organizations/{organization_id}/datasets/copy`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetCopyParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset: async (organizationId: string, dataset: Dataset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createDataset', 'organizationId', organizationId)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('createDataset', 'dataset', dataset)
            const localVarPath = `/organizations/{organization_id}/datasets`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a copy of the dataset using the results of the list of queries given in parameter.
         * @summary Create a sub-dataset from the dataset in parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {SubDatasetGraphQuery} subDatasetGraphQuery the Cypher query to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubDataset: async (organizationId: string, datasetId: string, subDatasetGraphQuery: SubDatasetGraphQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSubDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('createSubDataset', 'datasetId', datasetId)
            // verify required parameter 'subDatasetGraphQuery' is not null or undefined
            assertParamExists('createSubDataset', 'subDatasetGraphQuery', subDatasetGraphQuery)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/subdataset`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subDatasetGraphQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create new entities in a graph instance
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {CreateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTwingraphEntities: async (organizationId: string, datasetId: string, type: CreateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createTwingraphEntities', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('createTwingraphEntities', 'datasetId', datasetId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createTwingraphEntities', 'type', type)
            // verify required parameter 'graphProperties' is not null or undefined
            assertParamExists('createTwingraphEntities', 'graphProperties', graphProperties)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(graphProperties, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteDataset', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete entities in a graph instance
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DeleteTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTwingraphEntities: async (organizationId: string, datasetId: string, type: DeleteTwingraphEntitiesTypeEnum, ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteTwingraphEntities', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteTwingraphEntities', 'datasetId', datasetId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteTwingraphEntities', 'type', type)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteTwingraphEntities', 'ids', ids)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download the compressed graph reference by the hash in a zip file
         * @summary Download a graph as a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTwingraph: async (organizationId: string, hash: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadTwingraph', 'organizationId', organizationId)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('downloadTwingraph', 'hash', hash)
            const localVarPath = `/organizations/{organization_id}/datasets/twingraph/download/{hash}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDatasets: async (organizationId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllDatasets', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/datasets`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDatasetById: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findDatasetById', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('findDatasetById', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetAccessControl: async (organizationId: string, datasetId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getDatasetAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Dataset security information
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetSecurity: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetSecurity', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetSecurity', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Dataset security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetSecurityUsers: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetSecurityUsers', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of the import workflow lauch on the dataset\'s refresh. This endpoint needs to be called to update a dataset IngestionStatus or TwincacheStatus
         * @summary Get the dataset\'s refresh job status
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetTwingraphStatus: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetTwingraphStatus', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetTwingraphStatus', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/status`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get entities in a graph instance
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {GetTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwingraphEntities: async (organizationId: string, datasetId: string, type: GetTwingraphEntitiesTypeEnum, ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getTwingraphEntities', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getTwingraphEntities', 'datasetId', datasetId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getTwingraphEntities', 'type', type)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getTwingraphEntities', 'ids', ids)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkWorkspace: async (organizationId: string, datasetId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('linkWorkspace', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('linkWorkspace', 'datasetId', datasetId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('linkWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/link`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh dataset from parent source. At date, sources can be:      dataset (refresh from another dataset)      Azure Digital twin       Azure storage      Local File (import a new file)  During refresh, datas are overwritten 
         * @summary Refresh data on dataset from dataset\'s source
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshDataset: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('refreshDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('refreshDataset', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/refresh`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllDatasetCompatibilityElements: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllDatasetCompatibilityElements', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('removeAllDatasetCompatibilityElements', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/compatibility`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatasetAccessControl: async (organizationId: string, datasetId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('removeDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeDatasetAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rollback the twingraph on a dataset after a failed refresh
         * @summary Rollback the dataset after a failed refresh
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackRefresh: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('rollbackRefresh', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('rollbackRefresh', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/refresh/rollback`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Datasets by tags
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDatasets: async (organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('searchDatasets', 'organizationId', organizationId)
            // verify required parameter 'datasetSearch' is not null or undefined
            assertParamExists('searchDatasets', 'datasetSearch', datasetSearch)
            const localVarPath = `/organizations/{organization_id}/datasets/search`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Dataset default security
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDatasetDefaultSecurity: async (organizationId: string, datasetId: string, datasetRole: DatasetRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setDatasetDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('setDatasetDefaultSecurity', 'datasetId', datasetId)
            // verify required parameter 'datasetRole' is not null or undefined
            assertParamExists('setDatasetDefaultSecurity', 'datasetRole', datasetRole)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Graph Identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphBatchQuery: async (organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('twingraphBatchQuery', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('twingraphBatchQuery', 'datasetId', datasetId)
            // verify required parameter 'datasetTwinGraphQuery' is not null or undefined
            assertParamExists('twingraphBatchQuery', 'datasetTwinGraphQuery', datasetTwinGraphQuery)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/batch-query`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetTwinGraphQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Async batch update by loading a CSV file on a graph instance 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DatasetTwinGraphQuery} twinGraphQuery 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphBatchUpdate: async (organizationId: string, datasetId: string, twinGraphQuery: DatasetTwinGraphQuery, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('twingraphBatchUpdate', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('twingraphBatchUpdate', 'datasetId', datasetId)
            // verify required parameter 'twinGraphQuery' is not null or undefined
            assertParamExists('twingraphBatchUpdate', 'twinGraphQuery', twinGraphQuery)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('twingraphBatchUpdate', 'body', body)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/batch`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (twinGraphQuery !== undefined) {
                for (const [key, value] of Object.entries(twinGraphQuery)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/csv';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a query on a graph instance and return the result as a json
         * @summary Return the result of a query made on the graph instance as a json
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphQuery: async (organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('twingraphQuery', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('twingraphQuery', 'datasetId', datasetId)
            // verify required parameter 'datasetTwinGraphQuery' is not null or undefined
            assertParamExists('twingraphQuery', 'datasetTwinGraphQuery', datasetTwinGraphQuery)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetTwinGraphQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkWorkspace: async (organizationId: string, datasetId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('unlinkWorkspace', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('unlinkWorkspace', 'datasetId', datasetId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('unlinkWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/unlink`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset: async (organizationId: string, datasetId: string, dataset: Dataset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateDataset', 'datasetId', datasetId)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('updateDataset', 'dataset', dataset)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {DatasetRole} datasetRole The new Dataset Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatasetAccessControl: async (organizationId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'identityId', identityId)
            // verify required parameter 'datasetRole' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'datasetRole', datasetRole)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {UpdateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTwingraphEntities: async (organizationId: string, datasetId: string, type: UpdateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateTwingraphEntities', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateTwingraphEntities', 'datasetId', datasetId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('updateTwingraphEntities', 'type', type)
            // verify required parameter 'graphProperties' is not null or undefined
            assertParamExists('updateTwingraphEntities', 'graphProperties', graphProperties)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(graphProperties, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. 
         * @summary Upload data from zip file to dataset\'s twingraph
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTwingraph: async (organizationId: string, datasetId: string, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('uploadTwingraph', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('uploadTwingraph', 'datasetId', datasetId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadTwingraph', 'body', body)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetApi - functional programming interface
 * @export
 */
export const DatasetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDatasetAccessControl(organizationId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDatasetAccessControl(organizationId, datasetId, datasetAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.addDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DatasetCompatibility>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.addOrReplaceDatasetCompatibilityElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Not implemented!
         * @summary Copy a Dataset to another Dataset.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetCopyParameters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyDataset(organizationId, datasetCopyParameters, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.copyDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataset(organizationId: string, dataset: Dataset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataset(organizationId, dataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a copy of the dataset using the results of the list of queries given in parameter.
         * @summary Create a sub-dataset from the dataset in parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {SubDatasetGraphQuery} subDatasetGraphQuery the Cypher query to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubDataset(organizationId: string, datasetId: string, subDatasetGraphQuery: SubDatasetGraphQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubDataset(organizationId, datasetId, subDatasetGraphQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createSubDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create new entities in a graph instance
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {CreateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTwingraphEntities(organizationId: string, datasetId: string, type: CreateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTwingraphEntities(organizationId, datasetId, type, graphProperties, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createTwingraphEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataset(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.deleteDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete entities in a graph instance
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DeleteTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTwingraphEntities(organizationId: string, datasetId: string, type: DeleteTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTwingraphEntities(organizationId, datasetId, type, ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.deleteTwingraphEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download the compressed graph reference by the hash in a zip file
         * @summary Download a graph as a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTwingraph(organizationId: string, hash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTwingraph(organizationId, hash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.downloadTwingraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllDatasets(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllDatasets(organizationId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.findAllDatasets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDatasetById(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDatasetById(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.findDatasetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetAccessControl(organizationId, datasetId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Dataset security information
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetSecurity(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetSecurity(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Dataset security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetSecurityUsers(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetSecurityUsers(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the status of the import workflow lauch on the dataset\'s refresh. This endpoint needs to be called to update a dataset IngestionStatus or TwincacheStatus
         * @summary Get the dataset\'s refresh job status
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetTwingraphStatus(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetTwingraphStatus(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetTwingraphStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get entities in a graph instance
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {GetTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTwingraphEntities(organizationId: string, datasetId: string, type: GetTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTwingraphEntities(organizationId, datasetId, type, ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getTwingraphEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkWorkspace(organizationId, datasetId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.linkWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refresh dataset from parent source. At date, sources can be:      dataset (refresh from another dataset)      Azure Digital twin       Azure storage      Local File (import a new file)  During refresh, datas are overwritten 
         * @summary Refresh data on dataset from dataset\'s source
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetTwinGraphInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshDataset(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.refreshDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllDatasetCompatibilityElements(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.removeAllDatasetCompatibilityElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDatasetAccessControl(organizationId, datasetId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.removeDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rollback the twingraph on a dataset after a failed refresh
         * @summary Rollback the dataset after a failed refresh
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rollbackRefresh(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rollbackRefresh(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.rollbackRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Datasets by tags
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDatasets(organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDatasets(organizationId, datasetSearch, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.searchDatasets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Dataset default security
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDatasetDefaultSecurity(organizationId: string, datasetId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDatasetDefaultSecurity(organizationId, datasetId, datasetRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.setDatasetDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Graph Identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async twingraphBatchQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetTwinGraphHash>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.twingraphBatchQuery(organizationId, datasetId, datasetTwinGraphQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.twingraphBatchQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Async batch update by loading a CSV file on a graph instance 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DatasetTwinGraphQuery} twinGraphQuery 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async twingraphBatchUpdate(organizationId: string, datasetId: string, twinGraphQuery: DatasetTwinGraphQuery, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwinGraphBatchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.twingraphBatchUpdate(organizationId, datasetId, twinGraphQuery, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.twingraphBatchUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Run a query on a graph instance and return the result as a json
         * @summary Return the result of a query made on the graph instance as a json
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async twingraphQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.twingraphQuery(organizationId, datasetId, datasetTwinGraphQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.twingraphQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkWorkspace(organizationId, datasetId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.unlinkWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataset(organizationId, datasetId, dataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {DatasetRole} datasetRole The new Dataset Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDatasetAccessControl(organizationId, datasetId, identityId, datasetRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {UpdateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTwingraphEntities(organizationId: string, datasetId: string, type: UpdateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTwingraphEntities(organizationId, datasetId, type, graphProperties, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateTwingraphEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. 
         * @summary Upload data from zip file to dataset\'s twingraph
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadTwingraph(organizationId: string, datasetId: string, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadValidation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadTwingraph(organizationId, datasetId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.uploadTwingraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatasetApi - factory interface
 * @export
 */
export const DatasetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDatasetAccessControl(organizationId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options?: any): AxiosPromise<DatasetAccessControl> {
            return localVarFp.addDatasetAccessControl(organizationId, datasetId, datasetAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: any): AxiosPromise<Array<DatasetCompatibility>> {
            return localVarFp.addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options).then((request) => request(axios, basePath));
        },
        /**
         * Not implemented!
         * @summary Copy a Dataset to another Dataset.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: any): AxiosPromise<DatasetCopyParameters> {
            return localVarFp.copyDataset(organizationId, datasetCopyParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset(organizationId: string, dataset: Dataset, options?: any): AxiosPromise<Dataset> {
            return localVarFp.createDataset(organizationId, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a copy of the dataset using the results of the list of queries given in parameter.
         * @summary Create a sub-dataset from the dataset in parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {SubDatasetGraphQuery} subDatasetGraphQuery the Cypher query to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubDataset(organizationId: string, datasetId: string, subDatasetGraphQuery: SubDatasetGraphQuery, options?: any): AxiosPromise<Dataset> {
            return localVarFp.createSubDataset(organizationId, datasetId, subDatasetGraphQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * create new entities in a graph instance
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {CreateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTwingraphEntities(organizationId: string, datasetId: string, type: CreateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: any): AxiosPromise<string> {
            return localVarFp.createTwingraphEntities(organizationId, datasetId, type, graphProperties, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset(organizationId: string, datasetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDataset(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete entities in a graph instance
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DeleteTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTwingraphEntities(organizationId: string, datasetId: string, type: DeleteTwingraphEntitiesTypeEnum, ids: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTwingraphEntities(organizationId, datasetId, type, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Download the compressed graph reference by the hash in a zip file
         * @summary Download a graph as a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTwingraph(organizationId: string, hash: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadTwingraph(organizationId, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDatasets(organizationId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<Dataset>> {
            return localVarFp.findAllDatasets(organizationId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDatasetById(organizationId: string, datasetId: string, options?: any): AxiosPromise<Dataset> {
            return localVarFp.findDatasetById(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: any): AxiosPromise<DatasetAccessControl> {
            return localVarFp.getDatasetAccessControl(organizationId, datasetId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Dataset security information
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetSecurity(organizationId: string, datasetId: string, options?: any): AxiosPromise<DatasetSecurity> {
            return localVarFp.getDatasetSecurity(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Dataset security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetSecurityUsers(organizationId: string, datasetId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getDatasetSecurityUsers(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of the import workflow lauch on the dataset\'s refresh. This endpoint needs to be called to update a dataset IngestionStatus or TwincacheStatus
         * @summary Get the dataset\'s refresh job status
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetTwingraphStatus(organizationId: string, datasetId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getDatasetTwingraphStatus(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * get entities in a graph instance
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {GetTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwingraphEntities(organizationId: string, datasetId: string, type: GetTwingraphEntitiesTypeEnum, ids: Array<string>, options?: any): AxiosPromise<string> {
            return localVarFp.getTwingraphEntities(organizationId, datasetId, type, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: any): AxiosPromise<Dataset> {
            return localVarFp.linkWorkspace(organizationId, datasetId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh dataset from parent source. At date, sources can be:      dataset (refresh from another dataset)      Azure Digital twin       Azure storage      Local File (import a new file)  During refresh, datas are overwritten 
         * @summary Refresh data on dataset from dataset\'s source
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshDataset(organizationId: string, datasetId: string, options?: any): AxiosPromise<DatasetTwinGraphInfo> {
            return localVarFp.refreshDataset(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllDatasetCompatibilityElements(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeDatasetAccessControl(organizationId, datasetId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rollback the twingraph on a dataset after a failed refresh
         * @summary Rollback the dataset after a failed refresh
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackRefresh(organizationId: string, datasetId: string, options?: any): AxiosPromise<string> {
            return localVarFp.rollbackRefresh(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Datasets by tags
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDatasets(organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options?: any): AxiosPromise<Array<Dataset>> {
            return localVarFp.searchDatasets(organizationId, datasetSearch, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Dataset default security
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDatasetDefaultSecurity(organizationId: string, datasetId: string, datasetRole: DatasetRole, options?: any): AxiosPromise<DatasetSecurity> {
            return localVarFp.setDatasetDefaultSecurity(organizationId, datasetId, datasetRole, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Graph Identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphBatchQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: any): AxiosPromise<DatasetTwinGraphHash> {
            return localVarFp.twingraphBatchQuery(organizationId, datasetId, datasetTwinGraphQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Async batch update by loading a CSV file on a graph instance 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DatasetTwinGraphQuery} twinGraphQuery 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphBatchUpdate(organizationId: string, datasetId: string, twinGraphQuery: DatasetTwinGraphQuery, body: File, options?: any): AxiosPromise<TwinGraphBatchResult> {
            return localVarFp.twingraphBatchUpdate(organizationId, datasetId, twinGraphQuery, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a query on a graph instance and return the result as a json
         * @summary Return the result of a query made on the graph instance as a json
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.twingraphQuery(organizationId, datasetId, datasetTwinGraphQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: any): AxiosPromise<Dataset> {
            return localVarFp.unlinkWorkspace(organizationId, datasetId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: any): AxiosPromise<Dataset> {
            return localVarFp.updateDataset(organizationId, datasetId, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {DatasetRole} datasetRole The new Dataset Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options?: any): AxiosPromise<DatasetAccessControl> {
            return localVarFp.updateDatasetAccessControl(organizationId, datasetId, identityId, datasetRole, options).then((request) => request(axios, basePath));
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {UpdateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTwingraphEntities(organizationId: string, datasetId: string, type: UpdateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: any): AxiosPromise<string> {
            return localVarFp.updateTwingraphEntities(organizationId, datasetId, type, graphProperties, options).then((request) => request(axios, basePath));
        },
        /**
         * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. 
         * @summary Upload data from zip file to dataset\'s twingraph
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTwingraph(organizationId: string, datasetId: string, body: File, options?: any): AxiosPromise<FileUploadValidation> {
            return localVarFp.uploadTwingraph(organizationId, datasetId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetApi - object-oriented interface
 * @export
 * @class DatasetApi
 * @extends {BaseAPI}
 */
export class DatasetApi extends BaseAPI {
    /**
     * 
     * @summary Add a control access to the Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public addDatasetAccessControl(organizationId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).addDatasetAccessControl(organizationId, datasetId, datasetAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Dataset Compatibility elements.
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Not implemented!
     * @summary Copy a Dataset to another Dataset.
     * @param {string} organizationId the Organization identifier
     * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).copyDataset(organizationId, datasetCopyParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Dataset
     * @param {string} organizationId the Organization identifier
     * @param {Dataset} dataset the Dataset to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createDataset(organizationId: string, dataset: Dataset, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createDataset(organizationId, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a copy of the dataset using the results of the list of queries given in parameter.
     * @summary Create a sub-dataset from the dataset in parameter
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {SubDatasetGraphQuery} subDatasetGraphQuery the Cypher query to filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createSubDataset(organizationId: string, datasetId: string, subDatasetGraphQuery: SubDatasetGraphQuery, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createSubDataset(organizationId, datasetId, subDatasetGraphQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create new entities in a graph instance
     * @summary Create new entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {CreateTwingraphEntitiesTypeEnum} type the entity model type
     * @param {Array<GraphProperties>} graphProperties the entities to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createTwingraphEntities(organizationId: string, datasetId: string, type: CreateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createTwingraphEntities(organizationId, datasetId, type, graphProperties, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteDataset(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete entities in a graph instance
     * @summary Delete entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {DeleteTwingraphEntitiesTypeEnum} type the entity model type
     * @param {Array<string>} ids the entities to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteTwingraphEntities(organizationId: string, datasetId: string, type: DeleteTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteTwingraphEntities(organizationId, datasetId, type, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download the compressed graph reference by the hash in a zip file
     * @summary Download a graph as a zip file
     * @param {string} organizationId the Organization identifier
     * @param {string} hash the Graph download identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public downloadTwingraph(organizationId: string, hash: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).downloadTwingraph(organizationId, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Datasets
     * @param {string} organizationId the Organization identifier
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public findAllDatasets(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).findAllDatasets(organizationId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public findDatasetById(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).findDatasetById(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetAccessControl(organizationId, datasetId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Dataset security information
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetSecurity(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetSecurity(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Dataset security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetSecurityUsers(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetSecurityUsers(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of the import workflow lauch on the dataset\'s refresh. This endpoint needs to be called to update a dataset IngestionStatus or TwincacheStatus
     * @summary Get the dataset\'s refresh job status
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetTwingraphStatus(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetTwingraphStatus(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get entities in a graph instance
     * @summary Get entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {GetTwingraphEntitiesTypeEnum} type the entity model type
     * @param {Array<string>} ids the entities to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getTwingraphEntities(organizationId: string, datasetId: string, type: GetTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getTwingraphEntities(organizationId, datasetId, type, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} workspaceId workspace id to be linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public linkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).linkWorkspace(organizationId, datasetId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh dataset from parent source. At date, sources can be:      dataset (refresh from another dataset)      Azure Digital twin       Azure storage      Local File (import a new file)  During refresh, datas are overwritten 
     * @summary Refresh data on dataset from dataset\'s source
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public refreshDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).refreshDataset(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Dataset Compatibility elements from the Dataset specified
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).removeAllDatasetCompatibilityElements(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public removeDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).removeDatasetAccessControl(organizationId, datasetId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rollback the twingraph on a dataset after a failed refresh
     * @summary Rollback the dataset after a failed refresh
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public rollbackRefresh(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).rollbackRefresh(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Datasets by tags
     * @param {string} organizationId the Organization identifier
     * @param {DatasetSearch} datasetSearch the Dataset search parameters
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public searchDatasets(organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).searchDatasets(organizationId, datasetSearch, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Dataset default security
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public setDatasetDefaultSecurity(organizationId: string, datasetId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).setDatasetDefaultSecurity(organizationId, datasetId, datasetRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a query on a graph instance and return the result as a zip file in async mode
     * @summary Run a query on a graph instance and return the result as a zip file in async mode
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Graph Identifier
     * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public twingraphBatchQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).twingraphBatchQuery(organizationId, datasetId, datasetTwinGraphQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Async batch update by loading a CSV file on a graph instance 
     * @summary Async batch update by loading a CSV file on a graph instance 
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {DatasetTwinGraphQuery} twinGraphQuery 
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public twingraphBatchUpdate(organizationId: string, datasetId: string, twinGraphQuery: DatasetTwinGraphQuery, body: File, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).twingraphBatchUpdate(organizationId, datasetId, twinGraphQuery, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a query on a graph instance and return the result as a json
     * @summary Return the result of a query made on the graph instance as a json
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public twingraphQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).twingraphQuery(organizationId, datasetId, datasetTwinGraphQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} workspaceId workspace id to be linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public unlinkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).unlinkWorkspace(organizationId, datasetId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {Dataset} dataset the new Dataset details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateDataset(organizationId, datasetId, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} identityId the User identifier
     * @param {DatasetRole} datasetRole The new Dataset Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateDatasetAccessControl(organizationId, datasetId, identityId, datasetRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update entities in a graph instance
     * @summary Update entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {UpdateTwingraphEntitiesTypeEnum} type the entity model type
     * @param {Array<GraphProperties>} graphProperties the entities to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateTwingraphEntities(organizationId: string, datasetId: string, type: UpdateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateTwingraphEntities(organizationId, datasetId, type, graphProperties, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. 
     * @summary Upload data from zip file to dataset\'s twingraph
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public uploadTwingraph(organizationId: string, datasetId: string, body: File, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).uploadTwingraph(organizationId, datasetId, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CreateTwingraphEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type CreateTwingraphEntitiesTypeEnum = typeof CreateTwingraphEntitiesTypeEnum[keyof typeof CreateTwingraphEntitiesTypeEnum];
/**
 * @export
 */
export const DeleteTwingraphEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type DeleteTwingraphEntitiesTypeEnum = typeof DeleteTwingraphEntitiesTypeEnum[keyof typeof DeleteTwingraphEntitiesTypeEnum];
/**
 * @export
 */
export const GetTwingraphEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type GetTwingraphEntitiesTypeEnum = typeof GetTwingraphEntitiesTypeEnum[keyof typeof GetTwingraphEntitiesTypeEnum];
/**
 * @export
 */
export const UpdateTwingraphEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type UpdateTwingraphEntitiesTypeEnum = typeof UpdateTwingraphEntitiesTypeEnum[keyof typeof UpdateTwingraphEntitiesTypeEnum];


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationAccessControl: async (organizationId: string, organizationAccessControl: OrganizationAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'organizationAccessControl' is not null or undefined
            assertParamExists('addOrganizationAccessControl', 'organizationAccessControl', organizationAccessControl)
            const localVarPath = `/organizations/{organization_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrganizations: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganizationById: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findOrganizationById', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAccessControl: async (organizationId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getOrganizationAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationPermissions: async (organizationId: string, role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationPermissions', 'organizationId', organizationId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getOrganizationPermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurity: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationSecurity', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurityUsers: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationSecurityUsers', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new organization
         * @param {Organization} organization the Organization to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOrganization: async (organization: Organization, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('registerOrganization', 'organization', organization)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationAccessControl: async (organizationId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeOrganizationAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Organization default security
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationDefaultSecurity: async (organizationId: string, organizationRole: OrganizationRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setOrganizationDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'organizationRole' is not null or undefined
            assertParamExists('setOrganizationDefaultSecurity', 'organizationRole', organizationRole)
            const localVarPath = `/organizations/{organization_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unregister an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterOrganization: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('unregisterOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {Organization} organization the new Organization details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (organizationId: string, organization: Organization, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganization', 'organizationId', organizationId)
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('updateOrganization', 'organization', organization)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationAccessControl: async (organizationId: string, identityId: string, organizationRole: OrganizationRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'identityId', identityId)
            // verify required parameter 'organizationRole' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'organizationRole', organizationRole)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the solutions container registry configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new solutions container registry configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionsContainerRegistryByOrganizationId: async (organizationId: string, organizationService: OrganizationService, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionsContainerRegistryByOrganizationId', 'organizationId', organizationId)
            // verify required parameter 'organizationService' is not null or undefined
            assertParamExists('updateSolutionsContainerRegistryByOrganizationId', 'organizationService', organizationService)
            const localVarPath = `/organizations/{organization_id}/services/solutionsContainerRegistry`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationService, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update storage configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new Storage configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorageByOrganizationId: async (organizationId: string, organizationService: OrganizationService, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateStorageByOrganizationId', 'organizationId', organizationId)
            // verify required parameter 'organizationService' is not null or undefined
            assertParamExists('updateStorageByOrganizationId', 'organizationService', organizationService)
            const localVarPath = `/organizations/{organization_id}/services/storage`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationService, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update tenant credentials for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {{ [key: string]: any; }} requestBody the new Tenant Credentials to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenantCredentialsByOrganizationId: async (organizationId: string, requestBody: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateTenantCredentialsByOrganizationId', 'organizationId', organizationId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateTenantCredentialsByOrganizationId', 'requestBody', requestBody)
            const localVarPath = `/organizations/{organization_id}/services/tenantCredentials`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrganizationAccessControl(organizationId, organizationAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.addOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllOrganizations(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllOrganizations(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.findAllOrganizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOrganizationById(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOrganizationById(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.findOrganizationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ComponentRolePermissions>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getAllPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationAccessControl(organizationId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationPermissions(organizationId: string, role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationPermissions(organizationId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationSecurity(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationSecurity(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationSecurityUsers(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationSecurityUsers(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new organization
         * @param {Organization} organization the Organization to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerOrganization(organization: Organization, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerOrganization(organization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.registerOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOrganizationAccessControl(organizationId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.removeOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Organization default security
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOrganizationDefaultSecurity(organizationId, organizationRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.setOrganizationDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unregister an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unregisterOrganization(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unregisterOrganization(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.unregisterOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {Organization} organization the new Organization details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(organizationId: string, organization: Organization, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(organizationId, organization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationAccessControl(organizationId, identityId, organizationRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the solutions container registry configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new solutions container registry configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionsContainerRegistryByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionsContainerRegistryByOrganizationId(organizationId, organizationService, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateSolutionsContainerRegistryByOrganizationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update storage configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new Storage configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStorageByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStorageByOrganizationId(organizationId, organizationService, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateStorageByOrganizationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update tenant credentials for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {{ [key: string]: any; }} requestBody the new Tenant Credentials to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTenantCredentialsByOrganizationId(organizationId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTenantCredentialsByOrganizationId(organizationId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateTenantCredentialsByOrganizationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: any): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.addOrganizationAccessControl(organizationId, organizationAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrganizations(page?: number, size?: number, options?: any): AxiosPromise<Array<Organization>> {
            return localVarFp.findAllOrganizations(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganizationById(organizationId: string, options?: any): AxiosPromise<Organization> {
            return localVarFp.findOrganizationById(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPermissions(options?: any): AxiosPromise<Array<ComponentRolePermissions>> {
            return localVarFp.getAllPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAccessControl(organizationId: string, identityId: string, options?: any): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.getOrganizationAccessControl(organizationId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationPermissions(organizationId: string, role: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getOrganizationPermissions(organizationId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurity(organizationId: string, options?: any): AxiosPromise<OrganizationSecurity> {
            return localVarFp.getOrganizationSecurity(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurityUsers(organizationId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getOrganizationSecurityUsers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new organization
         * @param {Organization} organization the Organization to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOrganization(organization: Organization, options?: any): AxiosPromise<Organization> {
            return localVarFp.registerOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationAccessControl(organizationId: string, identityId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeOrganizationAccessControl(organizationId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Organization default security
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: any): AxiosPromise<OrganizationSecurity> {
            return localVarFp.setOrganizationDefaultSecurity(organizationId, organizationRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unregister an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterOrganization(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unregisterOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {Organization} organization the new Organization details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organizationId: string, organization: Organization, options?: any): AxiosPromise<Organization> {
            return localVarFp.updateOrganization(organizationId, organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: any): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.updateOrganizationAccessControl(organizationId, identityId, organizationRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the solutions container registry configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new solutions container registry configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionsContainerRegistryByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: any): AxiosPromise<OrganizationService> {
            return localVarFp.updateSolutionsContainerRegistryByOrganizationId(organizationId, organizationService, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update storage configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new Storage configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorageByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: any): AxiosPromise<OrganizationService> {
            return localVarFp.updateStorageByOrganizationId(organizationId, organizationService, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update tenant credentials for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {{ [key: string]: any; }} requestBody the new Tenant Credentials to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenantCredentialsByOrganizationId(organizationId: string, requestBody: { [key: string]: any; }, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.updateTenantCredentialsByOrganizationId(organizationId, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * 
     * @summary Add a control access to the Organization
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public addOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).addOrganizationAccessControl(organizationId, organizationAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Organizations
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public findAllOrganizations(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).findAllOrganizations(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an Organization
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public findOrganizationById(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).findOrganizationById(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all permissions per components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getAllPermissions(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getAllPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Organization
     * @param {string} organizationId the Organization identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationAccessControl(organizationId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization permissions by given role
     * @param {string} organizationId the Organization identifier
     * @param {string} role the Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationPermissions(organizationId: string, role: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationPermissions(organizationId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization security information
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationSecurity(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationSecurity(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization security users list
     * @param {string} organizationId The Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationSecurityUsers(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationSecurityUsers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new organization
     * @param {Organization} organization the Organization to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public registerOrganization(organization: Organization, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).registerOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization
     * @param {string} organizationId the Organization identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public removeOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).removeOrganizationAccessControl(organizationId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Organization default security
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public setOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).setOrganizationDefaultSecurity(organizationId, organizationRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unregister an organization
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public unregisterOrganization(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).unregisterOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an Organization
     * @param {string} organizationId the Organization identifier
     * @param {Organization} organization the new Organization details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganization(organizationId: string, organization: Organization, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganization(organizationId, organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for an Organization
     * @param {string} organizationId the Organization identifier
     * @param {string} identityId the User identifier
     * @param {OrganizationRole} organizationRole The new Organization Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganizationAccessControl(organizationId, identityId, organizationRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the solutions container registry configuration for the Organization specified
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationService} organizationService the new solutions container registry configuration to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateSolutionsContainerRegistryByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateSolutionsContainerRegistryByOrganizationId(organizationId, organizationService, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update storage configuration for the Organization specified
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationService} organizationService the new Storage configuration to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateStorageByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateStorageByOrganizationId(organizationId, organizationService, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update tenant credentials for the Organization specified
     * @param {string} organizationId the Organization identifier
     * @param {{ [key: string]: any; }} requestBody the new Tenant Credentials to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateTenantCredentialsByOrganizationId(organizationId: string, requestBody: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateTenantCredentialsByOrganizationId(organizationId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RunApi - axios parameter creator
 * @export
 */
export const RunApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('deleteRun', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('deleteRun', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRun', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRun', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the logs for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogs: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunLogs', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunLogs', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunLogs', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRunLogs', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/logs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the status for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatus: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunStatus', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunStatus', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunStatus', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRunStatus', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/status`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the list of Runs for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns: async (organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listRuns', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listRuns', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('listRuns', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary query the run data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {RunDataQuery} runDataQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryRunData: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('queryRunData', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('queryRunData', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('queryRunData', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('queryRunData', 'runId', runId)
            // verify required parameter 'runDataQuery' is not null or undefined
            assertParamExists('queryRunData', 'runDataQuery', runDataQuery)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/data/query`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runDataQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send data associated to a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRunData: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('sendRunData', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('sendRunData', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('sendRunData', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('sendRunData', 'runId', runId)
            // verify required parameter 'sendRunDataRequest' is not null or undefined
            assertParamExists('sendRunData', 'sendRunDataRequest', sendRunDataRequest)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/data/send`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendRunDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunApi - functional programming interface
 * @export
 */
export const RunApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRun(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.deleteRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Run>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRun(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.getRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the logs for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunLogs(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunLogs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunLogs(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.getRunLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the status for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunStatus(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunStatus(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.getRunStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the list of Runs for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuns(organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Run>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuns(organizationId, workspaceId, runnerId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.listRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary query the run data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {RunDataQuery} runDataQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryRunData(organizationId, workspaceId, runnerId, runId, runDataQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.queryRunData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send data associated to a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendRunData(organizationId, workspaceId, runnerId, runId, sendRunDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.sendRunData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RunApi - factory interface
 * @export
 */
export const RunApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: any): AxiosPromise<Run> {
            return localVarFp.getRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the logs for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogs(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: any): AxiosPromise<RunLogs> {
            return localVarFp.getRunLogs(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the status for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatus(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: any): AxiosPromise<RunStatus> {
            return localVarFp.getRunStatus(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the list of Runs for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<Run>> {
            return localVarFp.listRuns(organizationId, workspaceId, runnerId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary query the run data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {RunDataQuery} runDataQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options?: any): AxiosPromise<QueryResult> {
            return localVarFp.queryRunData(organizationId, workspaceId, runnerId, runId, runDataQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send data associated to a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options?: any): AxiosPromise<RunData> {
            return localVarFp.sendRunData(organizationId, workspaceId, runnerId, runId, sendRunDataRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunApi - object-oriented interface
 * @export
 * @class RunApi
 * @extends {BaseAPI}
 */
export class RunApi extends BaseAPI {
    /**
     * 
     * @summary Delete a run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public deleteRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).deleteRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public getRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).getRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the logs for the Run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public getRunLogs(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).getRunLogs(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the status for the Run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public getRunStatus(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).getRunStatus(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the list of Runs for the Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public listRuns(organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).listRuns(organizationId, workspaceId, runnerId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary query the run data
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {RunDataQuery} runDataQuery the query to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public queryRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).queryRunData(organizationId, workspaceId, runnerId, runId, runDataQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send data associated to a run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public sendRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).sendRunData(organizationId, workspaceId, runnerId, runId, sendRunDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RunnerApi - axios parameter creator
 * @export
 */
export const RunnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a control access to the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('addRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'runnerAccessControl' is not null or undefined
            assertParamExists('addRunnerAccessControl', 'runnerAccessControl', runnerAccessControl)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Runner} runner the Runner to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunner: async (organizationId: string, workspaceId: string, runner: Runner, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runner' is not null or undefined
            assertParamExists('createRunner', 'runner', runner)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunner: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('deleteRunner', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunner: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunner', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Runner permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerPermissions: async (organizationId: string, workspaceId: string, runnerId: string, role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerPermissions', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunnerPermissions', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerPermissions', 'runnerId', runnerId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getRunnerPermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Runner security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerSecurity: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunnerSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerSecurity', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Runner security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerSecurityUsers: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunnerSecurityUsers', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerSecurityUsers', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Runners
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunners: async (organizationId: string, workspaceId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listRunners', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listRunners', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('removeRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeRunnerAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Runner default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRunnerDefaultSecurity: async (organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setRunnerDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('setRunnerDefaultSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('setRunnerDefaultSecurity', 'runnerId', runnerId)
            // verify required parameter 'runnerRole' is not null or undefined
            assertParamExists('setRunnerDefaultSecurity', 'runnerRole', runnerRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a run with runner parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRun: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('startRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('startRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('startRun', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/start`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop the last run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('stopRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('stopRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('stopRun', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/stop`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {Runner} runner the new Runner details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunner: async (organizationId: string, workspaceId: string, runnerId: string, runner: Runner, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('updateRunner', 'runnerId', runnerId)
            // verify required parameter 'runner' is not null or undefined
            assertParamExists('updateRunner', 'runner', runner)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {RunnerRole} runnerRole The new Runner Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'identityId', identityId)
            // verify required parameter 'runnerRole' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'runnerRole', runnerRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunnerApi - functional programming interface
 * @export
 */
export const RunnerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunnerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRunnerAccessControl(organizationId, workspaceId, runnerId, runnerAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.addRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Runner} runner the Runner to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRunner(organizationId: string, workspaceId: string, runner: Runner, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Runner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRunner(organizationId, workspaceId, runner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.createRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRunner(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.deleteRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of an runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Runner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunner(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Runner permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerPermissions(organizationId: string, workspaceId: string, runnerId: string, role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerPermissions(organizationId, workspaceId, runnerId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunnerPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Runner security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerSecurity(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerSecurity(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunnerSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Runner security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerSecurityUsers(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerSecurityUsers(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunnerSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Runners
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRunners(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Runner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRunners(organizationId, workspaceId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.listRunners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.removeRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Runner default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRunnerDefaultSecurity(organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRunnerDefaultSecurity(organizationId, workspaceId, runnerId, runnerRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.setRunnerDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Start a run with runner parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRun(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.startRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stop the last run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopRun(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.stopRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {Runner} runner the new Runner details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRunner(organizationId: string, workspaceId: string, runnerId: string, runner: Runner, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Runner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRunner(organizationId, workspaceId, runnerId, runner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.updateRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {RunnerRole} runnerRole The new Runner Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, runnerRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.updateRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RunnerApi - factory interface
 * @export
 */
export const RunnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunnerApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options?: any): AxiosPromise<RunnerAccessControl> {
            return localVarFp.addRunnerAccessControl(organizationId, workspaceId, runnerId, runnerAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Runner} runner the Runner to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunner(organizationId: string, workspaceId: string, runner: Runner, options?: any): AxiosPromise<Runner> {
            return localVarFp.createRunner(organizationId, workspaceId, runner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunner(organizationId: string, workspaceId: string, runnerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRunner(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunner(organizationId: string, workspaceId: string, runnerId: string, options?: any): AxiosPromise<Runner> {
            return localVarFp.getRunner(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: any): AxiosPromise<RunnerAccessControl> {
            return localVarFp.getRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Runner permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerPermissions(organizationId: string, workspaceId: string, runnerId: string, role: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getRunnerPermissions(organizationId, workspaceId, runnerId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Runner security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerSecurity(organizationId: string, workspaceId: string, runnerId: string, options?: any): AxiosPromise<RunnerSecurity> {
            return localVarFp.getRunnerSecurity(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Runner security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerSecurityUsers(organizationId: string, workspaceId: string, runnerId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getRunnerSecurityUsers(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Runners
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunners(organizationId: string, workspaceId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<Runner>> {
            return localVarFp.listRunners(organizationId, workspaceId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Runner default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRunnerDefaultSecurity(organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options?: any): AxiosPromise<RunnerSecurity> {
            return localVarFp.setRunnerDefaultSecurity(organizationId, workspaceId, runnerId, runnerRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a run with runner parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRun(organizationId: string, workspaceId: string, runnerId: string, options?: any): AxiosPromise<string> {
            return localVarFp.startRun(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop the last run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(organizationId: string, workspaceId: string, runnerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.stopRun(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {Runner} runner the new Runner details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunner(organizationId: string, workspaceId: string, runnerId: string, runner: Runner, options?: any): AxiosPromise<Runner> {
            return localVarFp.updateRunner(organizationId, workspaceId, runnerId, runner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {RunnerRole} runnerRole The new Runner Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options?: any): AxiosPromise<RunnerAccessControl> {
            return localVarFp.updateRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, runnerRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunnerApi - object-oriented interface
 * @export
 * @class RunnerApi
 * @extends {BaseAPI}
 */
export class RunnerApi extends BaseAPI {
    /**
     * 
     * @summary Add a control access to the Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public addRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).addRunnerAccessControl(organizationId, workspaceId, runnerId, runnerAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {Runner} runner the Runner to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public createRunner(organizationId: string, workspaceId: string, runner: Runner, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).createRunner(organizationId, workspaceId, runner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public deleteRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).deleteRunner(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunner(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Runner permission by given role
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} role the Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerPermissions(organizationId: string, workspaceId: string, runnerId: string, role: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerPermissions(organizationId, workspaceId, runnerId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Runner security information
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerSecurity(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerSecurity(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Runner security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerSecurityUsers(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerSecurityUsers(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Runners
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public listRunners(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).listRunners(organizationId, workspaceId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public removeRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).removeRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Runner default security
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public setRunnerDefaultSecurity(organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).setRunnerDefaultSecurity(organizationId, workspaceId, runnerId, runnerRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a run with runner parameters
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public startRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).startRun(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop the last run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public stopRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).stopRun(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {Runner} runner the new Runner details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public updateRunner(organizationId: string, workspaceId: string, runnerId: string, runner: Runner, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).updateRunner(organizationId, workspaceId, runnerId, runner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} identityId the User identifier
     * @param {RunnerRole} runnerRole The new Runner Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public updateRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).updateRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, runnerRole, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScenarioApi - axios parameter creator
 * @export
 */
export const ScenarioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add (or replace) Parameter Values for the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Array<ScenarioRunTemplateParameterValue>} scenarioRunTemplateParameterValue the Parameter Value to add. Any Parameter Value with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addOrReplaceScenarioParameterValues: async (organizationId: string, workspaceId: string, scenarioId: string, scenarioRunTemplateParameterValue: Array<ScenarioRunTemplateParameterValue>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceScenarioParameterValues', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addOrReplaceScenarioParameterValues', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('addOrReplaceScenarioParameterValues', 'scenarioId', scenarioId)
            // verify required parameter 'scenarioRunTemplateParameterValue' is not null or undefined
            assertParamExists('addOrReplaceScenarioParameterValues', 'scenarioRunTemplateParameterValue', scenarioRunTemplateParameterValue)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/parameterValues`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioRunTemplateParameterValue, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a control access to the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioAccessControl} scenarioAccessControl the new Scenario security access to add.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addScenarioAccessControl: async (organizationId: string, workspaceId: string, scenarioId: string, scenarioAccessControl: ScenarioAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addScenarioAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addScenarioAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('addScenarioAccessControl', 'scenarioId', scenarioId)
            // verify required parameter 'scenarioAccessControl' is not null or undefined
            assertParamExists('addScenarioAccessControl', 'scenarioAccessControl', scenarioAccessControl)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Compare the Scenario with another one and returns the difference for parameters values
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} comparedScenarioId the Scenario identifier to compare to
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        compareScenarios: async (organizationId: string, workspaceId: string, scenarioId: string, comparedScenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('compareScenarios', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('compareScenarios', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('compareScenarios', 'scenarioId', scenarioId)
            // verify required parameter 'comparedScenarioId' is not null or undefined
            assertParamExists('compareScenarios', 'comparedScenarioId', comparedScenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/compare/{compared_scenario_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"compared_scenario_id"}}`, encodeURIComponent(String(comparedScenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Scenario} scenario the Scenario to create
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createScenario: async (organizationId: string, workspaceId: string, scenario: Scenario, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenario' is not null or undefined
            assertParamExists('createScenario', 'scenario', scenario)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenario, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all Scenarios of the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteAllScenarios: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteAllScenarios', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteAllScenarios', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteScenario: async (organizationId: string, workspaceId: string, scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deleteScenario', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Scenario data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        downloadScenarioData: async (organizationId: string, workspaceId: string, scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadScenarioData', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('downloadScenarioData', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('downloadScenarioData', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/downloads`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Scenarios
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findAllScenarios: async (organizationId: string, workspaceId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllScenarios', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findAllScenarios', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Scenarios by validation status
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {ScenarioValidationStatus} validationStatus the Scenario Validation Status
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findAllScenariosByValidationStatus: async (organizationId: string, workspaceId: string, validationStatus: ScenarioValidationStatus, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllScenariosByValidationStatus', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findAllScenariosByValidationStatus', 'workspaceId', workspaceId)
            // verify required parameter 'validationStatus' is not null or undefined
            assertParamExists('findAllScenariosByValidationStatus', 'validationStatus', validationStatus)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/{validationStatus}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"validationStatus"}}`, encodeURIComponent(String(validationStatus)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findScenarioById: async (organizationId: string, workspaceId: string, scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findScenarioById', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findScenarioById', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('findScenarioById', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioAccessControl: async (organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioAccessControl', 'scenarioId', scenarioId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getScenarioAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Scenario data download URL
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} downloadId the Scenario Download identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioDataDownloadJobInfo: async (organizationId: string, workspaceId: string, scenarioId: string, downloadId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioDataDownloadJobInfo', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioDataDownloadJobInfo', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioDataDownloadJobInfo', 'scenarioId', scenarioId)
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getScenarioDataDownloadJobInfo', 'downloadId', downloadId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/downloads/{download_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"download_id"}}`, encodeURIComponent(String(downloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Scenario permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioPermissions: async (organizationId: string, workspaceId: string, scenarioId: string, role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioPermissions', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioPermissions', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioPermissions', 'scenarioId', scenarioId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getScenarioPermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Scenario security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioSecurity: async (organizationId: string, workspaceId: string, scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioSecurity', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Scenario security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioSecurityUsers: async (organizationId: string, workspaceId: string, scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioSecurityUsers', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioSecurityUsers', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the validation status of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioValidationStatusById: async (organizationId: string, workspaceId: string, scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioValidationStatusById', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioValidationStatusById', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioValidationStatusById', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/ValidationStatus`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Scenarios Tree
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenariosTree: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenariosTree', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenariosTree', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/tree`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Parameter Values from the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        removeAllScenarioParameterValues: async (organizationId: string, workspaceId: string, scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllScenarioParameterValues', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeAllScenarioParameterValues', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('removeAllScenarioParameterValues', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/parameterValues`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        removeScenarioAccessControl: async (organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeScenarioAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeScenarioAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('removeScenarioAccessControl', 'scenarioId', scenarioId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeScenarioAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Scenario default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioRole} scenarioRole This change the scenario default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the scenario.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        setScenarioDefaultSecurity: async (organizationId: string, workspaceId: string, scenarioId: string, scenarioRole: ScenarioRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setScenarioDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('setScenarioDefaultSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('setScenarioDefaultSecurity', 'scenarioId', scenarioId)
            // verify required parameter 'scenarioRole' is not null or undefined
            assertParamExists('setScenarioDefaultSecurity', 'scenarioRole', scenarioRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Scenario} scenario the new Scenario details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateScenario: async (organizationId: string, workspaceId: string, scenarioId: string, scenario: Scenario, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('updateScenario', 'scenarioId', scenarioId)
            // verify required parameter 'scenario' is not null or undefined
            assertParamExists('updateScenario', 'scenario', scenario)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenario, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {ScenarioRole} scenarioRole The new Scenario Access Control
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateScenarioAccessControl: async (organizationId: string, workspaceId: string, scenarioId: string, identityId: string, scenarioRole: ScenarioRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateScenarioAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateScenarioAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('updateScenarioAccessControl', 'scenarioId', scenarioId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateScenarioAccessControl', 'identityId', identityId)
            // verify required parameter 'scenarioRole' is not null or undefined
            assertParamExists('updateScenarioAccessControl', 'scenarioRole', scenarioRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScenarioApi - functional programming interface
 * @export
 */
export const ScenarioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScenarioApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add (or replace) Parameter Values for the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Array<ScenarioRunTemplateParameterValue>} scenarioRunTemplateParameterValue the Parameter Value to add. Any Parameter Value with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async addOrReplaceScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, scenarioRunTemplateParameterValue: Array<ScenarioRunTemplateParameterValue>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioRunTemplateParameterValue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceScenarioParameterValues(organizationId, workspaceId, scenarioId, scenarioRunTemplateParameterValue, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.addOrReplaceScenarioParameterValues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a control access to the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioAccessControl} scenarioAccessControl the new Scenario security access to add.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async addScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, scenarioAccessControl: ScenarioAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addScenarioAccessControl(organizationId, workspaceId, scenarioId, scenarioAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.addScenarioAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Compare the Scenario with another one and returns the difference for parameters values
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} comparedScenarioId the Scenario identifier to compare to
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async compareScenarios(organizationId: string, workspaceId: string, scenarioId: string, comparedScenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioComparisonResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compareScenarios(organizationId, workspaceId, scenarioId, comparedScenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.compareScenarios']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Scenario} scenario the Scenario to create
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createScenario(organizationId: string, workspaceId: string, scenario: Scenario, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScenario(organizationId, workspaceId, scenario, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.createScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete all Scenarios of the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteAllScenarios(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllScenarios(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.deleteAllScenarios']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScenario(organizationId, workspaceId, scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.deleteScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download Scenario data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async downloadScenarioData(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioDataDownloadJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadScenarioData(organizationId, workspaceId, scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.downloadScenarioData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Scenarios
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async findAllScenarios(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Scenario>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllScenarios(organizationId, workspaceId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.findAllScenarios']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Scenarios by validation status
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {ScenarioValidationStatus} validationStatus the Scenario Validation Status
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async findAllScenariosByValidationStatus(organizationId: string, workspaceId: string, validationStatus: ScenarioValidationStatus, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Scenario>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllScenariosByValidationStatus(organizationId, workspaceId, validationStatus, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.findAllScenariosByValidationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async findScenarioById(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findScenarioById(organizationId, workspaceId, scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.findScenarioById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.getScenarioAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Scenario data download URL
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} downloadId the Scenario Download identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getScenarioDataDownloadJobInfo(organizationId: string, workspaceId: string, scenarioId: string, downloadId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioDataDownloadInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioDataDownloadJobInfo(organizationId, workspaceId, scenarioId, downloadId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.getScenarioDataDownloadJobInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Scenario permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getScenarioPermissions(organizationId: string, workspaceId: string, scenarioId: string, role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioPermissions(organizationId, workspaceId, scenarioId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.getScenarioPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Scenario security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getScenarioSecurity(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioSecurity(organizationId, workspaceId, scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.getScenarioSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Scenario security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getScenarioSecurityUsers(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioSecurityUsers(organizationId, workspaceId, scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.getScenarioSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the validation status of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getScenarioValidationStatusById(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioValidationStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioValidationStatusById(organizationId, workspaceId, scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.getScenarioValidationStatusById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Scenarios Tree
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getScenariosTree(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Scenario>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenariosTree(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.getScenariosTree']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove all Parameter Values from the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async removeAllScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllScenarioParameterValues(organizationId, workspaceId, scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.removeAllScenarioParameterValues']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async removeScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.removeScenarioAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Scenario default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioRole} scenarioRole This change the scenario default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the scenario.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async setScenarioDefaultSecurity(organizationId: string, workspaceId: string, scenarioId: string, scenarioRole: ScenarioRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setScenarioDefaultSecurity(organizationId, workspaceId, scenarioId, scenarioRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.setScenarioDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Scenario} scenario the new Scenario details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateScenario(organizationId: string, workspaceId: string, scenarioId: string, scenario: Scenario, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScenario(organizationId, workspaceId, scenarioId, scenario, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.updateScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {ScenarioRole} scenarioRole The new Scenario Access Control
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, scenarioRole: ScenarioRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, scenarioRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenarioApi.updateScenarioAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScenarioApi - factory interface
 * @export
 */
export const ScenarioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScenarioApiFp(configuration)
    return {
        /**
         * 
         * @summary Add (or replace) Parameter Values for the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Array<ScenarioRunTemplateParameterValue>} scenarioRunTemplateParameterValue the Parameter Value to add. Any Parameter Value with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addOrReplaceScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, scenarioRunTemplateParameterValue: Array<ScenarioRunTemplateParameterValue>, options?: any): AxiosPromise<Array<ScenarioRunTemplateParameterValue>> {
            return localVarFp.addOrReplaceScenarioParameterValues(organizationId, workspaceId, scenarioId, scenarioRunTemplateParameterValue, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a control access to the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioAccessControl} scenarioAccessControl the new Scenario security access to add.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        addScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, scenarioAccessControl: ScenarioAccessControl, options?: any): AxiosPromise<ScenarioAccessControl> {
            return localVarFp.addScenarioAccessControl(organizationId, workspaceId, scenarioId, scenarioAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Compare the Scenario with another one and returns the difference for parameters values
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} comparedScenarioId the Scenario identifier to compare to
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        compareScenarios(organizationId: string, workspaceId: string, scenarioId: string, comparedScenarioId: string, options?: any): AxiosPromise<ScenarioComparisonResult> {
            return localVarFp.compareScenarios(organizationId, workspaceId, scenarioId, comparedScenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Scenario} scenario the Scenario to create
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createScenario(organizationId: string, workspaceId: string, scenario: Scenario, options?: any): AxiosPromise<Scenario> {
            return localVarFp.createScenario(organizationId, workspaceId, scenario, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all Scenarios of the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteAllScenarios(organizationId: string, workspaceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllScenarios(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteScenario(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Scenario data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        downloadScenarioData(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<ScenarioDataDownloadJob> {
            return localVarFp.downloadScenarioData(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Scenarios
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findAllScenarios(organizationId: string, workspaceId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<Scenario>> {
            return localVarFp.findAllScenarios(organizationId, workspaceId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Scenarios by validation status
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {ScenarioValidationStatus} validationStatus the Scenario Validation Status
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findAllScenariosByValidationStatus(organizationId: string, workspaceId: string, validationStatus: ScenarioValidationStatus, page?: number, size?: number, options?: any): AxiosPromise<Array<Scenario>> {
            return localVarFp.findAllScenariosByValidationStatus(organizationId, workspaceId, validationStatus, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findScenarioById(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<Scenario> {
            return localVarFp.findScenarioById(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options?: any): AxiosPromise<ScenarioAccessControl> {
            return localVarFp.getScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Scenario data download URL
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} downloadId the Scenario Download identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioDataDownloadJobInfo(organizationId: string, workspaceId: string, scenarioId: string, downloadId: string, options?: any): AxiosPromise<ScenarioDataDownloadInfo> {
            return localVarFp.getScenarioDataDownloadJobInfo(organizationId, workspaceId, scenarioId, downloadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Scenario permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioPermissions(organizationId: string, workspaceId: string, scenarioId: string, role: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getScenarioPermissions(organizationId, workspaceId, scenarioId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Scenario security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioSecurity(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<ScenarioSecurity> {
            return localVarFp.getScenarioSecurity(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Scenario security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioSecurityUsers(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getScenarioSecurityUsers(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the validation status of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioValidationStatusById(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<ScenarioValidationStatus> {
            return localVarFp.getScenarioValidationStatusById(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Scenarios Tree
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenariosTree(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Array<Scenario>> {
            return localVarFp.getScenariosTree(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Parameter Values from the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        removeAllScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllScenarioParameterValues(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        removeScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Scenario default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioRole} scenarioRole This change the scenario default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the scenario.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        setScenarioDefaultSecurity(organizationId: string, workspaceId: string, scenarioId: string, scenarioRole: ScenarioRole, options?: any): AxiosPromise<ScenarioSecurity> {
            return localVarFp.setScenarioDefaultSecurity(organizationId, workspaceId, scenarioId, scenarioRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Scenario} scenario the new Scenario details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateScenario(organizationId: string, workspaceId: string, scenarioId: string, scenario: Scenario, options?: any): AxiosPromise<Scenario> {
            return localVarFp.updateScenario(organizationId, workspaceId, scenarioId, scenario, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {ScenarioRole} scenarioRole The new Scenario Access Control
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, scenarioRole: ScenarioRole, options?: any): AxiosPromise<ScenarioAccessControl> {
            return localVarFp.updateScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, scenarioRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScenarioApi - object-oriented interface
 * @export
 * @class ScenarioApi
 * @extends {BaseAPI}
 */
export class ScenarioApi extends BaseAPI {
    /**
     * 
     * @summary Add (or replace) Parameter Values for the Scenario specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {Array<ScenarioRunTemplateParameterValue>} scenarioRunTemplateParameterValue the Parameter Value to add. Any Parameter Value with the same ID is overwritten
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public addOrReplaceScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, scenarioRunTemplateParameterValue: Array<ScenarioRunTemplateParameterValue>, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).addOrReplaceScenarioParameterValues(organizationId, workspaceId, scenarioId, scenarioRunTemplateParameterValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a control access to the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {ScenarioAccessControl} scenarioAccessControl the new Scenario security access to add.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public addScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, scenarioAccessControl: ScenarioAccessControl, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).addScenarioAccessControl(organizationId, workspaceId, scenarioId, scenarioAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Compare the Scenario with another one and returns the difference for parameters values
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {string} comparedScenarioId the Scenario identifier to compare to
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public compareScenarios(organizationId: string, workspaceId: string, scenarioId: string, comparedScenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).compareScenarios(organizationId, workspaceId, scenarioId, comparedScenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {Scenario} scenario the Scenario to create
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public createScenario(organizationId: string, workspaceId: string, scenario: Scenario, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).createScenario(organizationId, workspaceId, scenario, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all Scenarios of the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public deleteAllScenarios(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).deleteAllScenarios(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public deleteScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).deleteScenario(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Scenario data
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public downloadScenarioData(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).downloadScenarioData(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Scenarios
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public findAllScenarios(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).findAllScenarios(organizationId, workspaceId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Scenarios by validation status
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {ScenarioValidationStatus} validationStatus the Scenario Validation Status
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public findAllScenariosByValidationStatus(organizationId: string, workspaceId: string, validationStatus: ScenarioValidationStatus, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).findAllScenariosByValidationStatus(organizationId, workspaceId, validationStatus, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public findScenarioById(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).findScenarioById(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Scenario data download URL
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {string} downloadId the Scenario Download identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenarioDataDownloadJobInfo(organizationId: string, workspaceId: string, scenarioId: string, downloadId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenarioDataDownloadJobInfo(organizationId, workspaceId, scenarioId, downloadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Scenario permission by given role
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {string} role the Role
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenarioPermissions(organizationId: string, workspaceId: string, scenarioId: string, role: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenarioPermissions(organizationId, workspaceId, scenarioId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Scenario security information
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenarioSecurity(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenarioSecurity(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Scenario security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenarioSecurityUsers(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenarioSecurityUsers(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the validation status of an scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenarioValidationStatusById(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenarioValidationStatusById(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Scenarios Tree
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenariosTree(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenariosTree(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Parameter Values from the Scenario specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public removeAllScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).removeAllScenarioParameterValues(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public removeScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).removeScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Scenario default security
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {ScenarioRole} scenarioRole This change the scenario default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the scenario.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public setScenarioDefaultSecurity(organizationId: string, workspaceId: string, scenarioId: string, scenarioRole: ScenarioRole, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).setScenarioDefaultSecurity(organizationId, workspaceId, scenarioId, scenarioRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {Scenario} scenario the new Scenario details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public updateScenario(organizationId: string, workspaceId: string, scenarioId: string, scenario: Scenario, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).updateScenario(organizationId, workspaceId, scenarioId, scenario, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {string} identityId the User identifier
     * @param {ScenarioRole} scenarioRole The new Scenario Access Control
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public updateScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, scenarioRole: ScenarioRole, options?: RawAxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).updateScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, scenarioRole, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScenariorunApi - axios parameter creator
 * @export
 */
export const ScenariorunApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Organization
         * @param {string} organizationId the Organization identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteHistoricalDataOrganization: async (organizationId: string, deleteUnknown?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteHistoricalDataOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/historicaldata`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (deleteUnknown !== undefined) {
                localVarQueryParameter['deleteUnknown'] = deleteUnknown;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteHistoricalDataScenario: async (organizationId: string, workspaceId: string, scenarioId: string, deleteUnknown?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteHistoricalDataScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteHistoricalDataScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deleteHistoricalDataScenario', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/scenarioruns/historicaldata`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (deleteUnknown !== undefined) {
                localVarQueryParameter['deleteUnknown'] = deleteUnknown;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteHistoricalDataWorkspace: async (organizationId: string, workspaceId: string, deleteUnknown?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteHistoricalDataWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteHistoricalDataWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarioruns/historicaldata`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (deleteUnknown !== undefined) {
                localVarQueryParameter['deleteUnknown'] = deleteUnknown;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteScenarioRun: async (organizationId: string, scenariorunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteScenarioRun', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('deleteScenarioRun', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findScenarioRunById: async (organizationId: string, scenariorunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findScenarioRunById', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('findScenarioRunById', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the cumulated logs of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioRunCumulatedLogs: async (organizationId: string, scenariorunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioRunCumulatedLogs', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('getScenarioRunCumulatedLogs', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}/cumulatedlogs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the logs for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioRunLogs: async (organizationId: string, scenariorunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioRunLogs', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('getScenarioRunLogs', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}/logs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the status for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioRunStatus: async (organizationId: string, scenariorunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioRunStatus', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('getScenarioRunStatus', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}/status`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioRuns: async (organizationId: string, workspaceId: string, scenarioId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioRuns', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioRuns', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioRuns', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/scenarioruns`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getWorkspaceScenarioRuns: async (organizationId: string, workspaceId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceScenarioRuns', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceScenarioRuns', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarioruns`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary run a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        runScenario: async (organizationId: string, workspaceId: string, scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('runScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('runScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('runScenario', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/run`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search ScenarioRuns
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunSearch} scenarioRunSearch the ScenarioRun search parameters
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchScenarioRuns: async (organizationId: string, scenarioRunSearch: ScenarioRunSearch, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('searchScenarioRuns', 'organizationId', organizationId)
            // verify required parameter 'scenarioRunSearch' is not null or undefined
            assertParamExists('searchScenarioRuns', 'scenarioRunSearch', scenarioRunSearch)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/search`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioRunSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a new scenariorun with raw containers definition
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunStartContainers} scenarioRunStartContainers the raw containers definition
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        startScenarioRunContainers: async (organizationId: string, scenarioRunStartContainers: ScenarioRunStartContainers, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('startScenarioRunContainers', 'organizationId', organizationId)
            // verify required parameter 'scenarioRunStartContainers' is not null or undefined
            assertParamExists('startScenarioRunContainers', 'scenarioRunStartContainers', scenarioRunStartContainers)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/startcontainers`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioRunStartContainers, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary stop a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the scenariorun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stopScenarioRun: async (organizationId: string, scenariorunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('stopScenarioRun', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('stopScenarioRun', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}/stop`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScenariorunApi - functional programming interface
 * @export
 */
export const ScenariorunApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScenariorunApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Organization
         * @param {string} organizationId the Organization identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteHistoricalDataOrganization(organizationId: string, deleteUnknown?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHistoricalDataOrganization(organizationId, deleteUnknown, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenariorunApi.deleteHistoricalDataOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteHistoricalDataScenario(organizationId: string, workspaceId: string, scenarioId: string, deleteUnknown?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHistoricalDataScenario(organizationId, workspaceId, scenarioId, deleteUnknown, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenariorunApi.deleteHistoricalDataScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteHistoricalDataWorkspace(organizationId: string, workspaceId: string, deleteUnknown?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHistoricalDataWorkspace(organizationId, workspaceId, deleteUnknown, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenariorunApi.deleteHistoricalDataWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteScenarioRun(organizationId: string, scenariorunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScenarioRun(organizationId, scenariorunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenariorunApi.deleteScenarioRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async findScenarioRunById(organizationId: string, scenariorunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findScenarioRunById(organizationId, scenariorunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenariorunApi.findScenarioRunById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the cumulated logs of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getScenarioRunCumulatedLogs(organizationId: string, scenariorunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioRunCumulatedLogs(organizationId, scenariorunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenariorunApi.getScenarioRunCumulatedLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the logs for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getScenarioRunLogs(organizationId: string, scenariorunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRunLogs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioRunLogs(organizationId, scenariorunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenariorunApi.getScenarioRunLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the status for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getScenarioRunStatus(organizationId: string, scenariorunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRunStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioRunStatus(organizationId, scenariorunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenariorunApi.getScenarioRunStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getScenarioRuns(organizationId: string, workspaceId: string, scenarioId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioRuns(organizationId, workspaceId, scenarioId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenariorunApi.getScenarioRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getWorkspaceScenarioRuns(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceScenarioRuns(organizationId, workspaceId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenariorunApi.getWorkspaceScenarioRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary run a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async runScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runScenario(organizationId, workspaceId, scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenariorunApi.runScenario']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search ScenarioRuns
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunSearch} scenarioRunSearch the ScenarioRun search parameters
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async searchScenarioRuns(organizationId: string, scenarioRunSearch: ScenarioRunSearch, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchScenarioRuns(organizationId, scenarioRunSearch, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenariorunApi.searchScenarioRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Start a new scenariorun with raw containers definition
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunStartContainers} scenarioRunStartContainers the raw containers definition
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async startScenarioRunContainers(organizationId: string, scenarioRunStartContainers: ScenarioRunStartContainers, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startScenarioRunContainers(organizationId, scenarioRunStartContainers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenariorunApi.startScenarioRunContainers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary stop a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the scenariorun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async stopScenarioRun(organizationId: string, scenariorunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRunStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopScenarioRun(organizationId, scenariorunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScenariorunApi.stopScenarioRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScenariorunApi - factory interface
 * @export
 */
export const ScenariorunApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScenariorunApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Organization
         * @param {string} organizationId the Organization identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteHistoricalDataOrganization(organizationId: string, deleteUnknown?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHistoricalDataOrganization(organizationId, deleteUnknown, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteHistoricalDataScenario(organizationId: string, workspaceId: string, scenarioId: string, deleteUnknown?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHistoricalDataScenario(organizationId, workspaceId, scenarioId, deleteUnknown, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteHistoricalDataWorkspace(organizationId: string, workspaceId: string, deleteUnknown?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHistoricalDataWorkspace(organizationId, workspaceId, deleteUnknown, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteScenarioRun(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteScenarioRun(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findScenarioRunById(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<ScenarioRun> {
            return localVarFp.findScenarioRunById(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the cumulated logs of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioRunCumulatedLogs(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getScenarioRunCumulatedLogs(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the logs for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioRunLogs(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<ScenarioRunLogs> {
            return localVarFp.getScenarioRunLogs(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the status for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioRunStatus(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<ScenarioRunStatus> {
            return localVarFp.getScenarioRunStatus(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getScenarioRuns(organizationId: string, workspaceId: string, scenarioId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<ScenarioRun>> {
            return localVarFp.getScenarioRuns(organizationId, workspaceId, scenarioId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getWorkspaceScenarioRuns(organizationId: string, workspaceId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<ScenarioRun>> {
            return localVarFp.getWorkspaceScenarioRuns(organizationId, workspaceId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary run a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        runScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<ScenarioRun> {
            return localVarFp.runScenario(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search ScenarioRuns
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunSearch} scenarioRunSearch the ScenarioRun search parameters
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        searchScenarioRuns(organizationId: string, scenarioRunSearch: ScenarioRunSearch, page?: number, size?: number, options?: any): AxiosPromise<Array<ScenarioRun>> {
            return localVarFp.searchScenarioRuns(organizationId, scenarioRunSearch, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a new scenariorun with raw containers definition
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunStartContainers} scenarioRunStartContainers the raw containers definition
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        startScenarioRunContainers(organizationId: string, scenarioRunStartContainers: ScenarioRunStartContainers, options?: any): AxiosPromise<ScenarioRun> {
            return localVarFp.startScenarioRunContainers(organizationId, scenarioRunStartContainers, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary stop a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the scenariorun identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        stopScenarioRun(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<ScenarioRunStatus> {
            return localVarFp.stopScenarioRun(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScenariorunApi - object-oriented interface
 * @export
 * @class ScenariorunApi
 * @extends {BaseAPI}
 */
export class ScenariorunApi extends BaseAPI {
    /**
     * 
     * @summary Delete all historical ScenarioRuns in the Organization
     * @param {string} organizationId the Organization identifier
     * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public deleteHistoricalDataOrganization(organizationId: string, deleteUnknown?: boolean, options?: RawAxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).deleteHistoricalDataOrganization(organizationId, deleteUnknown, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all historical ScenarioRuns in the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public deleteHistoricalDataScenario(organizationId: string, workspaceId: string, scenarioId: string, deleteUnknown?: boolean, options?: RawAxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).deleteHistoricalDataScenario(organizationId, workspaceId, scenarioId, deleteUnknown, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all historical ScenarioRuns in the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public deleteHistoricalDataWorkspace(organizationId: string, workspaceId: string, deleteUnknown?: boolean, options?: RawAxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).deleteHistoricalDataWorkspace(organizationId, workspaceId, deleteUnknown, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scenariorun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public deleteScenarioRun(organizationId: string, scenariorunId: string, options?: RawAxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).deleteScenarioRun(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a scenariorun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public findScenarioRunById(organizationId: string, scenariorunId: string, options?: RawAxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).findScenarioRunById(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the cumulated logs of a scenariorun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getScenarioRunCumulatedLogs(organizationId: string, scenariorunId: string, options?: RawAxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getScenarioRunCumulatedLogs(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the logs for the ScenarioRun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getScenarioRunLogs(organizationId: string, scenariorunId: string, options?: RawAxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getScenarioRunLogs(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the status for the ScenarioRun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getScenarioRunStatus(organizationId: string, scenariorunId: string, options?: RawAxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getScenarioRunStatus(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the list of ScenarioRuns for the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getScenarioRuns(organizationId: string, workspaceId: string, scenarioId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getScenarioRuns(organizationId, workspaceId, scenarioId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the list of ScenarioRuns for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getWorkspaceScenarioRuns(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getWorkspaceScenarioRuns(organizationId, workspaceId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary run a ScenarioRun for the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public runScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: RawAxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).runScenario(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search ScenarioRuns
     * @param {string} organizationId the Organization identifier
     * @param {ScenarioRunSearch} scenarioRunSearch the ScenarioRun search parameters
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public searchScenarioRuns(organizationId: string, scenarioRunSearch: ScenarioRunSearch, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).searchScenarioRuns(organizationId, scenarioRunSearch, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a new scenariorun with raw containers definition
     * @param {string} organizationId the Organization identifier
     * @param {ScenarioRunStartContainers} scenarioRunStartContainers the raw containers definition
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public startScenarioRunContainers(organizationId: string, scenarioRunStartContainers: ScenarioRunStartContainers, options?: RawAxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).startScenarioRunContainers(organizationId, scenarioRunStartContainers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary stop a ScenarioRun for the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the scenariorun identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public stopScenarioRun(organizationId: string, scenariorunId: string, options?: RawAxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).stopScenarioRun(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SolutionApi - axios parameter creator
 * @export
 */
export const SolutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Parameter Groups. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameterGroups: async (organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceParameterGroups', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('addOrReplaceParameterGroups', 'solutionId', solutionId)
            // verify required parameter 'runTemplateParameterGroup' is not null or undefined
            assertParamExists('addOrReplaceParameterGroups', 'runTemplateParameterGroup', runTemplateParameterGroup)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateParameterGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Parameters. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameters: async (organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceParameters', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('addOrReplaceParameters', 'solutionId', solutionId)
            // verify required parameter 'runTemplateParameter' is not null or undefined
            assertParamExists('addOrReplaceParameters', 'runTemplateParameter', runTemplateParameter)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Run Templates. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceRunTemplates: async (organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceRunTemplates', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('addOrReplaceRunTemplates', 'solutionId', solutionId)
            // verify required parameter 'runTemplate' is not null or undefined
            assertParamExists('addOrReplaceRunTemplates', 'runTemplate', runTemplate)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a control access to the Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionAccessControl} solutionAccessControl the new Solution security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSolutionAccessControl: async (organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('addSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'solutionAccessControl' is not null or undefined
            assertParamExists('addSolutionAccessControl', 'solutionAccessControl', solutionAccessControl)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolution: async (organizationId: string, solution: Solution, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSolution', 'organizationId', organizationId)
            // verify required parameter 'solution' is not null or undefined
            assertParamExists('createSolution', 'solution', solution)
            const localVarPath = `/organizations/{organization_id}/solutions`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolution: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolution', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionRunTemplate: async (organizationId: string, solutionId: string, runTemplateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'runTemplateId', runTemplateId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates/{run_template_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRunTemplateHandler: async (organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadRunTemplateHandler', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('downloadRunTemplateHandler', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('downloadRunTemplateHandler', 'runTemplateId', runTemplateId)
            // verify required parameter 'handlerId' is not null or undefined
            assertParamExists('downloadRunTemplateHandler', 'handlerId', handlerId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runtemplates/{run_template_id}/handlers/{handler_id}/download`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)))
                .replace(`{${"handler_id"}}`, encodeURIComponent(String(handlerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllSolutions: async (organizationId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllSolutions', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/solutions`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSolutionById: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findSolutionById', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('findSolutionById', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionAccessControl: async (organizationId: string, solutionId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getSolutionAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Solution security information
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionSecurity: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getSolutionSecurity', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getSolutionSecurity', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Solution security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionSecurityUsers: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getSolutionSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getSolutionSecurityUsers', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Run Templates from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllRunTemplates: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllRunTemplates', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('removeAllRunTemplates', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Parameter Groups from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameterGroups: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllSolutionParameterGroups', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('removeAllSolutionParameterGroups', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Parameters from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameters: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllSolutionParameters', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('removeAllSolutionParameters', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSolutionAccessControl: async (organizationId: string, solutionId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('removeSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeSolutionAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Solution default security
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionRole} solutionRole This change the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSolutionDefaultSecurity: async (organizationId: string, solutionId: string, solutionRole: SolutionRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setSolutionDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('setSolutionDefaultSecurity', 'solutionId', solutionId)
            // verify required parameter 'solutionRole' is not null or undefined
            assertParamExists('setSolutionDefaultSecurity', 'solutionRole', solutionRole)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Solution} solution the new Solution details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolution: async (organizationId: string, solutionId: string, solution: Solution, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolution', 'solutionId', solutionId)
            // verify required parameter 'solution' is not null or undefined
            assertParamExists('updateSolution', 'solution', solution)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {SolutionRole} solutionRole The new Solution Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionAccessControl: async (organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'identityId', identityId)
            // verify required parameter 'solutionRole' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'solutionRole', solutionRole)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionRunTemplate: async (organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'runTemplateId', runTemplateId)
            // verify required parameter 'runTemplate' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'runTemplate', runTemplate)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates/{run_template_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {File} body 
         * @param {boolean} [overwrite] whether to overwrite any existing handler resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunTemplateHandler: async (organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, body: File, overwrite?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'runTemplateId', runTemplateId)
            // verify required parameter 'handlerId' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'handlerId', handlerId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'body', body)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runtemplates/{run_template_id}/handlers/{handler_id}/upload`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)))
                .replace(`{${"handler_id"}}`, encodeURIComponent(String(handlerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SolutionApi - functional programming interface
 * @export
 */
export const SolutionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SolutionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Parameter Groups. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplateParameterGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.addOrReplaceParameterGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add Parameters. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplateParameter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceParameters(organizationId, solutionId, runTemplateParameter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.addOrReplaceParameters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add Run Templates. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceRunTemplates(organizationId, solutionId, runTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.addOrReplaceRunTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a control access to the Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionAccessControl} solutionAccessControl the new Solution security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSolutionAccessControl(organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSolutionAccessControl(organizationId, solutionId, solutionAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.addSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSolution(organizationId: string, solution: Solution, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSolution(organizationId, solution, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.createSolution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolution(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolutionRunTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.downloadRunTemplateHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllSolutions(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Solution>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllSolutions(organizationId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.findAllSolutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSolutionById(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSolutionById(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.findSolutionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolutionAccessControl(organizationId, solutionId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Solution security information
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolutionSecurity(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolutionSecurity(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getSolutionSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Solution security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolutionSecurityUsers(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolutionSecurityUsers(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getSolutionSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove all Run Templates from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllRunTemplates(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllRunTemplates(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.removeAllRunTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove all Parameter Groups from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllSolutionParameterGroups(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllSolutionParameterGroups(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.removeAllSolutionParameterGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove all Parameters from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllSolutionParameters(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllSolutionParameters(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.removeAllSolutionParameters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSolutionAccessControl(organizationId, solutionId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.removeSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Solution default security
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionRole} solutionRole This change the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSolutionDefaultSecurity(organizationId: string, solutionId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSolutionDefaultSecurity(organizationId, solutionId, solutionRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.setSolutionDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Solution} solution the new Solution details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolution(organizationId: string, solutionId: string, solution: Solution, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolution(organizationId, solutionId, solution, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {SolutionRole} solutionRole The new Solution Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionAccessControl(organizationId, solutionId, identityId, solutionRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionRunTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {File} body 
         * @param {boolean} [overwrite] whether to overwrite any existing handler resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, body: File, overwrite?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, body, overwrite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.uploadRunTemplateHandler']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SolutionApi - factory interface
 * @export
 */
export const SolutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SolutionApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Parameter Groups. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: any): AxiosPromise<Array<RunTemplateParameterGroup>> {
            return localVarFp.addOrReplaceParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Parameters. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: any): AxiosPromise<Array<RunTemplateParameter>> {
            return localVarFp.addOrReplaceParameters(organizationId, solutionId, runTemplateParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Run Templates. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: any): AxiosPromise<Array<RunTemplate>> {
            return localVarFp.addOrReplaceRunTemplates(organizationId, solutionId, runTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a control access to the Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionAccessControl} solutionAccessControl the new Solution security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSolutionAccessControl(organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options?: any): AxiosPromise<SolutionAccessControl> {
            return localVarFp.addSolutionAccessControl(organizationId, solutionId, solutionAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolution(organizationId: string, solution: Solution, options?: any): AxiosPromise<Solution> {
            return localVarFp.createSolution(organizationId, solution, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolution(organizationId: string, solutionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSolution(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, options?: any): AxiosPromise<string> {
            return localVarFp.downloadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllSolutions(organizationId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<Solution>> {
            return localVarFp.findAllSolutions(organizationId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSolutionById(organizationId: string, solutionId: string, options?: any): AxiosPromise<Solution> {
            return localVarFp.findSolutionById(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: any): AxiosPromise<SolutionAccessControl> {
            return localVarFp.getSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Solution security information
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionSecurity(organizationId: string, solutionId: string, options?: any): AxiosPromise<SolutionSecurity> {
            return localVarFp.getSolutionSecurity(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Solution security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionSecurityUsers(organizationId: string, solutionId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getSolutionSecurityUsers(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Run Templates from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllRunTemplates(organizationId: string, solutionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllRunTemplates(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Parameter Groups from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameterGroups(organizationId: string, solutionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllSolutionParameterGroups(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Parameters from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameters(organizationId: string, solutionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllSolutionParameters(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Solution default security
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionRole} solutionRole This change the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSolutionDefaultSecurity(organizationId: string, solutionId: string, solutionRole: SolutionRole, options?: any): AxiosPromise<SolutionSecurity> {
            return localVarFp.setSolutionDefaultSecurity(organizationId, solutionId, solutionRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Solution} solution the new Solution details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolution(organizationId: string, solutionId: string, solution: Solution, options?: any): AxiosPromise<Solution> {
            return localVarFp.updateSolution(organizationId, solutionId, solution, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {SolutionRole} solutionRole The new Solution Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options?: any): AxiosPromise<SolutionAccessControl> {
            return localVarFp.updateSolutionAccessControl(organizationId, solutionId, identityId, solutionRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: any): AxiosPromise<Array<RunTemplate>> {
            return localVarFp.updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {File} body 
         * @param {boolean} [overwrite] whether to overwrite any existing handler resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, body: File, overwrite?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.uploadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, body, overwrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SolutionApi - object-oriented interface
 * @export
 * @class SolutionApi
 * @extends {BaseAPI}
 */
export class SolutionApi extends BaseAPI {
    /**
     * 
     * @summary Add Parameter Groups. Any item with the same ID will be overwritten
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public addOrReplaceParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).addOrReplaceParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Parameters. Any item with the same ID will be overwritten
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public addOrReplaceParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).addOrReplaceParameters(organizationId, solutionId, runTemplateParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Run Templates. Any item with the same ID will be overwritten
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplate>} runTemplate the Run Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public addOrReplaceRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).addOrReplaceRunTemplates(organizationId, solutionId, runTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a control access to the Solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {SolutionAccessControl} solutionAccessControl the new Solution security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public addSolutionAccessControl(organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).addSolutionAccessControl(organizationId, solutionId, solutionAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new solution
     * @param {string} organizationId the Organization identifier
     * @param {Solution} solution the Solution to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public createSolution(organizationId: string, solution: Solution, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).createSolution(organizationId, solution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolution(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified Solution Run Template
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a Run Template step handler zip file
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {RunTemplateHandlerId} handlerId the Handler identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public downloadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).downloadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Solutions
     * @param {string} organizationId the Organization identifier
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public findAllSolutions(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).findAllSolutions(organizationId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public findSolutionById(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).findSolutionById(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Solution security information
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getSolutionSecurity(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getSolutionSecurity(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Solution security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getSolutionSecurityUsers(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getSolutionSecurityUsers(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Run Templates from the Solution specified
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public removeAllRunTemplates(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).removeAllRunTemplates(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Parameter Groups from the Solution specified
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public removeAllSolutionParameterGroups(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).removeAllSolutionParameterGroups(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Parameters from the Solution specified
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public removeAllSolutionParameters(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).removeAllSolutionParameters(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization Solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public removeSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).removeSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Solution default security
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {SolutionRole} solutionRole This change the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public setSolutionDefaultSecurity(organizationId: string, solutionId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).setSolutionDefaultSecurity(organizationId, solutionId, solutionRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Solution} solution the new Solution details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolution(organizationId: string, solutionId: string, solution: Solution, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolution(organizationId, solutionId, solution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} identityId the User identifier
     * @param {SolutionRole} solutionRole The new Solution Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionAccessControl(organizationId, solutionId, identityId, solutionRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified Solution Run Template
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {RunTemplate} runTemplate the Run Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a Run Template step handler zip file
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {RunTemplateHandlerId} handlerId the Handler identifier
     * @param {File} body 
     * @param {boolean} [overwrite] whether to overwrite any existing handler resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public uploadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, body: File, overwrite?: boolean, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).uploadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, body, overwrite, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TwingraphApi - axios parameter creator
 * @export
 */
export const TwingraphApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete all versions of a graph and his metadatas
         * @summary Delete all versions of a graph and his metadatas
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        _delete: async (organizationId: string, graphId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('_delete', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('_delete', 'graphId', graphId)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        batchQuery: async (organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('batchQuery', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('batchQuery', 'graphId', graphId)
            // verify required parameter 'twinGraphQuery' is not null or undefined
            assertParamExists('batchQuery', 'twinGraphQuery', twinGraphQuery)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/batch-query`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twinGraphQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Async batch update by loading a CSV file on a graph instance 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        batchUploadUpdate: async (organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('batchUploadUpdate', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('batchUploadUpdate', 'graphId', graphId)
            // verify required parameter 'twinGraphQuery' is not null or undefined
            assertParamExists('batchUploadUpdate', 'twinGraphQuery', twinGraphQuery)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('batchUploadUpdate', 'body', body)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/batch`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (twinGraphQuery !== undefined) {
                for (const [key, value] of Object.entries(twinGraphQuery)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/csv';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create new entities in a graph instance
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {CreateEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createEntities: async (organizationId: string, graphId: string, type: CreateEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createEntities', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('createEntities', 'graphId', graphId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createEntities', 'type', type)
            // verify required parameter 'graphProperties' is not null or undefined
            assertParamExists('createEntities', 'graphProperties', graphProperties)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/entity/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(graphProperties, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. 
         * @summary Create a new graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createGraph: async (organizationId: string, graphId: string, body?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createGraph', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('createGraph', 'graphId', graphId)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete entities in a graph instance
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {DeleteEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteEntities: async (organizationId: string, graphId: string, type: DeleteEntitiesTypeEnum, ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteEntities', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('deleteEntities', 'graphId', graphId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteEntities', 'type', type)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteEntities', 'ids', ids)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/entity/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a graph compressed in a zip file
         * @summary Download a graph compressed in a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        downloadGraph: async (organizationId: string, hash: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadGraph', 'organizationId', organizationId)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('downloadGraph', 'hash', hash)
            const localVarPath = `/organizations/{organization_id}/twingraph/download/{hash}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the list of all graphs stored in the organization
         * @summary Return the list of all graphs stored in the organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findAllTwingraphs: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllTwingraphs', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/twingraphs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get entities in a graph instance
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {GetEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getEntities: async (organizationId: string, graphId: string, type: GetEntitiesTypeEnum, ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getEntities', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getEntities', 'graphId', graphId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getEntities', 'type', type)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getEntities', 'ids', ids)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/entity/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the metaData of the specified graph
         * @summary Return the metaData of the specified graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGraphMetaData: async (organizationId: string, graphId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getGraphMetaData', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getGraphMetaData', 'graphId', graphId)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/metadata`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of a job
         * @summary Get the status of a job
         * @param {string} organizationId the Organization identifier
         * @param {string} jobId the job identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        jobStatus: async (organizationId: string, jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('jobStatus', 'organizationId', organizationId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('jobStatus', 'jobId', jobId)
            const localVarPath = `/organizations/{organization_id}/job/{job_id}/status`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a query on a graph instance
         * @summary Run a query on a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        query: async (organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('query', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('query', 'graphId', graphId)
            // verify required parameter 'twinGraphQuery' is not null or undefined
            assertParamExists('query', 'twinGraphQuery', twinGraphQuery)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/query`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twinGraphQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {UpdateEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to update
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEntities: async (organizationId: string, graphId: string, type: UpdateEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateEntities', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('updateEntities', 'graphId', graphId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('updateEntities', 'type', type)
            // verify required parameter 'graphProperties' is not null or undefined
            assertParamExists('updateEntities', 'graphProperties', graphProperties)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/entity/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(graphProperties, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the metaData of the specified graph
         * @summary Update the metaData of the specified graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {{ [key: string]: string; }} requestBody the metaData to update
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGraphMetaData: async (organizationId: string, graphId: string, requestBody: { [key: string]: string; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateGraphMetaData', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('updateGraphMetaData', 'graphId', graphId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateGraphMetaData', 'requestBody', requestBody)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/metadata`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TwingraphApi - functional programming interface
 * @export
 */
export const TwingraphApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TwingraphApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete all versions of a graph and his metadatas
         * @summary Delete all versions of a graph and his metadatas
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async _delete(organizationId: string, graphId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(organizationId, graphId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwingraphApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async batchQuery(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwinGraphHash>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchQuery(organizationId, graphId, twinGraphQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwingraphApi.batchQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Async batch update by loading a CSV file on a graph instance 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async batchUploadUpdate(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwinGraphBatchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchUploadUpdate(organizationId, graphId, twinGraphQuery, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwingraphApi.batchUploadUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create new entities in a graph instance
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {CreateEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createEntities(organizationId: string, graphId: string, type: CreateEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntities(organizationId, graphId, type, graphProperties, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwingraphApi.createEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. 
         * @summary Create a new graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createGraph(organizationId: string, graphId: string, body?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGraph(organizationId, graphId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwingraphApi.createGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete entities in a graph instance
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {DeleteEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deleteEntities(organizationId: string, graphId: string, type: DeleteEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntities(organizationId, graphId, type, ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwingraphApi.deleteEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download a graph compressed in a zip file
         * @summary Download a graph compressed in a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async downloadGraph(organizationId: string, hash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadGraph(organizationId, hash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwingraphApi.downloadGraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the list of all graphs stored in the organization
         * @summary Return the list of all graphs stored in the organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async findAllTwingraphs(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllTwingraphs(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwingraphApi.findAllTwingraphs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get entities in a graph instance
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {GetEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getEntities(organizationId: string, graphId: string, type: GetEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntities(organizationId, graphId, type, ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwingraphApi.getEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return the metaData of the specified graph
         * @summary Return the metaData of the specified graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getGraphMetaData(organizationId: string, graphId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGraphMetaData(organizationId, graphId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwingraphApi.getGraphMetaData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the status of a job
         * @summary Get the status of a job
         * @param {string} organizationId the Organization identifier
         * @param {string} jobId the job identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async jobStatus(organizationId: string, jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobStatus(organizationId, jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwingraphApi.jobStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Run a query on a graph instance
         * @summary Run a query on a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async query(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.query(organizationId, graphId, twinGraphQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwingraphApi.query']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {UpdateEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to update
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateEntities(organizationId: string, graphId: string, type: UpdateEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntities(organizationId, graphId, type, graphProperties, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwingraphApi.updateEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the metaData of the specified graph
         * @summary Update the metaData of the specified graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {{ [key: string]: string; }} requestBody the metaData to update
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async updateGraphMetaData(organizationId: string, graphId: string, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGraphMetaData(organizationId, graphId, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TwingraphApi.updateGraphMetaData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TwingraphApi - factory interface
 * @export
 */
export const TwingraphApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TwingraphApiFp(configuration)
    return {
        /**
         * Delete all versions of a graph and his metadatas
         * @summary Delete all versions of a graph and his metadatas
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        _delete(organizationId: string, graphId: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(organizationId, graphId, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        batchQuery(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options?: any): AxiosPromise<TwinGraphHash> {
            return localVarFp.batchQuery(organizationId, graphId, twinGraphQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Async batch update by loading a CSV file on a graph instance 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        batchUploadUpdate(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, body: File, options?: any): AxiosPromise<TwinGraphBatchResult> {
            return localVarFp.batchUploadUpdate(organizationId, graphId, twinGraphQuery, body, options).then((request) => request(axios, basePath));
        },
        /**
         * create new entities in a graph instance
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {CreateEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createEntities(organizationId: string, graphId: string, type: CreateEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: any): AxiosPromise<string> {
            return localVarFp.createEntities(organizationId, graphId, type, graphProperties, options).then((request) => request(axios, basePath));
        },
        /**
         * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. 
         * @summary Create a new graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {File} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createGraph(organizationId: string, graphId: string, body?: File, options?: any): AxiosPromise<void> {
            return localVarFp.createGraph(organizationId, graphId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * delete entities in a graph instance
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {DeleteEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deleteEntities(organizationId: string, graphId: string, type: DeleteEntitiesTypeEnum, ids: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEntities(organizationId, graphId, type, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Download a graph compressed in a zip file
         * @summary Download a graph compressed in a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        downloadGraph(organizationId: string, hash: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadGraph(organizationId, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the list of all graphs stored in the organization
         * @summary Return the list of all graphs stored in the organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findAllTwingraphs(organizationId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.findAllTwingraphs(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * get entities in a graph instance
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {GetEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getEntities(organizationId: string, graphId: string, type: GetEntitiesTypeEnum, ids: Array<string>, options?: any): AxiosPromise<string> {
            return localVarFp.getEntities(organizationId, graphId, type, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the metaData of the specified graph
         * @summary Return the metaData of the specified graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getGraphMetaData(organizationId: string, graphId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getGraphMetaData(organizationId, graphId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a job
         * @summary Get the status of a job
         * @param {string} organizationId the Organization identifier
         * @param {string} jobId the job identifier
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        jobStatus(organizationId: string, jobId: string, options?: any): AxiosPromise<string> {
            return localVarFp.jobStatus(organizationId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a query on a graph instance
         * @summary Run a query on a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        query(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options?: any): AxiosPromise<string> {
            return localVarFp.query(organizationId, graphId, twinGraphQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {UpdateEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to update
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateEntities(organizationId: string, graphId: string, type: UpdateEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: any): AxiosPromise<string> {
            return localVarFp.updateEntities(organizationId, graphId, type, graphProperties, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the metaData of the specified graph
         * @summary Update the metaData of the specified graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {{ [key: string]: string; }} requestBody the metaData to update
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        updateGraphMetaData(organizationId: string, graphId: string, requestBody: { [key: string]: string; }, options?: any): AxiosPromise<object> {
            return localVarFp.updateGraphMetaData(organizationId, graphId, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TwingraphApi - object-oriented interface
 * @export
 * @class TwingraphApi
 * @extends {BaseAPI}
 */
export class TwingraphApi extends BaseAPI {
    /**
     * Delete all versions of a graph and his metadatas
     * @summary Delete all versions of a graph and his metadatas
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public _delete(organizationId: string, graphId: string, options?: RawAxiosRequestConfig) {
        return TwingraphApiFp(this.configuration)._delete(organizationId, graphId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a query on a graph instance and return the result as a zip file in async mode
     * @summary Run a query on a graph instance and return the result as a zip file in async mode
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {TwinGraphQuery} twinGraphQuery the query to run
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public batchQuery(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options?: RawAxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).batchQuery(organizationId, graphId, twinGraphQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Async batch update by loading a CSV file on a graph instance 
     * @summary Async batch update by loading a CSV file on a graph instance 
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {TwinGraphQuery} twinGraphQuery 
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public batchUploadUpdate(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, body: File, options?: RawAxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).batchUploadUpdate(organizationId, graphId, twinGraphQuery, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create new entities in a graph instance
     * @summary Create new entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {CreateEntitiesTypeEnum} type the entity model type
     * @param {Array<GraphProperties>} graphProperties the entities to create
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public createEntities(organizationId: string, graphId: string, type: CreateEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).createEntities(organizationId, graphId, type, graphProperties, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. 
     * @summary Create a new graph
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {File} [body] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public createGraph(organizationId: string, graphId: string, body?: File, options?: RawAxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).createGraph(organizationId, graphId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete entities in a graph instance
     * @summary Delete entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {DeleteEntitiesTypeEnum} type the entity model type
     * @param {Array<string>} ids the entities to delete
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public deleteEntities(organizationId: string, graphId: string, type: DeleteEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).deleteEntities(organizationId, graphId, type, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download a graph compressed in a zip file
     * @summary Download a graph compressed in a zip file
     * @param {string} organizationId the Organization identifier
     * @param {string} hash the Graph download identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public downloadGraph(organizationId: string, hash: string, options?: RawAxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).downloadGraph(organizationId, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the list of all graphs stored in the organization
     * @summary Return the list of all graphs stored in the organization
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public findAllTwingraphs(organizationId: string, options?: RawAxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).findAllTwingraphs(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get entities in a graph instance
     * @summary Get entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {GetEntitiesTypeEnum} type the entity model type
     * @param {Array<string>} ids the entities to get
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public getEntities(organizationId: string, graphId: string, type: GetEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).getEntities(organizationId, graphId, type, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the metaData of the specified graph
     * @summary Return the metaData of the specified graph
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public getGraphMetaData(organizationId: string, graphId: string, options?: RawAxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).getGraphMetaData(organizationId, graphId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of a job
     * @summary Get the status of a job
     * @param {string} organizationId the Organization identifier
     * @param {string} jobId the job identifier
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public jobStatus(organizationId: string, jobId: string, options?: RawAxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).jobStatus(organizationId, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a query on a graph instance
     * @summary Run a query on a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {TwinGraphQuery} twinGraphQuery the query to run
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public query(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options?: RawAxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).query(organizationId, graphId, twinGraphQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update entities in a graph instance
     * @summary Update entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {UpdateEntitiesTypeEnum} type the entity model type
     * @param {Array<GraphProperties>} graphProperties the entities to update
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public updateEntities(organizationId: string, graphId: string, type: UpdateEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).updateEntities(organizationId, graphId, type, graphProperties, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the metaData of the specified graph
     * @summary Update the metaData of the specified graph
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {{ [key: string]: string; }} requestBody the metaData to update
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public updateGraphMetaData(organizationId: string, graphId: string, requestBody: { [key: string]: string; }, options?: RawAxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).updateGraphMetaData(organizationId, graphId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CreateEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type CreateEntitiesTypeEnum = typeof CreateEntitiesTypeEnum[keyof typeof CreateEntitiesTypeEnum];
/**
 * @export
 */
export const DeleteEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type DeleteEntitiesTypeEnum = typeof DeleteEntitiesTypeEnum[keyof typeof DeleteEntitiesTypeEnum];
/**
 * @export
 */
export const GetEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type GetEntitiesTypeEnum = typeof GetEntitiesTypeEnum[keyof typeof GetEntitiesTypeEnum];
/**
 * @export
 */
export const UpdateEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type UpdateEntitiesTypeEnum = typeof UpdateEntitiesTypeEnum[keyof typeof UpdateEntitiesTypeEnum];


/**
 * WorkspaceApi - axios parameter creator
 * @export
 */
export const WorkspaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspaceAccessControl: async (organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceAccessControl' is not null or undefined
            assertParamExists('addWorkspaceAccessControl', 'workspaceAccessControl', workspaceAccessControl)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a secret for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceSecret} workspaceSecret the definition of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret: async (organizationId: string, workspaceId: string, workspaceSecret: WorkspaceSecret, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSecret', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createSecret', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceSecret' is not null or undefined
            assertParamExists('createSecret', 'workspaceSecret', workspaceSecret)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/secret`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceSecret, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace: async (organizationId: string, workspace: Workspace, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createWorkspace', 'workspace', workspace)
            const localVarPath = `/organizations/{organization_id}/workspaces`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllWorkspaceFiles: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteAllWorkspaceFiles', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteAllWorkspaceFiles', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFile: async (organizationId: string, workspaceId: string, fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'fileName', fileName)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files/delete`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadWorkspaceFile: async (organizationId: string, workspaceId: string, fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('downloadWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('downloadWorkspaceFile', 'fileName', fileName)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files/download`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaceFiles: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllWorkspaceFiles', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findAllWorkspaceFiles', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaces: async (organizationId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllWorkspaces', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/workspaces`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkspaceById: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findWorkspaceById', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findWorkspaceById', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions: async (organizationId: string, workspaceId: string, role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspacePermissions', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspacePermissions', 'workspaceId', workspaceId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getWorkspacePermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurity: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceSecurity', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurityUsers: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceSecurityUsers', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataset: async (organizationId: string, workspaceId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('linkDataset', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('linkDataset', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('linkDataset', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/link`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (datasetId !== undefined) {
                localVarQueryParameter['datasetId'] = datasetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeWorkspaceAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Workspace default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceDefaultSecurity: async (organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setWorkspaceDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('setWorkspaceDefaultSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceRole' is not null or undefined
            assertParamExists('setWorkspaceDefaultSecurity', 'workspaceRole', workspaceRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataset: async (organizationId: string, workspaceId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('unlinkDataset', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('unlinkDataset', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('unlinkDataset', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/unlink`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (datasetId !== undefined) {
                localVarQueryParameter['datasetId'] = datasetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Workspace} workspace The new Workspace details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace: async (organizationId: string, workspaceId: string, workspace: Workspace, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceId', workspaceId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateWorkspace', 'workspace', workspace)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'identityId', identityId)
            // verify required parameter 'workspaceRole' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'workspaceRole', workspaceRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {File} file 
         * @param {boolean} [overwrite] 
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadWorkspaceFile: async (organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('uploadWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('uploadWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadWorkspaceFile', 'file', file)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


            if (overwrite !== undefined) { 
                localVarFormParams.append('overwrite', overwrite as any);
            }
    
            if (destination !== undefined) { 
                localVarFormParams.append('destination', destination as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspaceApi - functional programming interface
 * @export
 */
export const WorkspaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.addWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a secret for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceSecret} workspaceSecret the definition of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSecret(organizationId: string, workspaceId: string, workspaceSecret: WorkspaceSecret, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSecret(organizationId, workspaceId, workspaceSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.createSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspace(organizationId: string, workspace: Workspace, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspace(organizationId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.createWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllWorkspaceFiles(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteAllWorkspaceFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspace(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceFile(organizationId, workspaceId, fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteWorkspaceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadWorkspaceFile(organizationId, workspaceId, fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.downloadWorkspaceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllWorkspaceFiles(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.findAllWorkspaceFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllWorkspaces(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workspace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllWorkspaces(organizationId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.findAllWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findWorkspaceById(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findWorkspaceById(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.findWorkspaceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceAccessControl(organizationId, workspaceId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspacePermissions(organizationId: string, workspaceId: string, role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspacePermissions(organizationId, workspaceId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspacePermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceSecurity(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspaceSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceSecurityUsers(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspaceSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkDataset(organizationId, workspaceId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.linkDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeWorkspaceAccessControl(organizationId, workspaceId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.removeWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Workspace default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.setWorkspaceDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkDataset(organizationId, workspaceId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.unlinkDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Workspace} workspace The new Workspace details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspace(organizationId: string, workspaceId: string, workspace: Workspace, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspace(organizationId, workspaceId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.updateWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.updateWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {File} file 
         * @param {boolean} [overwrite] 
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadWorkspaceFile(organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.uploadWorkspaceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspaceApi - factory interface
 * @export
 */
export const WorkspaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspaceApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: any): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.addWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a secret for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceSecret} workspaceSecret the definition of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret(organizationId: string, workspaceId: string, workspaceSecret: WorkspaceSecret, options?: any): AxiosPromise<void> {
            return localVarFp.createSecret(organizationId, workspaceId, workspaceSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(organizationId: string, workspace: Workspace, options?: any): AxiosPromise<Workspace> {
            return localVarFp.createWorkspace(organizationId, workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Workspace> {
            return localVarFp.deleteWorkspace(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: any): AxiosPromise<File> {
            return localVarFp.downloadWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Array<WorkspaceFile>> {
            return localVarFp.findAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaces(organizationId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<Workspace>> {
            return localVarFp.findAllWorkspaces(organizationId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkspaceById(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Workspace> {
            return localVarFp.findWorkspaceById(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: any): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.getWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions(organizationId: string, workspaceId: string, role: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getWorkspacePermissions(organizationId, workspaceId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: any): AxiosPromise<WorkspaceSecurity> {
            return localVarFp.getWorkspaceSecurity(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getWorkspaceSecurityUsers(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataset(organizationId: string, workspaceId: string, datasetId: string, options?: any): AxiosPromise<Workspace> {
            return localVarFp.linkDataset(organizationId, workspaceId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Workspace default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: any): AxiosPromise<WorkspaceSecurity> {
            return localVarFp.setWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataset(organizationId: string, workspaceId: string, datasetId: string, options?: any): AxiosPromise<Workspace> {
            return localVarFp.unlinkDataset(organizationId, workspaceId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Workspace} workspace The new Workspace details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(organizationId: string, workspaceId: string, workspace: Workspace, options?: any): AxiosPromise<Workspace> {
            return localVarFp.updateWorkspace(organizationId, workspaceId, workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: any): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {File} file 
         * @param {boolean} [overwrite] 
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadWorkspaceFile(organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options?: any): AxiosPromise<WorkspaceFile> {
            return localVarFp.uploadWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspaceApi - object-oriented interface
 * @export
 * @class WorkspaceApi
 * @extends {BaseAPI}
 */
export class WorkspaceApi extends BaseAPI {
    /**
     * 
     * @summary Add a control access to the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public addWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).addWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a secret for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {WorkspaceSecret} workspaceSecret the definition of the secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createSecret(organizationId: string, workspaceId: string, workspaceSecret: WorkspaceSecret, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createSecret(organizationId, workspaceId, workspaceSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new workspace
     * @param {string} organizationId the Organization identifier
     * @param {Workspace} workspace the Workspace to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createWorkspace(organizationId: string, workspace: Workspace, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createWorkspace(organizationId, workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all Workspace files
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspace(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace file
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} fileName the file name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download the Workspace File specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} fileName the file name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public downloadWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).downloadWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Workspace files
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public findAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).findAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Workspaces
     * @param {string} organizationId the Organization identifier
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public findAllWorkspaces(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).findAllWorkspaces(organizationId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public findWorkspaceById(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).findWorkspaceById(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace permission by given role
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} role the Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspacePermissions(organizationId: string, workspaceId: string, role: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspacePermissions(organizationId, workspaceId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace security information
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceSecurity(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceSecurityUsers(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId dataset id to be linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public linkDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).linkDataset(organizationId, workspaceId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public removeWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).removeWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Workspace default security
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public setWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).setWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId dataset id to be linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public unlinkDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).unlinkDataset(organizationId, workspaceId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {Workspace} workspace The new Workspace details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspace(organizationId: string, workspaceId: string, workspace: Workspace, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspace(organizationId, workspaceId, workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} identityId the User identifier
     * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a file for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {File} file 
     * @param {boolean} [overwrite] 
     * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public uploadWorkspaceFile(organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).uploadWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options).then((request) => request(this.axios, this.basePath));
    }
}



