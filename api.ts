/* tslint:disable */
/* eslint-disable */
/**
 * Cosmo Tech Platform API
 * Cosmo Tech Platform API
 *
 * The version of the OpenAPI document: 2.4.1-SNAPSHOT
 * Contact: platform@cosmotech.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * a RBAC by component
 * @export
 * @interface ComponentRolePermissions
 */
export interface ComponentRolePermissions {
    /**
     * 
     * @type {string}
     * @memberof ComponentRolePermissions
     */
    'component'?: string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ComponentRolePermissions
     */
    'roles'?: { [key: string]: Array<string>; };
}
/**
 * a version of a Connector
 * @export
 * @interface Connector
 */
export interface Connector {
    /**
     * the Connector version unique identifier
     * @type {string}
     * @memberof Connector
     */
    'id'?: string;
    /**
     * the Connector key which group Connector versions
     * @type {string}
     * @memberof Connector
     */
    'key': string;
    /**
     * the Connector name
     * @type {string}
     * @memberof Connector
     */
    'name': string;
    /**
     * the Connector description
     * @type {string}
     * @memberof Connector
     */
    'description'?: string;
    /**
     * the registry repository containing the image
     * @type {string}
     * @memberof Connector
     */
    'repository': string;
    /**
     * the Connector version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof Connector
     */
    'version': string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Connector
     */
    'tags'?: Array<string>;
    /**
     * the user id which own this connector version
     * @type {string}
     * @memberof Connector
     */
    'ownerId'?: string;
    /**
     * an optional URL link to connector page
     * @type {string}
     * @memberof Connector
     */
    'url'?: string;
    /**
     * whether or not the connector uses Azure Managed Identity
     * @type {boolean}
     * @memberof Connector
     */
    'azureManagedIdentity'?: boolean;
    /**
     * whether to authenticate against Azure using the app registration credentials provided by the customer
     * @type {boolean}
     * @memberof Connector
     */
    'azureAuthenticationWithCustomerAppRegistration'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Connector
     */
    'ioTypes': Array<ConnectorIoTypesEnum>;
    /**
     * the list of connector parameters groups
     * @type {Array<ConnectorParameterGroup>}
     * @memberof Connector
     */
    'parameterGroups'?: Array<ConnectorParameterGroup>;
}

export const ConnectorIoTypesEnum = {
    Read: 'read',
    Write: 'write'
} as const;

export type ConnectorIoTypesEnum = typeof ConnectorIoTypesEnum[keyof typeof ConnectorIoTypesEnum];

/**
 * a connector parameter
 * @export
 * @interface ConnectorParameter
 */
export interface ConnectorParameter {
    /**
     * the connector parameter id
     * @type {string}
     * @memberof ConnectorParameter
     */
    'id': string;
    /**
     * the list of translated parameter group labels
     * @type {string}
     * @memberof ConnectorParameter
     */
    'label': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof ConnectorParameter
     */
    'valueType'?: string;
    /**
     * the list of available and valid values for the parameter
     * @type {Array<string>}
     * @memberof ConnectorParameter
     */
    'options'?: Array<string>;
    /**
     * the default value
     * @type {string}
     * @memberof ConnectorParameter
     */
    'default'?: string;
    /**
     * associated environment variable in connector image
     * @type {string}
     * @memberof ConnectorParameter
     */
    'envVar'?: string;
}
/**
 * a connector parameters group
 * @export
 * @interface ConnectorParameterGroup
 */
export interface ConnectorParameterGroup {
    /**
     * the connector parameter group id
     * @type {string}
     * @memberof ConnectorParameterGroup
     */
    'id': string;
    /**
     * the list of translated parameter group labels
     * @type {string}
     * @memberof ConnectorParameterGroup
     */
    'label': string;
    /**
     * the list of parameters
     * @type {Array<ConnectorParameter>}
     * @memberof ConnectorParameterGroup
     */
    'parameters': Array<ConnectorParameter>;
}
/**
 * define cpus and memory needs
 * @export
 * @interface ContainerResourceSizeInfo
 */
export interface ContainerResourceSizeInfo {
    /**
     * define cpu needs
     * @type {string}
     * @memberof ContainerResourceSizeInfo
     */
    'cpu': string;
    /**
     * define memory needs
     * @type {string}
     * @memberof ContainerResourceSizeInfo
     */
    'memory': string;
}
/**
 * a description object for resource requests and limits (default same configuration as basic sizing)
 * @export
 * @interface ContainerResourceSizing
 */
export interface ContainerResourceSizing {
    /**
     * 
     * @type {ContainerResourceSizeInfo}
     * @memberof ContainerResourceSizing
     */
    'requests': ContainerResourceSizeInfo;
    /**
     * 
     * @type {ContainerResourceSizeInfo}
     * @memberof ContainerResourceSizing
     */
    'limits': ContainerResourceSizeInfo;
}
/**
 * a Dataset
 * @export
 * @interface Dataset
 */
export interface Dataset {
    /**
     * the Dataset unique identifier
     * @type {string}
     * @memberof Dataset
     */
    'id'?: string;
    /**
     * the Dataset name
     * @type {string}
     * @memberof Dataset
     */
    'name'?: string;
    /**
     * the Dataset description
     * @type {string}
     * @memberof Dataset
     */
    'description'?: string;
    /**
     * the User id which own this Dataset
     * @type {string}
     * @memberof Dataset
     */
    'ownerId'?: string;
    /**
     * the Organization Id related to this Dataset
     * @type {string}
     * @memberof Dataset
     */
    'organizationId'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Dataset
     */
    'tags'?: Array<string>;
    /**
     * the Connector setup bound to a Dataset
     * @type {DatasetConnector}
     * @memberof Dataset
     */
    'connector'?: DatasetConnector;
    /**
     * the list of other Datasets ids to compose as fragments
     * @type {Array<string>}
     * @memberof Dataset
     */
    'fragmentsIds'?: Array<string>;
    /**
     * the validator id
     * @type {string}
     * @memberof Dataset
     */
    'validatorId'?: string;
    /**
     * the list of compatible Solutions versions
     * @type {Array<DatasetCompatibility>}
     * @memberof Dataset
     */
    'compatibility'?: Array<DatasetCompatibility>;
}
/**
 * a Dataset compatibility constraint to a Solution version open range
 * @export
 * @interface DatasetCompatibility
 */
export interface DatasetCompatibility {
    /**
     * the Solution key which group Solution versions
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'solutionKey': string;
    /**
     * the Solution minimum version compatibility (version included)
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'minimumVersion'?: string;
    /**
     * the Solution maximum version compatibility (version included)
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'maximumVersion'?: string;
}
/**
 * a Connector setup
 * @export
 * @interface DatasetConnector
 */
export interface DatasetConnector {
    /**
     * the Connector id
     * @type {string}
     * @memberof DatasetConnector
     */
    'id'?: string;
    /**
     * the Connector name
     * @type {string}
     * @memberof DatasetConnector
     */
    'name'?: string;
    /**
     * the Connector version
     * @type {string}
     * @memberof DatasetConnector
     */
    'version'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DatasetConnector
     */
    'parametersValues'?: { [key: string]: string; };
}
/**
 * the Dataset Copy Parameters
 * @export
 * @interface DatasetCopyParameters
 */
export interface DatasetCopyParameters {
    /**
     * the source Dataset id
     * @type {string}
     * @memberof DatasetCopyParameters
     */
    'sourceId'?: string;
    /**
     * the target Dataset id
     * @type {string}
     * @memberof DatasetCopyParameters
     */
    'targetId'?: string;
    /**
     * freeform options to path to connectors
     * @type {{ [key: string]: object; }}
     * @memberof DatasetCopyParameters
     */
    'options'?: { [key: string]: object; };
}
/**
 * the search options
 * @export
 * @interface DatasetSearch
 */
export interface DatasetSearch {
    /**
     * the dataset tag list to search
     * @type {Array<string>}
     * @memberof DatasetSearch
     */
    'datasetTags': Array<string>;
}
/**
 * Configuration of scenario runs deletion automatic mecanism
 * @export
 * @interface DeleteHistoricalData
 */
export interface DeleteHistoricalData {
    /**
     * Activate or Deactivate historical data deletion
     * @type {boolean}
     * @memberof DeleteHistoricalData
     */
    'enable': boolean;
    /**
     * define the polling frequency of scenario run status (in millis)
     * @type {number}
     * @memberof DeleteHistoricalData
     */
    'pollFrequency'?: number;
    /**
     * define the polling timeout
     * @type {number}
     * @memberof DeleteHistoricalData
     */
    'timeOut'?: number;
}
/**
 * 
 * @export
 * @interface GraphProperties
 */
export interface GraphProperties {
    /**
     * the type of the relationship
     * @type {string}
     * @memberof GraphProperties
     */
    'type'?: string;
    /**
     * the source node of the relationship
     * @type {string}
     * @memberof GraphProperties
     */
    'source'?: string;
    /**
     * the target node of the relationship
     * @type {string}
     * @memberof GraphProperties
     */
    'target'?: string;
    /**
     * the name of the graph data object
     * @type {string}
     * @memberof GraphProperties
     */
    'name'?: string;
    /**
     * the parameters of the graph data object
     * @type {string}
     * @memberof GraphProperties
     */
    'params'?: string;
}
/**
 * an Organization
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * the Organization unique identifier
     * @type {string}
     * @memberof Organization
     */
    'id'?: string;
    /**
     * the Organization name
     * @type {string}
     * @memberof Organization
     */
    'name'?: string;
    /**
     * the Owner User Id
     * @type {string}
     * @memberof Organization
     */
    'ownerId'?: string;
    /**
     * 
     * @type {OrganizationServices}
     * @memberof Organization
     */
    'services'?: OrganizationServices;
    /**
     * 
     * @type {OrganizationSecurity}
     * @memberof Organization
     */
    'security'?: OrganizationSecurity;
}
/**
 * a Organization access control item
 * @export
 * @interface OrganizationAccessControl
 */
export interface OrganizationAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof OrganizationAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof OrganizationAccessControl
     */
    'role': string;
}
/**
 * the Organization Role
 * @export
 * @interface OrganizationRole
 */
export interface OrganizationRole {
    /**
     * the Organization Role
     * @type {string}
     * @memberof OrganizationRole
     */
    'role': string;
}
/**
 * the Organization security information
 * @export
 * @interface OrganizationSecurity
 */
export interface OrganizationSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof OrganizationSecurity
     */
    'default': string;
    /**
     * the list which can access this Organization with detailed access control information
     * @type {Array<OrganizationAccessControl>}
     * @memberof OrganizationSecurity
     */
    'accessControlList': Array<OrganizationAccessControl>;
}
/**
 * a cloud service resource
 * @export
 * @interface OrganizationService
 */
export interface OrganizationService {
    /**
     * the cloud service name
     * @type {string}
     * @memberof OrganizationService
     */
    'cloudService'?: string;
    /**
     * the platform base uri for this service
     * @type {string}
     * @memberof OrganizationService
     */
    'baseUri'?: string;
    /**
     * the Platform service associated to the resource
     * @type {string}
     * @memberof OrganizationService
     */
    'platformService'?: string;
    /**
     * the Organization specific uri for this service resource
     * @type {string}
     * @memberof OrganizationService
     */
    'resourceUri'?: string;
    /**
     * a freeform credentials object. Structure depends on service
     * @type {{ [key: string]: object; }}
     * @memberof OrganizationService
     */
    'credentials'?: { [key: string]: object; };
}
/**
 * the cloud service resources of the Organization
 * @export
 * @interface OrganizationServices
 */
export interface OrganizationServices {
    /**
     * a freeform credentials object for the Organization tenant. Structure depends on cloud provider
     * @type {{ [key: string]: object; }}
     * @memberof OrganizationServices
     */
    'tenantCredentials'?: { [key: string]: object; };
    /**
     * 
     * @type {OrganizationService}
     * @memberof OrganizationServices
     */
    'storage'?: OrganizationService;
    /**
     * 
     * @type {OrganizationService}
     * @memberof OrganizationServices
     */
    'solutionsContainerRegistry'?: OrganizationService;
}
/**
 * define cpus and memory needs
 * @export
 * @interface ResourceSizeInfo
 */
export interface ResourceSizeInfo {
    /**
     * define cpu needs
     * @type {string}
     * @memberof ResourceSizeInfo
     */
    'cpu': string;
    /**
     * define memory needs
     * @type {string}
     * @memberof ResourceSizeInfo
     */
    'memory': string;
}
/**
 * a Solution Run Template
 * @export
 * @interface RunTemplate
 */
export interface RunTemplate {
    /**
     * the Solution Run Template id
     * @type {string}
     * @memberof RunTemplate
     */
    'id': string;
    /**
     * the Run Template name
     * @type {string}
     * @memberof RunTemplate
     */
    'name'?: string;
    /**
     * the Run Template description
     * @type {string}
     * @memberof RunTemplate
     */
    'description'?: string;
    /**
     * the Cosmo Tech simulation name. This information is send to the Engine. Mandatory information if no Engine is defined
     * @type {string}
     * @memberof RunTemplate
     */
    'csmSimulation'?: string;
    /**
     * the list of Run Template tags
     * @type {Array<string>}
     * @memberof RunTemplate
     */
    'tags'?: Array<string>;
    /**
     * the compute size needed for this Run Template. Standard sizes are basic and highcpu. Default is basic
     * @type {string}
     * @memberof RunTemplate
     */
    'computeSize'?: string;
    /**
     * 
     * @type {RunTemplateResourceSizing}
     * @memberof RunTemplate
     */
    'runSizing'?: RunTemplateResourceSizing;
    /**
     * set to true if the run template does not want to check data ingestion state (no probes or not control plane)
     * @type {boolean}
     * @memberof RunTemplate
     */
    'noDataIngestionState'?: boolean;
    /**
     * whether or not the fetch dataset step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'fetchDatasets'?: boolean;
    /**
     * whether or not the scenario data download transform step step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'scenarioDataDownloadTransform'?: boolean;
    /**
     * whether or not the fetch parameters step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'fetchScenarioParameters'?: boolean;
    /**
     * whether or not the apply parameter step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'applyParameters'?: boolean;
    /**
     * whether or not the validate step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'validateData'?: boolean;
    /**
     * whether or not the Datasets values are send to the DataWarehouse prior to Simulation Run. If not set follow the Workspace setting
     * @type {boolean}
     * @memberof RunTemplate
     */
    'sendDatasetsToDataWarehouse'?: boolean;
    /**
     * whether or not the input parameters values are send to the DataWarehouse prior to Simulation Run. If not set follow the Workspace setting
     * @type {boolean}
     * @memberof RunTemplate
     */
    'sendInputParametersToDataWarehouse'?: boolean;
    /**
     * whether or not the pre-run step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'preRun'?: boolean;
    /**
     * whether or not the run step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'run'?: boolean;
    /**
     * whether or not the post-run step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'postRun'?: boolean;
    /**
     * whether or not to store the scenario parameters in json instead of csv
     * @type {boolean}
     * @memberof RunTemplate
     */
    'parametersJson'?: boolean;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'parametersHandlerSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'datasetValidatorSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'preRunSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'runSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'postRunSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'scenariodataTransformSource'?: RunTemplateStepSource;
    /**
     * the ordered list of parameters groups for the Run Template
     * @type {Array<string>}
     * @memberof RunTemplate
     */
    'parameterGroups'?: Array<string>;
    /**
     * whether or not to stack adjacent scenario run steps in one container run which will chain steps
     * @type {boolean}
     * @memberof RunTemplate
     */
    'stackSteps'?: boolean;
    /**
     * an optional URL to the git repository
     * @type {string}
     * @memberof RunTemplate
     */
    'gitRepositoryUrl'?: string;
    /**
     * an optional git branch name
     * @type {string}
     * @memberof RunTemplate
     */
    'gitBranchName'?: string;
    /**
     * an optional directory where to find the run template source
     * @type {string}
     * @memberof RunTemplate
     */
    'runTemplateSourceDir'?: string;
    /**
     * an optional duration in seconds in which a workflow is allowed to run
     * @type {number}
     * @memberof RunTemplate
     */
    'executionTimeout'?: number;
    /**
     * 
     * @type {DeleteHistoricalData}
     * @memberof RunTemplate
     */
    'deleteHistoricalData'?: DeleteHistoricalData;
}
/**
 * the Run Template step handler identifier
 * @export
 * @enum {string}
 */

export const RunTemplateHandlerId = {
    ParametersHandler: 'parameters_handler',
    Validator: 'validator',
    Prerun: 'prerun',
    Engine: 'engine',
    Postrun: 'postrun',
    ScenariodataTransform: 'scenariodata_transform'
} as const;

export type RunTemplateHandlerId = typeof RunTemplateHandlerId[keyof typeof RunTemplateHandlerId];


/**
 * a Run Template Parameter
 * @export
 * @interface RunTemplateParameter
 */
export interface RunTemplateParameter {
    /**
     * the Parameter id
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'id': string;
    /**
     * a translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameter
     */
    'labels'?: { [key: string]: string; };
    /**
     * the variable type for the parameter. Basic types or special type %DATASETID%
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'varType'?: string;
    /**
     * the default value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'defaultValue'?: string;
    /**
     * the minimum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'minValue'?: string;
    /**
     * the maximum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'maxValue'?: string;
    /**
     * a regex to validate the value
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'regexValidation'?: string;
    /**
     * freeform options
     * @type {{ [key: string]: object; }}
     * @memberof RunTemplateParameter
     */
    'options'?: { [key: string]: object; };
}
/**
 * a Parameter Group for a Run Template
 * @export
 * @interface RunTemplateParameterGroup
 */
export interface RunTemplateParameterGroup {
    /**
     * the Parameter Group id
     * @type {string}
     * @memberof RunTemplateParameterGroup
     */
    'id': string;
    /**
     * a translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameterGroup
     */
    'labels'?: { [key: string]: string; };
    /**
     * does the group define a table
     * @type {boolean}
     * @memberof RunTemplateParameterGroup
     */
    'isTable'?: boolean;
    /**
     * freeform options
     * @type {{ [key: string]: object; }}
     * @memberof RunTemplateParameterGroup
     */
    'options'?: { [key: string]: object; };
    /**
     * the Run Template Group parent Id
     * @type {string}
     * @memberof RunTemplateParameterGroup
     */
    'parentId'?: string;
    /**
     * an ordered list of Run Template Parameters
     * @type {Array<string>}
     * @memberof RunTemplateParameterGroup
     */
    'parameters'?: Array<string>;
}
/**
 * the value of Analysis parameter for a Scenario for this ScenarioRun
 * @export
 * @interface RunTemplateParameterValue
 */
export interface RunTemplateParameterValue {
    /**
     * the parameter Id
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'parameterId': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'value': string;
}
/**
 * a description object for resource requests and limits (default same configuration as basic sizing)
 * @export
 * @interface RunTemplateResourceSizing
 */
export interface RunTemplateResourceSizing {
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunTemplateResourceSizing
     */
    'requests': ResourceSizeInfo;
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunTemplateResourceSizing
     */
    'limits': ResourceSizeInfo;
}
/**
 * the source local, cloud or git repository
 * @export
 * @enum {string}
 */

export const RunTemplateStepSource = {
    Cloud: 'cloud',
    Git: 'git',
    Local: 'local',
    Platform: 'platform'
} as const;

export type RunTemplateStepSource = typeof RunTemplateStepSource[keyof typeof RunTemplateStepSource];


/**
 * a Scenario with base information
 * @export
 * @interface Scenario
 */
export interface Scenario {
    /**
     * the Scenario unique identifier
     * @type {string}
     * @memberof Scenario
     */
    'id'?: string;
    /**
     * the Scenario name
     * @type {string}
     * @memberof Scenario
     */
    'name'?: string;
    /**
     * the Scenario description
     * @type {string}
     * @memberof Scenario
     */
    'description'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Scenario
     */
    'tags'?: Array<string>;
    /**
     * the Scenario parent id
     * @type {string}
     * @memberof Scenario
     */
    'parentId'?: string;
    /**
     * the user id which own this Scenario
     * @type {string}
     * @memberof Scenario
     */
    'ownerId'?: string;
    /**
     * the scenario root id
     * @type {string}
     * @memberof Scenario
     */
    'rootId'?: string;
    /**
     * the Solution Id associated with this Scenario
     * @type {string}
     * @memberof Scenario
     */
    'solutionId'?: string;
    /**
     * the Solution Run Template Id associated with this Scenario
     * @type {string}
     * @memberof Scenario
     */
    'runTemplateId'?: string;
    /**
     * the associated Organization Id
     * @type {string}
     * @memberof Scenario
     */
    'organizationId'?: string;
    /**
     * the associated Workspace Id
     * @type {string}
     * @memberof Scenario
     */
    'workspaceId'?: string;
    /**
     * 
     * @type {ScenarioJobState}
     * @memberof Scenario
     */
    'state'?: ScenarioJobState;
    /**
     * the Scenario creation date
     * @type {number}
     * @memberof Scenario
     */
    'creationDate'?: number;
    /**
     * the last time a Scenario was updated
     * @type {number}
     * @memberof Scenario
     */
    'lastUpdate'?: number;
    /**
     * the name of the owner
     * @type {string}
     * @memberof Scenario
     */
    'ownerName'?: string;
    /**
     * the Solution name
     * @type {string}
     * @memberof Scenario
     */
    'solutionName'?: string;
    /**
     * the Solution Run Template name associated with this Scenario
     * @type {string}
     * @memberof Scenario
     */
    'runTemplateName'?: string;
    /**
     * the list of Dataset Id associated to this Scenario Run Template
     * @type {Array<string>}
     * @memberof Scenario
     */
    'datasetList'?: Array<string>;
    /**
     * 
     * @type {ScenarioResourceSizing}
     * @memberof Scenario
     */
    'runSizing'?: ScenarioResourceSizing;
    /**
     * the list of Solution Run Template parameters values
     * @type {Array<ScenarioRunTemplateParameterValue>}
     * @memberof Scenario
     */
    'parametersValues'?: Array<ScenarioRunTemplateParameterValue>;
    /**
     * 
     * @type {ScenarioLastRun & object}
     * @memberof Scenario
     */
    'lastRun'?: ScenarioLastRun & object;
    /**
     * 
     * @type {ScenarioLastRun & object}
     * @memberof Scenario
     */
    'parentLastRun'?: ScenarioLastRun & object;
    /**
     * 
     * @type {ScenarioLastRun & object}
     * @memberof Scenario
     */
    'rootLastRun'?: ScenarioLastRun & object;
    /**
     * 
     * @type {ScenarioValidationStatus}
     * @memberof Scenario
     */
    'validationStatus'?: ScenarioValidationStatus;
    /**
     * 
     * @type {ScenarioSecurity}
     * @memberof Scenario
     */
    'security'?: ScenarioSecurity;
}
/**
 * a Scenario access control item
 * @export
 * @interface ScenarioAccessControl
 */
export interface ScenarioAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof ScenarioAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof ScenarioAccessControl
     */
    'role': string;
}
/**
 * the difference between the values of a parameter
 * @export
 * @interface ScenarioChangedParameterValue
 */
export interface ScenarioChangedParameterValue {
    /**
     * the parameter id the values refer to
     * @type {string}
     * @memberof ScenarioChangedParameterValue
     */
    'parameterId'?: string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof ScenarioChangedParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value for the reference Scenario
     * @type {string}
     * @memberof ScenarioChangedParameterValue
     */
    'value'?: string;
    /**
     * the parameter value for the compared Scenario
     * @type {string}
     * @memberof ScenarioChangedParameterValue
     */
    'comparedValue'?: string;
}
/**
 * the result of the comparison of two scenarios
 * @export
 * @interface ScenarioComparisonResult
 */
export interface ScenarioComparisonResult {
    /**
     * the Scenario Id which is the reference for the comparison
     * @type {string}
     * @memberof ScenarioComparisonResult
     */
    'scenarioId'?: string;
    /**
     * the Scenario Id the reference Scenario is compared to
     * @type {string}
     * @memberof ScenarioComparisonResult
     */
    'comparedScenarioId'?: string;
    /**
     * the list of changed values for parameters
     * @type {Array<ScenarioChangedParameterValue>}
     * @memberof ScenarioComparisonResult
     */
    'changedValues'?: Array<ScenarioChangedParameterValue>;
}
/**
 * Scenario data download job info
 * @export
 * @interface ScenarioDataDownloadInfo
 */
export interface ScenarioDataDownloadInfo {
    /**
     * the Scenario Data Download URL
     * @type {string}
     * @memberof ScenarioDataDownloadInfo
     */
    'url'?: string;
    /**
     * 
     * @type {ScenarioJobState}
     * @memberof ScenarioDataDownloadInfo
     */
    'state'?: ScenarioJobState;
}
/**
 * Scenario data download job
 * @export
 * @interface ScenarioDataDownloadJob
 */
export interface ScenarioDataDownloadJob {
    /**
     * the Scenario Data Download job identifier
     * @type {string}
     * @memberof ScenarioDataDownloadJob
     */
    'id'?: string;
}
/**
 * the Scenario job state
 * @export
 * @enum {string}
 */

export const ScenarioJobState = {
    Created: 'Created',
    Running: 'Running',
    Successful: 'Successful',
    Failed: 'Failed',
    Unknown: 'Unknown',
    DataIngestionInProgress: 'DataIngestionInProgress'
} as const;

export type ScenarioJobState = typeof ScenarioJobState[keyof typeof ScenarioJobState];


/**
 * 
 * @export
 * @interface ScenarioLastRun
 */
export interface ScenarioLastRun {
    /**
     * the last Scenario Run id
     * @type {string}
     * @memberof ScenarioLastRun
     */
    'scenarioRunId'?: string;
    /**
     * the last Cosmo Tech Simulation Run id
     * @type {string}
     * @memberof ScenarioLastRun
     */
    'csmSimulationRun'?: string;
    /**
     * the last Workflow Id
     * @type {string}
     * @memberof ScenarioLastRun
     */
    'workflowId'?: string;
    /**
     * the last Workflow name
     * @type {string}
     * @memberof ScenarioLastRun
     */
    'workflowName'?: string;
}
/**
 * a description object for resource requests and limits (default same configuration as basic sizing)
 * @export
 * @interface ScenarioResourceSizing
 */
export interface ScenarioResourceSizing {
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof ScenarioResourceSizing
     */
    'requests': ResourceSizeInfo;
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof ScenarioResourceSizing
     */
    'limits': ResourceSizeInfo;
}
/**
 * the Scenario Role
 * @export
 * @interface ScenarioRole
 */
export interface ScenarioRole {
    /**
     * the Scenario Role
     * @type {string}
     * @memberof ScenarioRole
     */
    'role': string;
}
/**
 * a ScenarioRun with only base properties
 * @export
 * @interface ScenarioRun
 */
export interface ScenarioRun {
    /**
     * the ScenarioRun
     * @type {string}
     * @memberof ScenarioRun
     */
    'id'?: string;
    /**
     * 
     * @type {ScenarioRunState}
     * @memberof ScenarioRun
     */
    'state'?: ScenarioRunState;
    /**
     * the Organization id
     * @type {string}
     * @memberof ScenarioRun
     */
    'organizationId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof ScenarioRun
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech Simulation Run Id
     * @type {string}
     * @memberof ScenarioRun
     */
    'csmSimulationRun'?: string;
    /**
     * the base name for workflow name generation
     * @type {string}
     * @memberof ScenarioRun
     */
    'generateName'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof ScenarioRun
     */
    'workflowName'?: string;
    /**
     * the user id which own this scenariorun
     * @type {string}
     * @memberof ScenarioRun
     */
    'ownerId'?: string;
    /**
     * the Workspace Id
     * @type {string}
     * @memberof ScenarioRun
     */
    'workspaceId'?: string;
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof ScenarioRun
     */
    'workspaceKey'?: string;
    /**
     * the Scenario Id
     * @type {string}
     * @memberof ScenarioRun
     */
    'scenarioId'?: string;
    /**
     * the Solution Id
     * @type {string}
     * @memberof ScenarioRun
     */
    'solutionId'?: string;
    /**
     * the Solution Run Template id
     * @type {string}
     * @memberof ScenarioRun
     */
    'runTemplateId'?: string;
    /**
     * the compute size needed for this Analysis. Standard sizes are basic and highcpu. Default is basic
     * @type {string}
     * @memberof ScenarioRun
     */
    'computeSize'?: string;
    /**
     * the MAJOR.MINOR version used to build the solution solution
     * @type {string}
     * @memberof ScenarioRun
     */
    'sdkVersion'?: string;
    /**
     * set to true if the run template does not use any Datawarehouse consumers (AMQP consumers for Azure)
     * @type {boolean}
     * @memberof ScenarioRun
     */
    'noDataIngestionState'?: boolean;
    /**
     * the list of Dataset Id associated to this Analysis
     * @type {Array<string>}
     * @memberof ScenarioRun
     */
    'datasetList'?: Array<string>;
    /**
     * the list of Run Template parameters values
     * @type {Array<RunTemplateParameterValue>}
     * @memberof ScenarioRun
     */
    'parametersValues'?: Array<RunTemplateParameterValue>;
    /**
     * whether or not the Datasets values are send to the DataWarehouse prior to Simulation Run. If not set follow the Workspace setting
     * @type {boolean}
     * @memberof ScenarioRun
     */
    'sendDatasetsToDataWarehouse'?: boolean;
    /**
     * whether or not the input parameters values are send to the DataWarehouse prior to Simulation Run. If not set follow the Workspace setting
     * @type {boolean}
     * @memberof ScenarioRun
     */
    'sendInputParametersToDataWarehouse'?: boolean;
    /**
     * the node label request
     * @type {string}
     * @memberof ScenarioRun
     */
    'nodeLabel'?: string;
    /**
     * the containers list. This information is not returned by the API.
     * @type {Array<ScenarioRunContainer>}
     * @memberof ScenarioRun
     */
    'containers'?: Array<ScenarioRunContainer>;
}
/**
 * a ScenarioRun container description
 * @export
 * @interface ScenarioRunContainer
 */
export interface ScenarioRunContainer {
    /**
     * the container Id
     * @type {string}
     * @memberof ScenarioRunContainer
     */
    'id'?: string;
    /**
     * the container name
     * @type {string}
     * @memberof ScenarioRunContainer
     */
    'name': string;
    /**
     * the metadata labels
     * @type {{ [key: string]: string; }}
     * @memberof ScenarioRunContainer
     */
    'labels'?: { [key: string]: string; };
    /**
     * environment variable map
     * @type {{ [key: string]: string; }}
     * @memberof ScenarioRunContainer
     */
    'envVars'?: { [key: string]: string; };
    /**
     * the container image URI
     * @type {string}
     * @memberof ScenarioRunContainer
     */
    'image': string;
    /**
     * the container entry point
     * @type {string}
     * @memberof ScenarioRunContainer
     */
    'entrypoint'?: string;
    /**
     * the list of run arguments for the container
     * @type {Array<string>}
     * @memberof ScenarioRunContainer
     */
    'runArgs'?: Array<string>;
    /**
     * the list of dependencies container name to run this container
     * @type {Array<string>}
     * @memberof ScenarioRunContainer
     */
    'dependencies'?: Array<string>;
    /**
     * whether or not this container is a Cosmo Tech solution container
     * @type {boolean}
     * @memberof ScenarioRunContainer
     */
    'solutionContainer'?: boolean;
    /**
     * the node label request
     * @type {string}
     * @memberof ScenarioRunContainer
     */
    'nodeLabel'?: string;
    /**
     * 
     * @type {ContainerResourceSizing}
     * @memberof ScenarioRunContainer
     */
    'runSizing'?: ContainerResourceSizing;
    /**
     * the list of artifacts
     * @type {Array<ScenarioRunContainerArtifact>}
     * @memberof ScenarioRunContainer
     */
    'artifacts'?: Array<ScenarioRunContainerArtifact>;
}
/**
 * a scenario run container artifact
 * @export
 * @interface ScenarioRunContainerArtifact
 */
export interface ScenarioRunContainerArtifact {
    /**
     * the artifact name
     * @type {string}
     * @memberof ScenarioRunContainerArtifact
     */
    'name'?: string;
    /**
     * the artifact path (relative to /var/csmoutput)
     * @type {string}
     * @memberof ScenarioRunContainerArtifact
     */
    'path'?: string;
}
/**
 * logs for a given container
 * @export
 * @interface ScenarioRunContainerLogs
 */
export interface ScenarioRunContainerLogs {
    /**
     * the node Id which has executed this log
     * @type {string}
     * @memberof ScenarioRunContainerLogs
     */
    'nodeId'?: string;
    /**
     * the container name
     * @type {string}
     * @memberof ScenarioRunContainerLogs
     */
    'containerName'?: string;
    /**
     * the list of children node id
     * @type {Array<string>}
     * @memberof ScenarioRunContainerLogs
     */
    'children'?: Array<string>;
    /**
     * the node logs in plain text
     * @type {string}
     * @memberof ScenarioRunContainerLogs
     */
    'logs'?: string;
}
/**
 * the scenariorun logs returned by all containers
 * @export
 * @interface ScenarioRunLogs
 */
export interface ScenarioRunLogs {
    /**
     * the ScenarioRun Id
     * @type {string}
     * @memberof ScenarioRunLogs
     */
    'scenariorunId'?: string;
    /**
     * the container map of logs
     * @type {{ [key: string]: ScenarioRunContainerLogs; }}
     * @memberof ScenarioRunLogs
     */
    'containers'?: { [key: string]: ScenarioRunContainerLogs; };
}
/**
 * the search options
 * @export
 * @interface ScenarioRunSearch
 */
export interface ScenarioRunSearch {
    /**
     * the Solution Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'solutionId'?: string;
    /**
     * the Solution Analysis Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'runTemplateId'?: string;
    /**
     * the Workspace Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'workspaceId'?: string;
    /**
     * the Scenario Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'scenarioId'?: string;
    /**
     * the state to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'state'?: ScenarioRunSearchStateEnum;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'workflowName'?: string;
    /**
     * the owner Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'ownerId'?: string;
}

export const ScenarioRunSearchStateEnum = {
    FetchingDatasets: 'FetchingDatasets',
    FetchingScenarioParameters: 'FetchingScenarioParameters',
    ApplyingScenarioParameters: 'ApplyingScenarioParameters',
    ValidatingScenarioData: 'ValidatingScenarioData',
    SendingScenarioDataToDataWarehouse: 'SendingScenarioDataToDataWarehouse',
    PreRun: 'PreRun',
    Running: 'Running',
    PostRun: 'PostRun',
    Success: 'Success',
    Failed: 'Failed'
} as const;

export type ScenarioRunSearchStateEnum = typeof ScenarioRunSearchStateEnum[keyof typeof ScenarioRunSearchStateEnum];

/**
 * the parameters to run directly containers
 * @export
 * @interface ScenarioRunStartContainers
 */
export interface ScenarioRunStartContainers {
    /**
     * the base name for workflow name generation
     * @type {string}
     * @memberof ScenarioRunStartContainers
     */
    'generateName'?: string;
    /**
     * Cosmo Tech Simulation Run Id
     * @type {string}
     * @memberof ScenarioRunStartContainers
     */
    'csmSimulationId': string;
    /**
     * the node label request
     * @type {string}
     * @memberof ScenarioRunStartContainers
     */
    'nodeLabel'?: string;
    /**
     * the workflow labels
     * @type {{ [key: string]: string; }}
     * @memberof ScenarioRunStartContainers
     */
    'labels'?: { [key: string]: string; };
    /**
     * the containerslist
     * @type {Array<ScenarioRunContainer>}
     * @memberof ScenarioRunStartContainers
     */
    'containers': Array<ScenarioRunContainer>;
}
/**
 * the ScenarioRun end-to-end state
 * @export
 * @enum {string}
 */

export const ScenarioRunState = {
    Running: 'Running',
    Successful: 'Successful',
    Failed: 'Failed',
    Unknown: 'Unknown',
    DataIngestionInProgress: 'DataIngestionInProgress',
    DataIngestionFailure: 'DataIngestionFailure'
} as const;

export type ScenarioRunState = typeof ScenarioRunState[keyof typeof ScenarioRunState];


/**
 * a ScenarioRun status
 * @export
 * @interface ScenarioRunStatus
 */
export interface ScenarioRunStatus {
    /**
     * the ScenarioRun id
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'id'?: string;
    /**
     * the ScenarioRun id
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'organizationId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'workflowName'?: string;
    /**
     * the ScenarioRun start Date Time
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'startTime'?: string;
    /**
     * the ScenarioRun end Date Time
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'endTime'?: string;
    /**
     * high-level summary of where the workflow is in its lifecycle
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'phase'?: string;
    /**
     * progress to completion
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'progress'?: string;
    /**
     * a  human readable message indicating details about why the workflow is in this condition
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'message'?: string;
    /**
     * estimatedDuration in seconds
     * @type {number}
     * @memberof ScenarioRunStatus
     */
    'estimatedDuration'?: number;
    /**
     * status of ScenarioRun nodes
     * @type {Array<ScenarioRunStatusNode>}
     * @memberof ScenarioRunStatus
     */
    'nodes'?: Array<ScenarioRunStatusNode>;
    /**
     * 
     * @type {ScenarioRunState}
     * @memberof ScenarioRunStatus
     */
    'state'?: ScenarioRunState;
}
/**
 * status of a ScenarioRun Node
 * @export
 * @interface ScenarioRunStatusNode
 */
export interface ScenarioRunStatusNode {
    /**
     * the node id
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'id'?: string;
    /**
     * the node unique name
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'name'?: string;
    /**
     * the ScenarioRun container name
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'containerName'?: string;
    /**
     * estimatedDuration in seconds
     * @type {number}
     * @memberof ScenarioRunStatusNode
     */
    'estimatedDuration'?: number;
    /**
     * HostNodeName name of the Kubernetes node on which the Pod is running, if applicable
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'hostNodeName'?: string;
    /**
     * a human readable message indicating details about why the node is in this condition
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'message'?: string;
    /**
     * high-level summary of where the node is in its lifecycle
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'phase'?: string;
    /**
     * progress to completion
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'progress'?: string;
    /**
     * the node start time
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'startTime'?: string;
    /**
     * the node end time
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'endTime'?: string;
}
/**
 * the value of a Solution Run Template parameter for a Scenario
 * @export
 * @interface ScenarioRunTemplateParameterValue
 */
export interface ScenarioRunTemplateParameterValue {
    /**
     * the parameter Id
     * @type {string}
     * @memberof ScenarioRunTemplateParameterValue
     */
    'parameterId': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof ScenarioRunTemplateParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value
     * @type {string}
     * @memberof ScenarioRunTemplateParameterValue
     */
    'value': string;
    /**
     * whether or not the value is inherited from parent or has been changed
     * @type {boolean}
     * @memberof ScenarioRunTemplateParameterValue
     */
    'isInherited'?: boolean;
}
/**
 * the Scenario security information
 * @export
 * @interface ScenarioSecurity
 */
export interface ScenarioSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof ScenarioSecurity
     */
    'default': string;
    /**
     * the list which can access this Scenario with detailed access control information
     * @type {Array<ScenarioAccessControl>}
     * @memberof ScenarioSecurity
     */
    'accessControlList': Array<ScenarioAccessControl>;
}
/**
 * the validation status of the scenario
 * @export
 * @enum {string}
 */

export const ScenarioValidationStatus = {
    Draft: 'Draft',
    Rejected: 'Rejected',
    Unknown: 'Unknown',
    Validated: 'Validated'
} as const;

export type ScenarioValidationStatus = typeof ScenarioValidationStatus[keyof typeof ScenarioValidationStatus];


/**
 * a version of a Solution
 * @export
 * @interface Solution
 */
export interface Solution {
    /**
     * the Solution version unique identifier
     * @type {string}
     * @memberof Solution
     */
    'id'?: string;
    /**
     * the Organization unique identifier
     * @type {string}
     * @memberof Solution
     */
    'organizationId'?: string;
    /**
     * the Solution key which group Solution versions
     * @type {string}
     * @memberof Solution
     */
    'key'?: string;
    /**
     * the Solution name
     * @type {string}
     * @memberof Solution
     */
    'name'?: string;
    /**
     * the Solution description
     * @type {string}
     * @memberof Solution
     */
    'description'?: string;
    /**
     * the registry repository containing the image
     * @type {string}
     * @memberof Solution
     */
    'repository'?: string;
    /**
     * the main Cosmo Tech simulator name used in standard Run Template
     * @type {string}
     * @memberof Solution
     */
    'csmSimulator'?: string;
    /**
     * the Solution version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof Solution
     */
    'version'?: string;
    /**
     * the User id which own this Solution
     * @type {string}
     * @memberof Solution
     */
    'ownerId'?: string;
    /**
     * the MAJOR.MINOR version used to build this solution
     * @type {string}
     * @memberof Solution
     */
    'sdkVersion'?: string;
    /**
     * an optional URL link to solution page
     * @type {string}
     * @memberof Solution
     */
    'url'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Solution
     */
    'tags'?: Array<string>;
    /**
     * the list of Run Template Parameters
     * @type {Array<RunTemplateParameter>}
     * @memberof Solution
     */
    'parameters'?: Array<RunTemplateParameter>;
    /**
     * the list of parameters groups for the Run Templates
     * @type {Array<RunTemplateParameterGroup>}
     * @memberof Solution
     */
    'parameterGroups'?: Array<RunTemplateParameterGroup>;
    /**
     * list of Run Template
     * @type {Array<RunTemplate>}
     * @memberof Solution
     */
    'runTemplates'?: Array<RunTemplate>;
}
/**
 * Source job import information
 * @export
 * @interface SourceInfo
 */
export interface SourceInfo {
    /**
     * the source name containing the files to import
     * @type {string}
     * @memberof SourceInfo
     */
    'name'?: string;
    /**
     * the source location containing the files to import
     * @type {string}
     * @memberof SourceInfo
     */
    'location': string;
    /**
     * the source location containing the files to import
     * @type {string}
     * @memberof SourceInfo
     */
    'path'?: string;
    /**
     * the source type containing the files to import
     * @type {string}
     * @memberof SourceInfo
     */
    'type': SourceInfoTypeEnum;
}

export const SourceInfoTypeEnum = {
    Adt: 'ADT',
    Storage: 'Storage'
} as const;

export type SourceInfoTypeEnum = typeof SourceInfoTypeEnum[keyof typeof SourceInfoTypeEnum];

/**
 * Processing result
 * @export
 * @interface TwinGraphBatchResult
 */
export interface TwinGraphBatchResult {
    /**
     * 
     * @type {number}
     * @memberof TwinGraphBatchResult
     */
    'totalLines': number;
    /**
     * 
     * @type {number}
     * @memberof TwinGraphBatchResult
     */
    'processedLines': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TwinGraphBatchResult
     */
    'errors': Array<string>;
}
/**
 * a twin graph hash
 * @export
 * @interface TwinGraphHash
 */
export interface TwinGraphHash {
    /**
     * the hash of the graph
     * @type {string}
     * @memberof TwinGraphHash
     */
    'hash'?: string;
}
/**
 * a twin graph import info
 * @export
 * @interface TwinGraphImport
 */
export interface TwinGraphImport {
    /**
     * 
     * @type {SourceInfo}
     * @memberof TwinGraphImport
     */
    'source': SourceInfo;
    /**
     * the graph id to import to
     * @type {string}
     * @memberof TwinGraphImport
     */
    'graphId': string;
    /**
     * The version of the graph to import to.  When not set, the last version before import is upgraded by 1. When set, the targeted graph is replaced 
     * @type {string}
     * @memberof TwinGraphImport
     */
    'version'?: string;
}
/**
 * a twin graph query in cypher language
 * @export
 * @interface TwinGraphImportInfo
 */
export interface TwinGraphImportInfo {
    /**
     * the import job id
     * @type {string}
     * @memberof TwinGraphImportInfo
     */
    'jobId'?: string;
    /**
     * the twin graph name
     * @type {string}
     * @memberof TwinGraphImportInfo
     */
    'graphName'?: string;
}
/**
 * a twin graph query in cypher language
 * @export
 * @interface TwinGraphQuery
 */
export interface TwinGraphQuery {
    /**
     * Twin graph version
     * @type {string}
     * @memberof TwinGraphQuery
     */
    'version'?: string;
    /**
     * the query in cypher language
     * @type {string}
     * @memberof TwinGraphQuery
     */
    'query': string;
}
/**
 * a Validator to validate a Dataset
 * @export
 * @interface Validator
 */
export interface Validator {
    /**
     * the Validator id
     * @type {string}
     * @memberof Validator
     */
    'id': string;
    /**
     * the Validator name
     * @type {string}
     * @memberof Validator
     */
    'name': string;
    /**
     * the Validator description
     * @type {string}
     * @memberof Validator
     */
    'description'?: string;
    /**
     * the registry repository containing the Validator image
     * @type {string}
     * @memberof Validator
     */
    'repository': string;
    /**
     * the Validator version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof Validator
     */
    'version': string;
    /**
     * the User id which own this Validator
     * @type {string}
     * @memberof Validator
     */
    'ownerId'?: string;
    /**
     * an optional URL link to Validator page
     * @type {string}
     * @memberof Validator
     */
    'url'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Validator
     */
    'tags'?: Array<string>;
}
/**
 * a Validator Run
 * @export
 * @interface ValidatorRun
 */
export interface ValidatorRun {
    /**
     * the Validator Run id
     * @type {string}
     * @memberof ValidatorRun
     */
    'id'?: string;
    /**
     * the Validator id
     * @type {string}
     * @memberof ValidatorRun
     */
    'validatorId'?: string;
    /**
     * the validator name
     * @type {string}
     * @memberof ValidatorRun
     */
    'validatorName'?: string;
    /**
     * the Dataset id to run the validator on
     * @type {string}
     * @memberof ValidatorRun
     */
    'datasetId': string;
    /**
     * the Dataset name
     * @type {string}
     * @memberof ValidatorRun
     */
    'datasetName'?: string;
    /**
     * the Validator Run state
     * @type {string}
     * @memberof ValidatorRun
     */
    'state'?: ValidatorRunStateEnum;
    /**
     * the Validator Run container id
     * @type {string}
     * @memberof ValidatorRun
     */
    'containerId'?: string;
    /**
     * the Validator Run logs
     * @type {string}
     * @memberof ValidatorRun
     */
    'logs'?: string;
}

export const ValidatorRunStateEnum = {
    Running: 'Running',
    Finished: 'Finished',
    OnError: 'OnError'
} as const;

export type ValidatorRunStateEnum = typeof ValidatorRunStateEnum[keyof typeof ValidatorRunStateEnum];

/**
 * a Workspace
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * the Workspace version unique identifier
     * @type {string}
     * @memberof Workspace
     */
    'id'?: string;
    /**
     * the Organization unique identifier
     * @type {string}
     * @memberof Workspace
     */
    'organizationId'?: string;
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof Workspace
     */
    'key': string;
    /**
     * the Workspace name
     * @type {string}
     * @memberof Workspace
     */
    'name': string;
    /**
     * the Workspace description
     * @type {string}
     * @memberof Workspace
     */
    'description'?: string;
    /**
     * the Workspace version MAJOR.MINOR.PATCH.
     * @type {string}
     * @memberof Workspace
     */
    'version'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Workspace
     */
    'tags'?: Array<string>;
    /**
     * the user id which own this workspace
     * @type {string}
     * @memberof Workspace
     */
    'ownerId'?: string;
    /**
     * 
     * @type {WorkspaceSolution}
     * @memberof Workspace
     */
    'solution': WorkspaceSolution;
    /**
     * 
     * @type {WorkspaceWebApp}
     * @memberof Workspace
     */
    'webApp'?: WorkspaceWebApp;
    /**
     * default setting for all Scenarios and Run Templates to set whether or not the Dataset values and the input parameters values are send to the DataWarehouse prior to the ScenarioRun
     * @type {boolean}
     * @memberof Workspace
     */
    'sendInputToDataWarehouse'?: boolean;
    /**
     * Set this property to true to use a dedicated Azure Event Hub Namespace for this Workspace. The Event Hub Namespace must be named \\\'<organization_id\\>-<workspace_id\\>\\\' (in lower case). This Namespace must also contain two Event Hubs named \\\'probesmeasures\\\' and \\\'scenariorun\\\'.
     * @type {boolean}
     * @memberof Workspace
     */
    'useDedicatedEventHubNamespace'?: boolean;
    /**
     * the Dedicated Event Hub SAS key name, default to RootManageSharedAccessKey. Use the /secret endpoint to set the key value
     * @type {string}
     * @memberof Workspace
     */
    'dedicatedEventHubSasKeyName'?: string;
    /**
     * the Event Hub authentication strategy, SHARED_ACCESS_POLICY or TENANT_CLIENT_CREDENTIALS. Default to the one defined for the tenant.
     * @type {string}
     * @memberof Workspace
     */
    'dedicatedEventHubAuthenticationStrategy'?: string;
    /**
     * default setting for all Scenarios and Run Templates to set whether or not the ScenarioRun is send to the Event Hub
     * @type {boolean}
     * @memberof Workspace
     */
    'sendScenarioRunToEventHub'?: boolean;
    /**
     * Set this property to false to not send scenario metada to Azure Event Hub Namespace for this Workspace. The Event Hub Namespace must be named \\\'<organization_id\\>-<workspace_id\\>\\\' (in lower case). This Namespace must also contain two Event Hubs named \\\'scenariometadata\\\' and \\\'scenariorunmetadata\\\'.
     * @type {boolean}
     * @memberof Workspace
     */
    'sendScenarioMetadataToEventHub'?: boolean;
    /**
     * 
     * @type {WorkspaceSecurity}
     * @memberof Workspace
     */
    'security'?: WorkspaceSecurity;
}
/**
 * a Workspace access control item
 * @export
 * @interface WorkspaceAccessControl
 */
export interface WorkspaceAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof WorkspaceAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof WorkspaceAccessControl
     */
    'role': string;
}
/**
 * a Workspace File resource
 * @export
 * @interface WorkspaceFile
 */
export interface WorkspaceFile {
    /**
     * the Workspace File name
     * @type {string}
     * @memberof WorkspaceFile
     */
    'fileName'?: string;
}
/**
 * the Workspace Role
 * @export
 * @interface WorkspaceRole
 */
export interface WorkspaceRole {
    /**
     * the Workspace Role
     * @type {string}
     * @memberof WorkspaceRole
     */
    'role': string;
}
/**
 * the secret definition
 * @export
 * @interface WorkspaceSecret
 */
export interface WorkspaceSecret {
    /**
     * the dedicated event hub shared access key
     * @type {string}
     * @memberof WorkspaceSecret
     */
    'dedicatedEventHubKey'?: string;
}
/**
 * the workspace security information
 * @export
 * @interface WorkspaceSecurity
 */
export interface WorkspaceSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof WorkspaceSecurity
     */
    'default': string;
    /**
     * the list which can access this Workspace with detailed access control information
     * @type {Array<WorkspaceAccessControl>}
     * @memberof WorkspaceSecurity
     */
    'accessControlList': Array<WorkspaceAccessControl>;
}
/**
 * the Workspace Solution configuration
 * @export
 * @interface WorkspaceSolution
 */
export interface WorkspaceSolution {
    /**
     * the Solution Id attached to this workspace
     * @type {string}
     * @memberof WorkspaceSolution
     */
    'solutionId'?: string;
    /**
     * the list of Solution Run Template Id to filter
     * @type {Array<string>}
     * @memberof WorkspaceSolution
     */
    'runTemplateFilter'?: Array<string>;
    /**
     * a map of RunTemplateId/DatasetId to set a default dataset for a Run Template
     * @type {{ [key: string]: object; }}
     * @memberof WorkspaceSolution
     */
    'defaultRunTemplateDataset'?: { [key: string]: object; };
}
/**
 * a Workspace Web Application
 * @export
 * @interface WorkspaceWebApp
 */
export interface WorkspaceWebApp {
    /**
     * the Workspace Web Application URL
     * @type {string}
     * @memberof WorkspaceWebApp
     */
    'url': string;
    /**
     * a map of iframeKey/iframeURL
     * @type {{ [key: string]: object; }}
     * @memberof WorkspaceWebApp
     */
    'iframes'?: { [key: string]: object; };
    /**
     * free form options for Web Application
     * @type {{ [key: string]: object; }}
     * @memberof WorkspaceWebApp
     */
    'options'?: { [key: string]: object; };
}

/**
 * ConnectorApi - axios parameter creator
 * @export
 */
export const ConnectorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllConnectors: async (page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findConnectorById: async (connectorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('findConnectorById', 'connectorId', connectorId)
            const localVarPath = `/connectors/{connector_id}`
                .replace(`{${"connector_id"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import existing connector
         * @param {Connector} connector the Connector to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importConnector: async (connector: Connector, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connector' is not null or undefined
            assertParamExists('importConnector', 'connector', connector)
            const localVarPath = `/connectors/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connector, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerConnector: async (connector: Connector, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connector' is not null or undefined
            assertParamExists('registerConnector', 'connector', connector)
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connector, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterConnector: async (connectorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('unregisterConnector', 'connectorId', connectorId)
            const localVarPath = `/connectors/{connector_id}`
                .replace(`{${"connector_id"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorApi - functional programming interface
 * @export
 */
export const ConnectorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllConnectors(page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Connector>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllConnectors(page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findConnectorById(connectorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findConnectorById(connectorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import existing connector
         * @param {Connector} connector the Connector to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importConnector(connector: Connector, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importConnector(connector, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerConnector(connector: Connector, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerConnector(connector, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unregisterConnector(connectorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unregisterConnector(connectorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectorApi - factory interface
 * @export
 */
export const ConnectorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllConnectors(page?: number, size?: number, options?: any): AxiosPromise<Array<Connector>> {
            return localVarFp.findAllConnectors(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findConnectorById(connectorId: string, options?: any): AxiosPromise<Connector> {
            return localVarFp.findConnectorById(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import existing connector
         * @param {Connector} connector the Connector to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importConnector(connector: Connector, options?: any): AxiosPromise<Connector> {
            return localVarFp.importConnector(connector, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerConnector(connector: Connector, options?: any): AxiosPromise<Connector> {
            return localVarFp.registerConnector(connector, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterConnector(connectorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unregisterConnector(connectorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorApi - object-oriented interface
 * @export
 * @class ConnectorApi
 * @extends {BaseAPI}
 */
export class ConnectorApi extends BaseAPI {
    /**
     * 
     * @summary List all Connectors
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public findAllConnectors(page?: number, size?: number, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).findAllConnectors(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a connector
     * @param {string} connectorId the Connector identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public findConnectorById(connectorId: string, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).findConnectorById(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import existing connector
     * @param {Connector} connector the Connector to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public importConnector(connector: Connector, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).importConnector(connector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new connector
     * @param {Connector} connector the Connector to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public registerConnector(connector: Connector, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).registerConnector(connector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unregister a connector
     * @param {string} connectorId the Connector identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public unregisterConnector(connectorId: string, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).unregisterConnector(connectorId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatasetApi - axios parameter creator
 * @export
 */
export const DatasetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceDatasetCompatibilityElements: async (organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'datasetId', datasetId)
            // verify required parameter 'datasetCompatibility' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'datasetCompatibility', datasetCompatibility)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/compatibility`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetCompatibility, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copy a Dataset to another Dataset. Source must have a read capable connector and Target a write capable connector.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyDataset: async (organizationId: string, datasetCopyParameters: DatasetCopyParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('copyDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetCopyParameters' is not null or undefined
            assertParamExists('copyDataset', 'datasetCopyParameters', datasetCopyParameters)
            const localVarPath = `/organizations/{organization_id}/datasets/copy`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetCopyParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset: async (organizationId: string, dataset: Dataset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createDataset', 'organizationId', organizationId)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('createDataset', 'dataset', dataset)
            const localVarPath = `/organizations/{organization_id}/datasets`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset: async (organizationId: string, datasetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteDataset', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDatasets: async (organizationId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllDatasets', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/datasets`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDatasetById: async (organizationId: string, datasetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findDatasetById', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('findDatasetById', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importDataset: async (organizationId: string, dataset: Dataset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('importDataset', 'organizationId', organizationId)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('importDataset', 'dataset', dataset)
            const localVarPath = `/organizations/{organization_id}/datasets/import`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllDatasetCompatibilityElements: async (organizationId: string, datasetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllDatasetCompatibilityElements', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('removeAllDatasetCompatibilityElements', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/compatibility`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Datasets
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDatasets: async (organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('searchDatasets', 'organizationId', organizationId)
            // verify required parameter 'datasetSearch' is not null or undefined
            assertParamExists('searchDatasets', 'datasetSearch', datasetSearch)
            const localVarPath = `/organizations/{organization_id}/datasets/search`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset: async (organizationId: string, datasetId: string, dataset: Dataset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateDataset', 'datasetId', datasetId)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('updateDataset', 'dataset', dataset)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetApi - functional programming interface
 * @export
 */
export const DatasetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DatasetCompatibility>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Copy a Dataset to another Dataset. Source must have a read capable connector and Target a write capable connector.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetCopyParameters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyDataset(organizationId, datasetCopyParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataset(organizationId: string, dataset: Dataset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataset(organizationId, dataset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataset(organizationId: string, datasetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataset(organizationId, datasetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllDatasets(organizationId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllDatasets(organizationId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDatasetById(organizationId: string, datasetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDatasetById(organizationId, datasetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importDataset(organizationId: string, dataset: Dataset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importDataset(organizationId, dataset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllDatasetCompatibilityElements(organizationId, datasetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search Datasets
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDatasets(organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDatasets(organizationId, datasetSearch, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataset(organizationId, datasetId, dataset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatasetApi - factory interface
 * @export
 */
export const DatasetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: any): AxiosPromise<Array<DatasetCompatibility>> {
            return localVarFp.addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Copy a Dataset to another Dataset. Source must have a read capable connector and Target a write capable connector.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: any): AxiosPromise<DatasetCopyParameters> {
            return localVarFp.copyDataset(organizationId, datasetCopyParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset(organizationId: string, dataset: Dataset, options?: any): AxiosPromise<Dataset> {
            return localVarFp.createDataset(organizationId, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset(organizationId: string, datasetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDataset(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDatasets(organizationId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<Dataset>> {
            return localVarFp.findAllDatasets(organizationId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDatasetById(organizationId: string, datasetId: string, options?: any): AxiosPromise<Dataset> {
            return localVarFp.findDatasetById(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importDataset(organizationId: string, dataset: Dataset, options?: any): AxiosPromise<Dataset> {
            return localVarFp.importDataset(organizationId, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllDatasetCompatibilityElements(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Datasets
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDatasets(organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options?: any): AxiosPromise<Array<Dataset>> {
            return localVarFp.searchDatasets(organizationId, datasetSearch, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: any): AxiosPromise<Dataset> {
            return localVarFp.updateDataset(organizationId, datasetId, dataset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetApi - object-oriented interface
 * @export
 * @class DatasetApi
 * @extends {BaseAPI}
 */
export class DatasetApi extends BaseAPI {
    /**
     * 
     * @summary Add Dataset Compatibility elements.
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Copy a Dataset to another Dataset. Source must have a read capable connector and Target a write capable connector.
     * @param {string} organizationId the Organization identifier
     * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).copyDataset(organizationId, datasetCopyParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Dataset
     * @param {string} organizationId the Organization identifier
     * @param {Dataset} dataset the Dataset to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createDataset(organizationId: string, dataset: Dataset, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createDataset(organizationId, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteDataset(organizationId: string, datasetId: string, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteDataset(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Datasets
     * @param {string} organizationId the Organization identifier
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public findAllDatasets(organizationId: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).findAllDatasets(organizationId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public findDatasetById(organizationId: string, datasetId: string, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).findDatasetById(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import a new Dataset
     * @param {string} organizationId the Organization identifier
     * @param {Dataset} dataset the Dataset to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public importDataset(organizationId: string, dataset: Dataset, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).importDataset(organizationId, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Dataset Compatibility elements from the Dataset specified
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).removeAllDatasetCompatibilityElements(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Datasets
     * @param {string} organizationId the Organization identifier
     * @param {DatasetSearch} datasetSearch the Dataset search parameters
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public searchDatasets(organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).searchDatasets(organizationId, datasetSearch, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {Dataset} dataset the new Dataset details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateDataset(organizationId, datasetId, dataset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationAccessControl: async (organizationId: string, organizationAccessControl: OrganizationAccessControl, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'organizationAccessControl' is not null or undefined
            assertParamExists('addOrganizationAccessControl', 'organizationAccessControl', organizationAccessControl)
            const localVarPath = `/organizations/{organization_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrganizations: async (page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganizationById: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findOrganizationById', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPermissions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAccessControl: async (organizationId: string, identityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getOrganizationAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationPermissions: async (organizationId: string, role: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationPermissions', 'organizationId', organizationId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getOrganizationPermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurity: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationSecurity', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurityUsers: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationSecurityUsers', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import an organization
         * @param {Organization} organization the Organization to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importOrganization: async (organization: Organization, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('importOrganization', 'organization', organization)
            const localVarPath = `/organizations/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new organization
         * @param {Organization} organization the Organization to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOrganization: async (organization: Organization, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('registerOrganization', 'organization', organization)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationAccessControl: async (organizationId: string, identityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeOrganizationAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Organization default security
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationRole} organizationRole the new Organization default security.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationDefaultSecurity: async (organizationId: string, organizationRole: OrganizationRole, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setOrganizationDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'organizationRole' is not null or undefined
            assertParamExists('setOrganizationDefaultSecurity', 'organizationRole', organizationRole)
            const localVarPath = `/organizations/{organization_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unregister an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterOrganization: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('unregisterOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {Organization} organization the new Organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (organizationId: string, organization: Organization, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganization', 'organizationId', organizationId)
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('updateOrganization', 'organization', organization)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationAccessControl: async (organizationId: string, identityId: string, organizationRole: OrganizationRole, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'identityId', identityId)
            // verify required parameter 'organizationRole' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'organizationRole', organizationRole)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the solutions container registry configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new solutions container registry configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionsContainerRegistryByOrganizationId: async (organizationId: string, organizationService: OrganizationService, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionsContainerRegistryByOrganizationId', 'organizationId', organizationId)
            // verify required parameter 'organizationService' is not null or undefined
            assertParamExists('updateSolutionsContainerRegistryByOrganizationId', 'organizationService', organizationService)
            const localVarPath = `/organizations/{organization_id}/services/solutionsContainerRegistry`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationService, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update storage configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new Storage configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorageByOrganizationId: async (organizationId: string, organizationService: OrganizationService, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateStorageByOrganizationId', 'organizationId', organizationId)
            // verify required parameter 'organizationService' is not null or undefined
            assertParamExists('updateStorageByOrganizationId', 'organizationService', organizationService)
            const localVarPath = `/organizations/{organization_id}/services/storage`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationService, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update tenant credentials for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {{ [key: string]: object; }} requestBody the new Tenant Credentials to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenantCredentialsByOrganizationId: async (organizationId: string, requestBody: { [key: string]: object; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateTenantCredentialsByOrganizationId', 'organizationId', organizationId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateTenantCredentialsByOrganizationId', 'requestBody', requestBody)
            const localVarPath = `/organizations/{organization_id}/services/tenantCredentials`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrganizationAccessControl(organizationId, organizationAccessControl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllOrganizations(page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllOrganizations(page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOrganizationById(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOrganizationById(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPermissions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ComponentRolePermissions>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPermissions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationAccessControl(organizationId: string, identityId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationAccessControl(organizationId, identityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationPermissions(organizationId: string, role: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationPermissions(organizationId, role, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationSecurity(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationSecurity(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationSecurityUsers(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationSecurityUsers(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import an organization
         * @param {Organization} organization the Organization to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importOrganization(organization: Organization, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importOrganization(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new organization
         * @param {Organization} organization the Organization to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerOrganization(organization: Organization, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerOrganization(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrganizationAccessControl(organizationId: string, identityId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOrganizationAccessControl(organizationId, identityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set the Organization default security
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationRole} organizationRole the new Organization default security.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOrganizationDefaultSecurity(organizationId, organizationRole, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unregister an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unregisterOrganization(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unregisterOrganization(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {Organization} organization the new Organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(organizationId: string, organization: Organization, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(organizationId, organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationAccessControl(organizationId, identityId, organizationRole, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the solutions container registry configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new solutions container registry configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionsContainerRegistryByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionsContainerRegistryByOrganizationId(organizationId, organizationService, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update storage configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new Storage configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStorageByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStorageByOrganizationId(organizationId, organizationService, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update tenant credentials for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {{ [key: string]: object; }} requestBody the new Tenant Credentials to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTenantCredentialsByOrganizationId(organizationId: string, requestBody: { [key: string]: object; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTenantCredentialsByOrganizationId(organizationId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: any): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.addOrganizationAccessControl(organizationId, organizationAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrganizations(page?: number, size?: number, options?: any): AxiosPromise<Array<Organization>> {
            return localVarFp.findAllOrganizations(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganizationById(organizationId: string, options?: any): AxiosPromise<Organization> {
            return localVarFp.findOrganizationById(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPermissions(options?: any): AxiosPromise<Array<ComponentRolePermissions>> {
            return localVarFp.getAllPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAccessControl(organizationId: string, identityId: string, options?: any): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.getOrganizationAccessControl(organizationId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationPermissions(organizationId: string, role: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getOrganizationPermissions(organizationId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurity(organizationId: string, options?: any): AxiosPromise<OrganizationSecurity> {
            return localVarFp.getOrganizationSecurity(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurityUsers(organizationId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getOrganizationSecurityUsers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import an organization
         * @param {Organization} organization the Organization to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importOrganization(organization: Organization, options?: any): AxiosPromise<Organization> {
            return localVarFp.importOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new organization
         * @param {Organization} organization the Organization to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOrganization(organization: Organization, options?: any): AxiosPromise<Organization> {
            return localVarFp.registerOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationAccessControl(organizationId: string, identityId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeOrganizationAccessControl(organizationId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Organization default security
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationRole} organizationRole the new Organization default security.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: any): AxiosPromise<OrganizationSecurity> {
            return localVarFp.setOrganizationDefaultSecurity(organizationId, organizationRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unregister an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterOrganization(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unregisterOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {Organization} organization the new Organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organizationId: string, organization: Organization, options?: any): AxiosPromise<Organization> {
            return localVarFp.updateOrganization(organizationId, organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: any): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.updateOrganizationAccessControl(organizationId, identityId, organizationRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the solutions container registry configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new solutions container registry configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionsContainerRegistryByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: any): AxiosPromise<OrganizationService> {
            return localVarFp.updateSolutionsContainerRegistryByOrganizationId(organizationId, organizationService, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update storage configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new Storage configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorageByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: any): AxiosPromise<OrganizationService> {
            return localVarFp.updateStorageByOrganizationId(organizationId, organizationService, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update tenant credentials for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {{ [key: string]: object; }} requestBody the new Tenant Credentials to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenantCredentialsByOrganizationId(organizationId: string, requestBody: { [key: string]: object; }, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.updateTenantCredentialsByOrganizationId(organizationId, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * 
     * @summary Add a control access to the Organization
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public addOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).addOrganizationAccessControl(organizationId, organizationAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Organizations
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public findAllOrganizations(page?: number, size?: number, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).findAllOrganizations(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an Organization
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public findOrganizationById(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).findOrganizationById(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all permissions per components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getAllPermissions(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getAllPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Organization
     * @param {string} organizationId the Organization identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationAccessControl(organizationId: string, identityId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationAccessControl(organizationId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization permissions by given role
     * @param {string} organizationId the Organization identifier
     * @param {string} role the Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationPermissions(organizationId: string, role: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationPermissions(organizationId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization security information
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationSecurity(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationSecurity(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization security users list
     * @param {string} organizationId The Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationSecurityUsers(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationSecurityUsers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import an organization
     * @param {Organization} organization the Organization to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public importOrganization(organization: Organization, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).importOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new organization
     * @param {Organization} organization the Organization to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public registerOrganization(organization: Organization, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).registerOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization
     * @param {string} organizationId the Organization identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public removeOrganizationAccessControl(organizationId: string, identityId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).removeOrganizationAccessControl(organizationId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Organization default security
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationRole} organizationRole the new Organization default security.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public setOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).setOrganizationDefaultSecurity(organizationId, organizationRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unregister an organization
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public unregisterOrganization(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).unregisterOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an Organization
     * @param {string} organizationId the Organization identifier
     * @param {Organization} organization the new Organization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganization(organizationId: string, organization: Organization, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganization(organizationId, organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for an Organization
     * @param {string} organizationId the Organization identifier
     * @param {string} identityId the User identifier
     * @param {OrganizationRole} organizationRole The new Organization Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganizationAccessControl(organizationId, identityId, organizationRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the solutions container registry configuration for the Organization specified
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationService} organizationService the new solutions container registry configuration to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateSolutionsContainerRegistryByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateSolutionsContainerRegistryByOrganizationId(organizationId, organizationService, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update storage configuration for the Organization specified
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationService} organizationService the new Storage configuration to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateStorageByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateStorageByOrganizationId(organizationId, organizationService, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update tenant credentials for the Organization specified
     * @param {string} organizationId the Organization identifier
     * @param {{ [key: string]: object; }} requestBody the new Tenant Credentials to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateTenantCredentialsByOrganizationId(organizationId: string, requestBody: { [key: string]: object; }, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateTenantCredentialsByOrganizationId(organizationId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScenarioApi - axios parameter creator
 * @export
 */
export const ScenarioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add (or replace) Parameter Values for the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Array<ScenarioRunTemplateParameterValue>} scenarioRunTemplateParameterValue the Parameter Value to add. Any Parameter Value with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceScenarioParameterValues: async (organizationId: string, workspaceId: string, scenarioId: string, scenarioRunTemplateParameterValue: Array<ScenarioRunTemplateParameterValue>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceScenarioParameterValues', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addOrReplaceScenarioParameterValues', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('addOrReplaceScenarioParameterValues', 'scenarioId', scenarioId)
            // verify required parameter 'scenarioRunTemplateParameterValue' is not null or undefined
            assertParamExists('addOrReplaceScenarioParameterValues', 'scenarioRunTemplateParameterValue', scenarioRunTemplateParameterValue)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/parameterValues`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioRunTemplateParameterValue, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a control access to the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioAccessControl} scenarioAccessControl the new Scenario security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScenarioAccessControl: async (organizationId: string, workspaceId: string, scenarioId: string, scenarioAccessControl: ScenarioAccessControl, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addScenarioAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addScenarioAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('addScenarioAccessControl', 'scenarioId', scenarioId)
            // verify required parameter 'scenarioAccessControl' is not null or undefined
            assertParamExists('addScenarioAccessControl', 'scenarioAccessControl', scenarioAccessControl)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Compare the Scenario with another one and returns the difference for parameters values
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} comparedScenarioId the Scenario identifier to compare to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareScenarios: async (organizationId: string, workspaceId: string, scenarioId: string, comparedScenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('compareScenarios', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('compareScenarios', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('compareScenarios', 'scenarioId', scenarioId)
            // verify required parameter 'comparedScenarioId' is not null or undefined
            assertParamExists('compareScenarios', 'comparedScenarioId', comparedScenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/compare/{compared_scenario_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"compared_scenario_id"}}`, encodeURIComponent(String(comparedScenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Scenario} scenario the Scenario to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenario: async (organizationId: string, workspaceId: string, scenario: Scenario, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenario' is not null or undefined
            assertParamExists('createScenario', 'scenario', scenario)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenario, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all Scenarios of the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllScenarios: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteAllScenarios', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteAllScenarios', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [waitRelationshipPropagation] whether to wait until child scenarios are effectively updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenario: async (organizationId: string, workspaceId: string, scenarioId: string, waitRelationshipPropagation?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deleteScenario', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (waitRelationshipPropagation !== undefined) {
                localVarQueryParameter['wait_relationship_propagation'] = waitRelationshipPropagation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Scenario data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadScenarioData: async (organizationId: string, workspaceId: string, scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadScenarioData', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('downloadScenarioData', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('downloadScenarioData', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/downloads`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Scenarios
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllScenarios: async (organizationId: string, workspaceId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllScenarios', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findAllScenarios', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Scenarios by validation status
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {ScenarioValidationStatus} validationStatus the Scenario Validation Status
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllScenariosByValidationStatus: async (organizationId: string, workspaceId: string, validationStatus: ScenarioValidationStatus, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllScenariosByValidationStatus', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findAllScenariosByValidationStatus', 'workspaceId', workspaceId)
            // verify required parameter 'validationStatus' is not null or undefined
            assertParamExists('findAllScenariosByValidationStatus', 'validationStatus', validationStatus)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/{validationStatus}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"validationStatus"}}`, encodeURIComponent(String(validationStatus)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findScenarioById: async (organizationId: string, workspaceId: string, scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findScenarioById', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findScenarioById', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('findScenarioById', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioAccessControl: async (organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioAccessControl', 'scenarioId', scenarioId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getScenarioAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Scenario data download URL
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} downloadId the Scenario Download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioDataDownloadJobInfo: async (organizationId: string, workspaceId: string, scenarioId: string, downloadId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioDataDownloadJobInfo', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioDataDownloadJobInfo', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioDataDownloadJobInfo', 'scenarioId', scenarioId)
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getScenarioDataDownloadJobInfo', 'downloadId', downloadId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/downloads/{download_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"download_id"}}`, encodeURIComponent(String(downloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Scenario permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioPermissions: async (organizationId: string, workspaceId: string, role: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioPermissions', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioPermissions', 'workspaceId', workspaceId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getScenarioPermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Scenario security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioSecurity: async (organizationId: string, workspaceId: string, scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioSecurity', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Scenario security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioSecurityUsers: async (organizationId: string, workspaceId: string, scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioSecurityUsers', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioSecurityUsers', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the validation status of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioValidationStatusById: async (organizationId: string, workspaceId: string, scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioValidationStatusById', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioValidationStatusById', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioValidationStatusById', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/ValidationStatus`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Scenarios Tree
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenariosTree: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenariosTree', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenariosTree', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/tree`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Scenario} scenario the Scenario to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importScenario: async (organizationId: string, workspaceId: string, scenario: Scenario, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('importScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('importScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenario' is not null or undefined
            assertParamExists('importScenario', 'scenario', scenario)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/import`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenario, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Parameter Values from the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllScenarioParameterValues: async (organizationId: string, workspaceId: string, scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllScenarioParameterValues', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeAllScenarioParameterValues', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('removeAllScenarioParameterValues', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/parameterValues`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeScenarioAccessControl: async (organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeScenarioAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeScenarioAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('removeScenarioAccessControl', 'scenarioId', scenarioId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeScenarioAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Scenario default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioRole} scenarioRole the new Scenario default security.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setScenarioDefaultSecurity: async (organizationId: string, workspaceId: string, scenarioId: string, scenarioRole: ScenarioRole, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setScenarioDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('setScenarioDefaultSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('setScenarioDefaultSecurity', 'scenarioId', scenarioId)
            // verify required parameter 'scenarioRole' is not null or undefined
            assertParamExists('setScenarioDefaultSecurity', 'scenarioRole', scenarioRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Scenario} scenario the new Scenario details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenario: async (organizationId: string, workspaceId: string, scenarioId: string, scenario: Scenario, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('updateScenario', 'scenarioId', scenarioId)
            // verify required parameter 'scenario' is not null or undefined
            assertParamExists('updateScenario', 'scenario', scenario)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenario, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {ScenarioRole} scenarioRole The new Scenario Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioAccessControl: async (organizationId: string, workspaceId: string, scenarioId: string, identityId: string, scenarioRole: ScenarioRole, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateScenarioAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateScenarioAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('updateScenarioAccessControl', 'scenarioId', scenarioId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateScenarioAccessControl', 'identityId', identityId)
            // verify required parameter 'scenarioRole' is not null or undefined
            assertParamExists('updateScenarioAccessControl', 'scenarioRole', scenarioRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScenarioApi - functional programming interface
 * @export
 */
export const ScenarioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScenarioApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add (or replace) Parameter Values for the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Array<ScenarioRunTemplateParameterValue>} scenarioRunTemplateParameterValue the Parameter Value to add. Any Parameter Value with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, scenarioRunTemplateParameterValue: Array<ScenarioRunTemplateParameterValue>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioRunTemplateParameterValue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceScenarioParameterValues(organizationId, workspaceId, scenarioId, scenarioRunTemplateParameterValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a control access to the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioAccessControl} scenarioAccessControl the new Scenario security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, scenarioAccessControl: ScenarioAccessControl, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addScenarioAccessControl(organizationId, workspaceId, scenarioId, scenarioAccessControl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Compare the Scenario with another one and returns the difference for parameters values
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} comparedScenarioId the Scenario identifier to compare to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compareScenarios(organizationId: string, workspaceId: string, scenarioId: string, comparedScenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioComparisonResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compareScenarios(organizationId, workspaceId, scenarioId, comparedScenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Scenario} scenario the Scenario to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScenario(organizationId: string, workspaceId: string, scenario: Scenario, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScenario(organizationId, workspaceId, scenario, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete all Scenarios of the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllScenarios(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllScenarios(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [waitRelationshipPropagation] whether to wait until child scenarios are effectively updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScenario(organizationId: string, workspaceId: string, scenarioId: string, waitRelationshipPropagation?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScenario(organizationId, workspaceId, scenarioId, waitRelationshipPropagation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download Scenario data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadScenarioData(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioDataDownloadJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadScenarioData(organizationId, workspaceId, scenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Scenarios
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllScenarios(organizationId: string, workspaceId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Scenario>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllScenarios(organizationId, workspaceId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Scenarios by validation status
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {ScenarioValidationStatus} validationStatus the Scenario Validation Status
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllScenariosByValidationStatus(organizationId: string, workspaceId: string, validationStatus: ScenarioValidationStatus, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Scenario>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllScenariosByValidationStatus(organizationId, workspaceId, validationStatus, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findScenarioById(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findScenarioById(organizationId, workspaceId, scenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a control access for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Scenario data download URL
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} downloadId the Scenario Download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioDataDownloadJobInfo(organizationId: string, workspaceId: string, scenarioId: string, downloadId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioDataDownloadInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioDataDownloadJobInfo(organizationId, workspaceId, scenarioId, downloadId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Scenario permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioPermissions(organizationId: string, workspaceId: string, role: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioPermissions(organizationId, workspaceId, role, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Scenario security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioSecurity(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioSecurity(organizationId, workspaceId, scenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Scenario security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioSecurityUsers(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioSecurityUsers(organizationId, workspaceId, scenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the validation status of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioValidationStatusById(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioValidationStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioValidationStatusById(organizationId, workspaceId, scenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Scenarios Tree
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenariosTree(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Scenario>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenariosTree(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Scenario} scenario the Scenario to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importScenario(organizationId: string, workspaceId: string, scenario: Scenario, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importScenario(organizationId, workspaceId, scenario, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all Parameter Values from the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllScenarioParameterValues(organizationId, workspaceId, scenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set the Scenario default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioRole} scenarioRole the new Scenario default security.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setScenarioDefaultSecurity(organizationId: string, workspaceId: string, scenarioId: string, scenarioRole: ScenarioRole, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setScenarioDefaultSecurity(organizationId, workspaceId, scenarioId, scenarioRole, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Scenario} scenario the new Scenario details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScenario(organizationId: string, workspaceId: string, scenarioId: string, scenario: Scenario, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScenario(organizationId, workspaceId, scenarioId, scenario, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the specified access to User for a Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {ScenarioRole} scenarioRole The new Scenario Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, scenarioRole: ScenarioRole, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, scenarioRole, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScenarioApi - factory interface
 * @export
 */
export const ScenarioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScenarioApiFp(configuration)
    return {
        /**
         * 
         * @summary Add (or replace) Parameter Values for the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Array<ScenarioRunTemplateParameterValue>} scenarioRunTemplateParameterValue the Parameter Value to add. Any Parameter Value with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, scenarioRunTemplateParameterValue: Array<ScenarioRunTemplateParameterValue>, options?: any): AxiosPromise<Array<ScenarioRunTemplateParameterValue>> {
            return localVarFp.addOrReplaceScenarioParameterValues(organizationId, workspaceId, scenarioId, scenarioRunTemplateParameterValue, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a control access to the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioAccessControl} scenarioAccessControl the new Scenario security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, scenarioAccessControl: ScenarioAccessControl, options?: any): AxiosPromise<ScenarioAccessControl> {
            return localVarFp.addScenarioAccessControl(organizationId, workspaceId, scenarioId, scenarioAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Compare the Scenario with another one and returns the difference for parameters values
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} comparedScenarioId the Scenario identifier to compare to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareScenarios(organizationId: string, workspaceId: string, scenarioId: string, comparedScenarioId: string, options?: any): AxiosPromise<ScenarioComparisonResult> {
            return localVarFp.compareScenarios(organizationId, workspaceId, scenarioId, comparedScenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Scenario} scenario the Scenario to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenario(organizationId: string, workspaceId: string, scenario: Scenario, options?: any): AxiosPromise<Scenario> {
            return localVarFp.createScenario(organizationId, workspaceId, scenario, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all Scenarios of the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllScenarios(organizationId: string, workspaceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllScenarios(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [waitRelationshipPropagation] whether to wait until child scenarios are effectively updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenario(organizationId: string, workspaceId: string, scenarioId: string, waitRelationshipPropagation?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteScenario(organizationId, workspaceId, scenarioId, waitRelationshipPropagation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Scenario data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadScenarioData(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<ScenarioDataDownloadJob> {
            return localVarFp.downloadScenarioData(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Scenarios
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllScenarios(organizationId: string, workspaceId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<Scenario>> {
            return localVarFp.findAllScenarios(organizationId, workspaceId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Scenarios by validation status
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {ScenarioValidationStatus} validationStatus the Scenario Validation Status
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllScenariosByValidationStatus(organizationId: string, workspaceId: string, validationStatus: ScenarioValidationStatus, page?: number, size?: number, options?: any): AxiosPromise<Array<Scenario>> {
            return localVarFp.findAllScenariosByValidationStatus(organizationId, workspaceId, validationStatus, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findScenarioById(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<Scenario> {
            return localVarFp.findScenarioById(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options?: any): AxiosPromise<ScenarioAccessControl> {
            return localVarFp.getScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Scenario data download URL
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} downloadId the Scenario Download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioDataDownloadJobInfo(organizationId: string, workspaceId: string, scenarioId: string, downloadId: string, options?: any): AxiosPromise<ScenarioDataDownloadInfo> {
            return localVarFp.getScenarioDataDownloadJobInfo(organizationId, workspaceId, scenarioId, downloadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Scenario permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioPermissions(organizationId: string, workspaceId: string, role: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getScenarioPermissions(organizationId, workspaceId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Scenario security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioSecurity(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<ScenarioSecurity> {
            return localVarFp.getScenarioSecurity(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Scenario security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioSecurityUsers(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getScenarioSecurityUsers(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the validation status of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioValidationStatusById(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<ScenarioValidationStatus> {
            return localVarFp.getScenarioValidationStatusById(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Scenarios Tree
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenariosTree(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Array<Scenario>> {
            return localVarFp.getScenariosTree(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Scenario} scenario the Scenario to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importScenario(organizationId: string, workspaceId: string, scenario: Scenario, options?: any): AxiosPromise<Scenario> {
            return localVarFp.importScenario(organizationId, workspaceId, scenario, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Parameter Values from the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllScenarioParameterValues(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Scenario default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioRole} scenarioRole the new Scenario default security.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setScenarioDefaultSecurity(organizationId: string, workspaceId: string, scenarioId: string, scenarioRole: ScenarioRole, options?: any): AxiosPromise<ScenarioSecurity> {
            return localVarFp.setScenarioDefaultSecurity(organizationId, workspaceId, scenarioId, scenarioRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Scenario} scenario the new Scenario details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenario(organizationId: string, workspaceId: string, scenarioId: string, scenario: Scenario, options?: any): AxiosPromise<Scenario> {
            return localVarFp.updateScenario(organizationId, workspaceId, scenarioId, scenario, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} identityId the User identifier
         * @param {ScenarioRole} scenarioRole The new Scenario Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, scenarioRole: ScenarioRole, options?: any): AxiosPromise<ScenarioAccessControl> {
            return localVarFp.updateScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, scenarioRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScenarioApi - object-oriented interface
 * @export
 * @class ScenarioApi
 * @extends {BaseAPI}
 */
export class ScenarioApi extends BaseAPI {
    /**
     * 
     * @summary Add (or replace) Parameter Values for the Scenario specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {Array<ScenarioRunTemplateParameterValue>} scenarioRunTemplateParameterValue the Parameter Value to add. Any Parameter Value with the same ID is overwritten
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public addOrReplaceScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, scenarioRunTemplateParameterValue: Array<ScenarioRunTemplateParameterValue>, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).addOrReplaceScenarioParameterValues(organizationId, workspaceId, scenarioId, scenarioRunTemplateParameterValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a control access to the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {ScenarioAccessControl} scenarioAccessControl the new Scenario security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public addScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, scenarioAccessControl: ScenarioAccessControl, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).addScenarioAccessControl(organizationId, workspaceId, scenarioId, scenarioAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Compare the Scenario with another one and returns the difference for parameters values
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {string} comparedScenarioId the Scenario identifier to compare to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public compareScenarios(organizationId: string, workspaceId: string, scenarioId: string, comparedScenarioId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).compareScenarios(organizationId, workspaceId, scenarioId, comparedScenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {Scenario} scenario the Scenario to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public createScenario(organizationId: string, workspaceId: string, scenario: Scenario, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).createScenario(organizationId, workspaceId, scenario, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all Scenarios of the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public deleteAllScenarios(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).deleteAllScenarios(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {boolean} [waitRelationshipPropagation] whether to wait until child scenarios are effectively updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public deleteScenario(organizationId: string, workspaceId: string, scenarioId: string, waitRelationshipPropagation?: boolean, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).deleteScenario(organizationId, workspaceId, scenarioId, waitRelationshipPropagation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Scenario data
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public downloadScenarioData(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).downloadScenarioData(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Scenarios
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public findAllScenarios(organizationId: string, workspaceId: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).findAllScenarios(organizationId, workspaceId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Scenarios by validation status
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {ScenarioValidationStatus} validationStatus the Scenario Validation Status
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public findAllScenariosByValidationStatus(organizationId: string, workspaceId: string, validationStatus: ScenarioValidationStatus, page?: number, size?: number, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).findAllScenariosByValidationStatus(organizationId, workspaceId, validationStatus, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public findScenarioById(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).findScenarioById(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Scenario data download URL
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {string} downloadId the Scenario Download identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenarioDataDownloadJobInfo(organizationId: string, workspaceId: string, scenarioId: string, downloadId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenarioDataDownloadJobInfo(organizationId, workspaceId, scenarioId, downloadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Scenario permission by given role
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} role the Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenarioPermissions(organizationId: string, workspaceId: string, role: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenarioPermissions(organizationId, workspaceId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Scenario security information
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenarioSecurity(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenarioSecurity(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Scenario security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenarioSecurityUsers(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenarioSecurityUsers(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the validation status of an scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenarioValidationStatusById(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenarioValidationStatusById(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Scenarios Tree
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenariosTree(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenariosTree(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {Scenario} scenario the Scenario to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public importScenario(organizationId: string, workspaceId: string, scenario: Scenario, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).importScenario(organizationId, workspaceId, scenario, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Parameter Values from the Scenario specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public removeAllScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).removeAllScenarioParameterValues(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public removeScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).removeScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Scenario default security
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {ScenarioRole} scenarioRole the new Scenario default security.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public setScenarioDefaultSecurity(organizationId: string, workspaceId: string, scenarioId: string, scenarioRole: ScenarioRole, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).setScenarioDefaultSecurity(organizationId, workspaceId, scenarioId, scenarioRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {Scenario} scenario the new Scenario details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public updateScenario(organizationId: string, workspaceId: string, scenarioId: string, scenario: Scenario, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).updateScenario(organizationId, workspaceId, scenarioId, scenario, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {string} identityId the User identifier
     * @param {ScenarioRole} scenarioRole The new Scenario Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public updateScenarioAccessControl(organizationId: string, workspaceId: string, scenarioId: string, identityId: string, scenarioRole: ScenarioRole, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).updateScenarioAccessControl(organizationId, workspaceId, scenarioId, identityId, scenarioRole, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScenariorunApi - axios parameter creator
 * @export
 */
export const ScenariorunApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Organization
         * @param {string} organizationId the Organization identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHistoricalDataOrganization: async (organizationId: string, deleteUnknown?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteHistoricalDataOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/historicaldata`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (deleteUnknown !== undefined) {
                localVarQueryParameter['deleteUnknown'] = deleteUnknown;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHistoricalDataScenario: async (organizationId: string, workspaceId: string, scenarioId: string, deleteUnknown?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteHistoricalDataScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteHistoricalDataScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deleteHistoricalDataScenario', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/scenarioruns/historicaldata`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (deleteUnknown !== undefined) {
                localVarQueryParameter['deleteUnknown'] = deleteUnknown;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHistoricalDataWorkspace: async (organizationId: string, workspaceId: string, deleteUnknown?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteHistoricalDataWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteHistoricalDataWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarioruns/historicaldata`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (deleteUnknown !== undefined) {
                localVarQueryParameter['deleteUnknown'] = deleteUnknown;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioRun: async (organizationId: string, scenariorunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteScenarioRun', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('deleteScenarioRun', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findScenarioRunById: async (organizationId: string, scenariorunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findScenarioRunById', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('findScenarioRunById', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the cumulated logs of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRunCumulatedLogs: async (organizationId: string, scenariorunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioRunCumulatedLogs', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('getScenarioRunCumulatedLogs', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}/cumulatedlogs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the logs for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRunLogs: async (organizationId: string, scenariorunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioRunLogs', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('getScenarioRunLogs', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}/logs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the status for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRunStatus: async (organizationId: string, scenariorunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioRunStatus', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('getScenarioRunStatus', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}/status`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRuns: async (organizationId: string, workspaceId: string, scenarioId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioRuns', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioRuns', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioRuns', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/scenarioruns`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceScenarioRuns: async (organizationId: string, workspaceId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceScenarioRuns', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceScenarioRuns', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarioruns`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary import a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioRun} scenarioRun the ScenarioRun to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importScenarioRun: async (organizationId: string, workspaceId: string, scenarioId: string, scenarioRun: ScenarioRun, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('importScenarioRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('importScenarioRun', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('importScenarioRun', 'scenarioId', scenarioId)
            // verify required parameter 'scenarioRun' is not null or undefined
            assertParamExists('importScenarioRun', 'scenarioRun', scenarioRun)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/run/import`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioRun, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary run a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runScenario: async (organizationId: string, workspaceId: string, scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('runScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('runScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('runScenario', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/run`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search ScenarioRuns
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunSearch} scenarioRunSearch the ScenarioRun search parameters
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenarioRuns: async (organizationId: string, scenarioRunSearch: ScenarioRunSearch, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('searchScenarioRuns', 'organizationId', organizationId)
            // verify required parameter 'scenarioRunSearch' is not null or undefined
            assertParamExists('searchScenarioRuns', 'scenarioRunSearch', scenarioRunSearch)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/search`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioRunSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a new scenariorun with raw containers definition
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunStartContainers} scenarioRunStartContainers the raw containers definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startScenarioRunContainers: async (organizationId: string, scenarioRunStartContainers: ScenarioRunStartContainers, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('startScenarioRunContainers', 'organizationId', organizationId)
            // verify required parameter 'scenarioRunStartContainers' is not null or undefined
            assertParamExists('startScenarioRunContainers', 'scenarioRunStartContainers', scenarioRunStartContainers)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/startcontainers`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioRunStartContainers, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary stop a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the scenariorun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopScenarioRun: async (organizationId: string, scenariorunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('stopScenarioRun', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('stopScenarioRun', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}/stop`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScenariorunApi - functional programming interface
 * @export
 */
export const ScenariorunApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScenariorunApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Organization
         * @param {string} organizationId the Organization identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHistoricalDataOrganization(organizationId: string, deleteUnknown?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHistoricalDataOrganization(organizationId, deleteUnknown, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHistoricalDataScenario(organizationId: string, workspaceId: string, scenarioId: string, deleteUnknown?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHistoricalDataScenario(organizationId, workspaceId, scenarioId, deleteUnknown, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHistoricalDataWorkspace(organizationId: string, workspaceId: string, deleteUnknown?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHistoricalDataWorkspace(organizationId, workspaceId, deleteUnknown, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScenarioRun(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScenarioRun(organizationId, scenariorunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findScenarioRunById(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findScenarioRunById(organizationId, scenariorunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the cumulated logs of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioRunCumulatedLogs(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioRunCumulatedLogs(organizationId, scenariorunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get the logs for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioRunLogs(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRunLogs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioRunLogs(organizationId, scenariorunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get the status for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioRunStatus(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRunStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioRunStatus(organizationId, scenariorunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioRuns(organizationId: string, workspaceId: string, scenarioId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioRuns(organizationId, workspaceId, scenarioId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceScenarioRuns(organizationId: string, workspaceId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceScenarioRuns(organizationId, workspaceId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary import a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioRun} scenarioRun the ScenarioRun to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importScenarioRun(organizationId: string, workspaceId: string, scenarioId: string, scenarioRun: ScenarioRun, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importScenarioRun(organizationId, workspaceId, scenarioId, scenarioRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary run a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runScenario(organizationId, workspaceId, scenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search ScenarioRuns
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunSearch} scenarioRunSearch the ScenarioRun search parameters
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchScenarioRuns(organizationId: string, scenarioRunSearch: ScenarioRunSearch, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchScenarioRuns(organizationId, scenarioRunSearch, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start a new scenariorun with raw containers definition
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunStartContainers} scenarioRunStartContainers the raw containers definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startScenarioRunContainers(organizationId: string, scenarioRunStartContainers: ScenarioRunStartContainers, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startScenarioRunContainers(organizationId, scenarioRunStartContainers, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary stop a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the scenariorun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopScenarioRun(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRunStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopScenarioRun(organizationId, scenariorunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScenariorunApi - factory interface
 * @export
 */
export const ScenariorunApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScenariorunApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Organization
         * @param {string} organizationId the Organization identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHistoricalDataOrganization(organizationId: string, deleteUnknown?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHistoricalDataOrganization(organizationId, deleteUnknown, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHistoricalDataScenario(organizationId: string, workspaceId: string, scenarioId: string, deleteUnknown?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHistoricalDataScenario(organizationId, workspaceId, scenarioId, deleteUnknown, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHistoricalDataWorkspace(organizationId: string, workspaceId: string, deleteUnknown?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHistoricalDataWorkspace(organizationId, workspaceId, deleteUnknown, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioRun(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteScenarioRun(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findScenarioRunById(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<ScenarioRun> {
            return localVarFp.findScenarioRunById(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the cumulated logs of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRunCumulatedLogs(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getScenarioRunCumulatedLogs(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the logs for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRunLogs(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<ScenarioRunLogs> {
            return localVarFp.getScenarioRunLogs(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the status for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRunStatus(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<ScenarioRunStatus> {
            return localVarFp.getScenarioRunStatus(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRuns(organizationId: string, workspaceId: string, scenarioId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<ScenarioRun>> {
            return localVarFp.getScenarioRuns(organizationId, workspaceId, scenarioId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceScenarioRuns(organizationId: string, workspaceId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<ScenarioRun>> {
            return localVarFp.getWorkspaceScenarioRuns(organizationId, workspaceId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary import a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {ScenarioRun} scenarioRun the ScenarioRun to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importScenarioRun(organizationId: string, workspaceId: string, scenarioId: string, scenarioRun: ScenarioRun, options?: any): AxiosPromise<ScenarioRun> {
            return localVarFp.importScenarioRun(organizationId, workspaceId, scenarioId, scenarioRun, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary run a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<ScenarioRun> {
            return localVarFp.runScenario(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search ScenarioRuns
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunSearch} scenarioRunSearch the ScenarioRun search parameters
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenarioRuns(organizationId: string, scenarioRunSearch: ScenarioRunSearch, page?: number, size?: number, options?: any): AxiosPromise<Array<ScenarioRun>> {
            return localVarFp.searchScenarioRuns(organizationId, scenarioRunSearch, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a new scenariorun with raw containers definition
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunStartContainers} scenarioRunStartContainers the raw containers definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startScenarioRunContainers(organizationId: string, scenarioRunStartContainers: ScenarioRunStartContainers, options?: any): AxiosPromise<ScenarioRun> {
            return localVarFp.startScenarioRunContainers(organizationId, scenarioRunStartContainers, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary stop a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the scenariorun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopScenarioRun(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<ScenarioRunStatus> {
            return localVarFp.stopScenarioRun(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScenariorunApi - object-oriented interface
 * @export
 * @class ScenariorunApi
 * @extends {BaseAPI}
 */
export class ScenariorunApi extends BaseAPI {
    /**
     * 
     * @summary Delete all historical ScenarioRuns in the Organization
     * @param {string} organizationId the Organization identifier
     * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public deleteHistoricalDataOrganization(organizationId: string, deleteUnknown?: boolean, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).deleteHistoricalDataOrganization(organizationId, deleteUnknown, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all historical ScenarioRuns in the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public deleteHistoricalDataScenario(organizationId: string, workspaceId: string, scenarioId: string, deleteUnknown?: boolean, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).deleteHistoricalDataScenario(organizationId, workspaceId, scenarioId, deleteUnknown, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all historical ScenarioRuns in the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public deleteHistoricalDataWorkspace(organizationId: string, workspaceId: string, deleteUnknown?: boolean, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).deleteHistoricalDataWorkspace(organizationId, workspaceId, deleteUnknown, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scenariorun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public deleteScenarioRun(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).deleteScenarioRun(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a scenariorun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public findScenarioRunById(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).findScenarioRunById(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the cumulated logs of a scenariorun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getScenarioRunCumulatedLogs(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getScenarioRunCumulatedLogs(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the logs for the ScenarioRun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getScenarioRunLogs(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getScenarioRunLogs(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the status for the ScenarioRun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getScenarioRunStatus(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getScenarioRunStatus(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the list of ScenarioRuns for the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getScenarioRuns(organizationId: string, workspaceId: string, scenarioId: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getScenarioRuns(organizationId, workspaceId, scenarioId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the list of ScenarioRuns for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getWorkspaceScenarioRuns(organizationId: string, workspaceId: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getWorkspaceScenarioRuns(organizationId, workspaceId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary import a ScenarioRun for the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {ScenarioRun} scenarioRun the ScenarioRun to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public importScenarioRun(organizationId: string, workspaceId: string, scenarioId: string, scenarioRun: ScenarioRun, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).importScenarioRun(organizationId, workspaceId, scenarioId, scenarioRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary run a ScenarioRun for the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public runScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).runScenario(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search ScenarioRuns
     * @param {string} organizationId the Organization identifier
     * @param {ScenarioRunSearch} scenarioRunSearch the ScenarioRun search parameters
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public searchScenarioRuns(organizationId: string, scenarioRunSearch: ScenarioRunSearch, page?: number, size?: number, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).searchScenarioRuns(organizationId, scenarioRunSearch, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a new scenariorun with raw containers definition
     * @param {string} organizationId the Organization identifier
     * @param {ScenarioRunStartContainers} scenarioRunStartContainers the raw containers definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public startScenarioRunContainers(organizationId: string, scenarioRunStartContainers: ScenarioRunStartContainers, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).startScenarioRunContainers(organizationId, scenarioRunStartContainers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary stop a ScenarioRun for the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the scenariorun identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public stopScenarioRun(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).stopScenarioRun(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SolutionApi - axios parameter creator
 * @export
 */
export const SolutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Parameter Groups. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameterGroups: async (organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceParameterGroups', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('addOrReplaceParameterGroups', 'solutionId', solutionId)
            // verify required parameter 'runTemplateParameterGroup' is not null or undefined
            assertParamExists('addOrReplaceParameterGroups', 'runTemplateParameterGroup', runTemplateParameterGroup)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateParameterGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Parameters. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameters: async (organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceParameters', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('addOrReplaceParameters', 'solutionId', solutionId)
            // verify required parameter 'runTemplateParameter' is not null or undefined
            assertParamExists('addOrReplaceParameters', 'runTemplateParameter', runTemplateParameter)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Run Templates. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceRunTemplates: async (organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceRunTemplates', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('addOrReplaceRunTemplates', 'solutionId', solutionId)
            // verify required parameter 'runTemplate' is not null or undefined
            assertParamExists('addOrReplaceRunTemplates', 'runTemplate', runTemplate)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolution: async (organizationId: string, solution: Solution, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSolution', 'organizationId', organizationId)
            // verify required parameter 'solution' is not null or undefined
            assertParamExists('createSolution', 'solution', solution)
            const localVarPath = `/organizations/{organization_id}/solutions`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolution: async (organizationId: string, solutionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolution', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionRunTemplate: async (organizationId: string, solutionId: string, runTemplateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'runTemplateId', runTemplateId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates/{run_template_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRunTemplateHandler: async (organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadRunTemplateHandler', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('downloadRunTemplateHandler', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('downloadRunTemplateHandler', 'runTemplateId', runTemplateId)
            // verify required parameter 'handlerId' is not null or undefined
            assertParamExists('downloadRunTemplateHandler', 'handlerId', handlerId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runtemplates/{run_template_id}/handlers/{handler_id}/download`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)))
                .replace(`{${"handler_id"}}`, encodeURIComponent(String(handlerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllSolutions: async (organizationId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllSolutions', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/solutions`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSolutionById: async (organizationId: string, solutionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findSolutionById', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('findSolutionById', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import a solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSolution: async (organizationId: string, solution: Solution, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('importSolution', 'organizationId', organizationId)
            // verify required parameter 'solution' is not null or undefined
            assertParamExists('importSolution', 'solution', solution)
            const localVarPath = `/organizations/{organization_id}/solutions/import`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Run Templates from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllRunTemplates: async (organizationId: string, solutionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllRunTemplates', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('removeAllRunTemplates', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Parameter Groups from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameterGroups: async (organizationId: string, solutionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllSolutionParameterGroups', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('removeAllSolutionParameterGroups', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Parameters from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameters: async (organizationId: string, solutionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllSolutionParameters', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('removeAllSolutionParameters', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Solution} solution the new Solution details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolution: async (organizationId: string, solutionId: string, solution: Solution, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolution', 'solutionId', solutionId)
            // verify required parameter 'solution' is not null or undefined
            assertParamExists('updateSolution', 'solution', solution)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionRunTemplate: async (organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'runTemplateId', runTemplateId)
            // verify required parameter 'runTemplate' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'runTemplate', runTemplate)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates/{run_template_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {any} body 
         * @param {boolean} [overwrite] whether to overwrite any existing handler resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunTemplateHandler: async (organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, body: any, overwrite?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'runTemplateId', runTemplateId)
            // verify required parameter 'handlerId' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'handlerId', handlerId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'body', body)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runtemplates/{run_template_id}/handlers/{handler_id}/upload`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)))
                .replace(`{${"handler_id"}}`, encodeURIComponent(String(handlerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SolutionApi - functional programming interface
 * @export
 */
export const SolutionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SolutionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Parameter Groups. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplateParameterGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add Parameters. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplateParameter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceParameters(organizationId, solutionId, runTemplateParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add Run Templates. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceRunTemplates(organizationId, solutionId, runTemplate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSolution(organizationId: string, solution: Solution, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSolution(organizationId, solution, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolution(organizationId: string, solutionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolution(organizationId, solutionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllSolutions(organizationId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Solution>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllSolutions(organizationId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSolutionById(organizationId: string, solutionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSolutionById(organizationId, solutionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import a solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importSolution(organizationId: string, solution: Solution, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importSolution(organizationId, solution, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all Run Templates from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllRunTemplates(organizationId: string, solutionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllRunTemplates(organizationId, solutionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all Parameter Groups from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllSolutionParameterGroups(organizationId: string, solutionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllSolutionParameterGroups(organizationId, solutionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all Parameters from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllSolutionParameters(organizationId: string, solutionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllSolutionParameters(organizationId, solutionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Solution} solution the new Solution details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolution(organizationId: string, solutionId: string, solution: Solution, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolution(organizationId, solutionId, solution, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {any} body 
         * @param {boolean} [overwrite] whether to overwrite any existing handler resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, body: any, overwrite?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, body, overwrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SolutionApi - factory interface
 * @export
 */
export const SolutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SolutionApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Parameter Groups. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: any): AxiosPromise<Array<RunTemplateParameterGroup>> {
            return localVarFp.addOrReplaceParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Parameters. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: any): AxiosPromise<Array<RunTemplateParameter>> {
            return localVarFp.addOrReplaceParameters(organizationId, solutionId, runTemplateParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Run Templates. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: any): AxiosPromise<Array<RunTemplate>> {
            return localVarFp.addOrReplaceRunTemplates(organizationId, solutionId, runTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolution(organizationId: string, solution: Solution, options?: any): AxiosPromise<Solution> {
            return localVarFp.createSolution(organizationId, solution, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolution(organizationId: string, solutionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSolution(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, options?: any): AxiosPromise<any> {
            return localVarFp.downloadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllSolutions(organizationId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<Solution>> {
            return localVarFp.findAllSolutions(organizationId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSolutionById(organizationId: string, solutionId: string, options?: any): AxiosPromise<Solution> {
            return localVarFp.findSolutionById(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import a solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSolution(organizationId: string, solution: Solution, options?: any): AxiosPromise<Solution> {
            return localVarFp.importSolution(organizationId, solution, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Run Templates from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllRunTemplates(organizationId: string, solutionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllRunTemplates(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Parameter Groups from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameterGroups(organizationId: string, solutionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllSolutionParameterGroups(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Parameters from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameters(organizationId: string, solutionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllSolutionParameters(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Solution} solution the new Solution details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolution(organizationId: string, solutionId: string, solution: Solution, options?: any): AxiosPromise<Solution> {
            return localVarFp.updateSolution(organizationId, solutionId, solution, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: any): AxiosPromise<Array<RunTemplate>> {
            return localVarFp.updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {any} body 
         * @param {boolean} [overwrite] whether to overwrite any existing handler resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, body: any, overwrite?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.uploadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, body, overwrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SolutionApi - object-oriented interface
 * @export
 * @class SolutionApi
 * @extends {BaseAPI}
 */
export class SolutionApi extends BaseAPI {
    /**
     * 
     * @summary Add Parameter Groups. Any item with the same ID will be overwritten
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public addOrReplaceParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).addOrReplaceParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Parameters. Any item with the same ID will be overwritten
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public addOrReplaceParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).addOrReplaceParameters(organizationId, solutionId, runTemplateParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Run Templates. Any item with the same ID will be overwritten
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplate>} runTemplate the Run Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public addOrReplaceRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).addOrReplaceRunTemplates(organizationId, solutionId, runTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new solution
     * @param {string} organizationId the Organization identifier
     * @param {Solution} solution the Solution to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public createSolution(organizationId: string, solution: Solution, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).createSolution(organizationId, solution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolution(organizationId: string, solutionId: string, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolution(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified Solution Run Template
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a Run Template step handler zip file
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {RunTemplateHandlerId} handlerId the Handler identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public downloadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).downloadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Solutions
     * @param {string} organizationId the Organization identifier
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public findAllSolutions(organizationId: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).findAllSolutions(organizationId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public findSolutionById(organizationId: string, solutionId: string, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).findSolutionById(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import a solution
     * @param {string} organizationId the Organization identifier
     * @param {Solution} solution the Solution to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public importSolution(organizationId: string, solution: Solution, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).importSolution(organizationId, solution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Run Templates from the Solution specified
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public removeAllRunTemplates(organizationId: string, solutionId: string, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).removeAllRunTemplates(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Parameter Groups from the Solution specified
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public removeAllSolutionParameterGroups(organizationId: string, solutionId: string, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).removeAllSolutionParameterGroups(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Parameters from the Solution specified
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public removeAllSolutionParameters(organizationId: string, solutionId: string, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).removeAllSolutionParameters(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Solution} solution the new Solution details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolution(organizationId: string, solutionId: string, solution: Solution, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolution(organizationId, solutionId, solution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified Solution Run Template
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {RunTemplate} runTemplate the Run Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a Run Template step handler zip file
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {RunTemplateHandlerId} handlerId the Handler identifier
     * @param {any} body 
     * @param {boolean} [overwrite] whether to overwrite any existing handler resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public uploadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, body: any, overwrite?: boolean, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).uploadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, body, overwrite, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TwingraphApi - axios parameter creator
 * @export
 */
export const TwingraphApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Launch a mass delete job
         * @summary Launch a mass delete job
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (organizationId: string, graphId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('_delete', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('_delete', 'graphId', graphId)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchQuery: async (organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('batchQuery', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('batchQuery', 'graphId', graphId)
            // verify required parameter 'twinGraphQuery' is not null or undefined
            assertParamExists('batchQuery', 'twinGraphQuery', twinGraphQuery)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/batch-query`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twinGraphQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Async batch update by loading a CSV file on a graph instance 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchUploadUpdate: async (organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, body: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('batchUploadUpdate', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('batchUploadUpdate', 'graphId', graphId)
            // verify required parameter 'twinGraphQuery' is not null or undefined
            assertParamExists('batchUploadUpdate', 'twinGraphQuery', twinGraphQuery)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('batchUploadUpdate', 'body', body)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/batch`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (twinGraphQuery !== undefined) {
                localVarQueryParameter['twinGraphQuery'] = twinGraphQuery;
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/csv';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create new entities in a graph instance
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {'node' | 'relationship'} modelType the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntities: async (organizationId: string, graphId: string, modelType: 'node' | 'relationship', graphProperties: Array<GraphProperties>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createEntities', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('createEntities', 'graphId', graphId)
            // verify required parameter 'modelType' is not null or undefined
            assertParamExists('createEntities', 'modelType', modelType)
            // verify required parameter 'graphProperties' is not null or undefined
            assertParamExists('createEntities', 'graphProperties', graphProperties)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/{modelType}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"modelType"}}`, encodeURIComponent(String(modelType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(graphProperties, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new graph
         * @summary Create a new graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGraph: async (organizationId: string, graphId: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createGraph', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('createGraph', 'graphId', graphId)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete entities in a graph instance
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {'node' | 'relationship'} modelType the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntities: async (organizationId: string, graphId: string, modelType: 'node' | 'relationship', ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteEntities', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('deleteEntities', 'graphId', graphId)
            // verify required parameter 'modelType' is not null or undefined
            assertParamExists('deleteEntities', 'modelType', modelType)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteEntities', 'ids', ids)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/{modelType}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"modelType"}}`, encodeURIComponent(String(modelType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a graph compressed in a zip file
         * @summary Download a graph compressed in a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadGraph: async (organizationId: string, hash: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadGraph', 'organizationId', organizationId)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('downloadGraph', 'hash', hash)
            const localVarPath = `/organizations/{organization_id}/twingraph/bulk-query/download/{hash}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the list of all graphs stored in the organization
         * @summary Return the list of all graphs stored in the organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTwingraphs: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllTwingraphs', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/twingraphs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get entities in a graph instance
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {'node' | 'relationship'} modelType the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntities: async (organizationId: string, graphId: string, modelType: 'node' | 'relationship', ids: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getEntities', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getEntities', 'graphId', graphId)
            // verify required parameter 'modelType' is not null or undefined
            assertParamExists('getEntities', 'modelType', modelType)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getEntities', 'ids', ids)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/{modelType}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"modelType"}}`, encodeURIComponent(String(modelType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the metaData of the specified graph
         * @summary Return the metaData of the specified graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphMetaData: async (organizationId: string, graphId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getGraphMetaData', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('getGraphMetaData', 'graphId', graphId)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/metadata`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import a new version of a twin graph
         * @summary Import a new version of a twin graph
         * @param {string} organizationId the Organization identifier
         * @param {TwinGraphImport} twinGraphImport the graph to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGraph: async (organizationId: string, twinGraphImport: TwinGraphImport, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('importGraph', 'organizationId', organizationId)
            // verify required parameter 'twinGraphImport' is not null or undefined
            assertParamExists('importGraph', 'twinGraphImport', twinGraphImport)
            const localVarPath = `/organizations/{organization_id}/twingraph/import`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twinGraphImport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of a job
         * @summary Get the status of a job
         * @param {string} organizationId the Organization identifier
         * @param {string} jobId the job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobStatus: async (organizationId: string, jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('jobStatus', 'organizationId', organizationId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('jobStatus', 'jobId', jobId)
            const localVarPath = `/organizations/{organization_id}/job/{job_id}/status`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a query on a graph instance
         * @summary Run a query on a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query: async (organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('query', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('query', 'graphId', graphId)
            // verify required parameter 'twinGraphQuery' is not null or undefined
            assertParamExists('query', 'twinGraphQuery', twinGraphQuery)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/query`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twinGraphQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {'node' | 'relationship'} modelType the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntities: async (organizationId: string, graphId: string, modelType: 'node' | 'relationship', graphProperties: Array<GraphProperties>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateEntities', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('updateEntities', 'graphId', graphId)
            // verify required parameter 'modelType' is not null or undefined
            assertParamExists('updateEntities', 'modelType', modelType)
            // verify required parameter 'graphProperties' is not null or undefined
            assertParamExists('updateEntities', 'graphProperties', graphProperties)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/{modelType}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)))
                .replace(`{${"modelType"}}`, encodeURIComponent(String(modelType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(graphProperties, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the metaData of the specified graph
         * @summary Update the metaData of the specified graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {{ [key: string]: string; }} requestBody the metaData to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGraphMetaData: async (organizationId: string, graphId: string, requestBody: { [key: string]: string; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateGraphMetaData', 'organizationId', organizationId)
            // verify required parameter 'graphId' is not null or undefined
            assertParamExists('updateGraphMetaData', 'graphId', graphId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateGraphMetaData', 'requestBody', requestBody)
            const localVarPath = `/organizations/{organization_id}/twingraph/{graph_id}/metadata`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"graph_id"}}`, encodeURIComponent(String(graphId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TwingraphApi - functional programming interface
 * @export
 */
export const TwingraphApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TwingraphApiAxiosParamCreator(configuration)
    return {
        /**
         * Launch a mass delete job
         * @summary Launch a mass delete job
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(organizationId: string, graphId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(organizationId, graphId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchQuery(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwinGraphHash>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchQuery(organizationId, graphId, twinGraphQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Async batch update by loading a CSV file on a graph instance 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchUploadUpdate(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, body: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwinGraphBatchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchUploadUpdate(organizationId, graphId, twinGraphQuery, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create new entities in a graph instance
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {'node' | 'relationship'} modelType the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntities(organizationId: string, graphId: string, modelType: 'node' | 'relationship', graphProperties: Array<GraphProperties>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntities(organizationId, graphId, modelType, graphProperties, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new graph
         * @summary Create a new graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGraph(organizationId: string, graphId: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGraph(organizationId, graphId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete entities in a graph instance
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {'node' | 'relationship'} modelType the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntities(organizationId: string, graphId: string, modelType: 'node' | 'relationship', ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntities(organizationId, graphId, modelType, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download a graph compressed in a zip file
         * @summary Download a graph compressed in a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadGraph(organizationId: string, hash: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadGraph(organizationId, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return the list of all graphs stored in the organization
         * @summary Return the list of all graphs stored in the organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllTwingraphs(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllTwingraphs(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get entities in a graph instance
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {'node' | 'relationship'} modelType the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntities(organizationId: string, graphId: string, modelType: 'node' | 'relationship', ids: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntities(organizationId, graphId, modelType, ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return the metaData of the specified graph
         * @summary Return the metaData of the specified graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGraphMetaData(organizationId: string, graphId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGraphMetaData(organizationId, graphId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import a new version of a twin graph
         * @summary Import a new version of a twin graph
         * @param {string} organizationId the Organization identifier
         * @param {TwinGraphImport} twinGraphImport the graph to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importGraph(organizationId: string, twinGraphImport: TwinGraphImport, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwinGraphImportInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importGraph(organizationId, twinGraphImport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the status of a job
         * @summary Get the status of a job
         * @param {string} organizationId the Organization identifier
         * @param {string} jobId the job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobStatus(organizationId: string, jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobStatus(organizationId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Run a query on a graph instance
         * @summary Run a query on a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async query(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.query(organizationId, graphId, twinGraphQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {'node' | 'relationship'} modelType the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntities(organizationId: string, graphId: string, modelType: 'node' | 'relationship', graphProperties: Array<GraphProperties>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntities(organizationId, graphId, modelType, graphProperties, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update the metaData of the specified graph
         * @summary Update the metaData of the specified graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {{ [key: string]: string; }} requestBody the metaData to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGraphMetaData(organizationId: string, graphId: string, requestBody: { [key: string]: string; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGraphMetaData(organizationId, graphId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TwingraphApi - factory interface
 * @export
 */
export const TwingraphApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TwingraphApiFp(configuration)
    return {
        /**
         * Launch a mass delete job
         * @summary Launch a mass delete job
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(organizationId: string, graphId: string, options?: any): AxiosPromise<void> {
            return localVarFp._delete(organizationId, graphId, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchQuery(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options?: any): AxiosPromise<TwinGraphHash> {
            return localVarFp.batchQuery(organizationId, graphId, twinGraphQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Async batch update by loading a CSV file on a graph instance 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery 
         * @param {any} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchUploadUpdate(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, body: any, options?: any): AxiosPromise<TwinGraphBatchResult> {
            return localVarFp.batchUploadUpdate(organizationId, graphId, twinGraphQuery, body, options).then((request) => request(axios, basePath));
        },
        /**
         * create new entities in a graph instance
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {'node' | 'relationship'} modelType the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntities(organizationId: string, graphId: string, modelType: 'node' | 'relationship', graphProperties: Array<GraphProperties>, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.createEntities(organizationId, graphId, modelType, graphProperties, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new graph
         * @summary Create a new graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGraph(organizationId: string, graphId: string, body?: any, options?: any): AxiosPromise<void> {
            return localVarFp.createGraph(organizationId, graphId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * delete entities in a graph instance
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {'node' | 'relationship'} modelType the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntities(organizationId: string, graphId: string, modelType: 'node' | 'relationship', ids: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteEntities(organizationId, graphId, modelType, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Download a graph compressed in a zip file
         * @summary Download a graph compressed in a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadGraph(organizationId: string, hash: string, options?: any): AxiosPromise<any> {
            return localVarFp.downloadGraph(organizationId, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the list of all graphs stored in the organization
         * @summary Return the list of all graphs stored in the organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTwingraphs(organizationId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.findAllTwingraphs(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * get entities in a graph instance
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {'node' | 'relationship'} modelType the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntities(organizationId: string, graphId: string, modelType: 'node' | 'relationship', ids: Array<string>, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getEntities(organizationId, graphId, modelType, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Return the metaData of the specified graph
         * @summary Return the metaData of the specified graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraphMetaData(organizationId: string, graphId: string, options?: any): AxiosPromise<object> {
            return localVarFp.getGraphMetaData(organizationId, graphId, options).then((request) => request(axios, basePath));
        },
        /**
         * Import a new version of a twin graph
         * @summary Import a new version of a twin graph
         * @param {string} organizationId the Organization identifier
         * @param {TwinGraphImport} twinGraphImport the graph to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importGraph(organizationId: string, twinGraphImport: TwinGraphImport, options?: any): AxiosPromise<TwinGraphImportInfo> {
            return localVarFp.importGraph(organizationId, twinGraphImport, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a job
         * @summary Get the status of a job
         * @param {string} organizationId the Organization identifier
         * @param {string} jobId the job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobStatus(organizationId: string, jobId: string, options?: any): AxiosPromise<string> {
            return localVarFp.jobStatus(organizationId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a query on a graph instance
         * @summary Run a query on a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {TwinGraphQuery} twinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        query(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options?: any): AxiosPromise<string> {
            return localVarFp.query(organizationId, graphId, twinGraphQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {'node' | 'relationship'} modelType the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntities(organizationId: string, graphId: string, modelType: 'node' | 'relationship', graphProperties: Array<GraphProperties>, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.updateEntities(organizationId, graphId, modelType, graphProperties, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the metaData of the specified graph
         * @summary Update the metaData of the specified graph
         * @param {string} organizationId the Organization identifier
         * @param {string} graphId the Graph Identifier
         * @param {{ [key: string]: string; }} requestBody the metaData to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGraphMetaData(organizationId: string, graphId: string, requestBody: { [key: string]: string; }, options?: any): AxiosPromise<object> {
            return localVarFp.updateGraphMetaData(organizationId, graphId, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TwingraphApi - object-oriented interface
 * @export
 * @class TwingraphApi
 * @extends {BaseAPI}
 */
export class TwingraphApi extends BaseAPI {
    /**
     * Launch a mass delete job
     * @summary Launch a mass delete job
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public _delete(organizationId: string, graphId: string, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration)._delete(organizationId, graphId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a query on a graph instance and return the result as a zip file in async mode
     * @summary Run a query on a graph instance and return the result as a zip file in async mode
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {TwinGraphQuery} twinGraphQuery the query to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public batchQuery(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).batchQuery(organizationId, graphId, twinGraphQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Async batch update by loading a CSV file on a graph instance 
     * @summary Async batch update by loading a CSV file on a graph instance 
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {TwinGraphQuery} twinGraphQuery 
     * @param {any} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public batchUploadUpdate(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, body: any, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).batchUploadUpdate(organizationId, graphId, twinGraphQuery, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create new entities in a graph instance
     * @summary Create new entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {'node' | 'relationship'} modelType the entity model type
     * @param {Array<GraphProperties>} graphProperties the entities to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public createEntities(organizationId: string, graphId: string, modelType: 'node' | 'relationship', graphProperties: Array<GraphProperties>, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).createEntities(organizationId, graphId, modelType, graphProperties, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new graph
     * @summary Create a new graph
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public createGraph(organizationId: string, graphId: string, body?: any, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).createGraph(organizationId, graphId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete entities in a graph instance
     * @summary Delete entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {'node' | 'relationship'} modelType the entity model type
     * @param {Array<string>} ids the entities to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public deleteEntities(organizationId: string, graphId: string, modelType: 'node' | 'relationship', ids: Array<string>, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).deleteEntities(organizationId, graphId, modelType, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download a graph compressed in a zip file
     * @summary Download a graph compressed in a zip file
     * @param {string} organizationId the Organization identifier
     * @param {string} hash the Graph download identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public downloadGraph(organizationId: string, hash: string, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).downloadGraph(organizationId, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the list of all graphs stored in the organization
     * @summary Return the list of all graphs stored in the organization
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public findAllTwingraphs(organizationId: string, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).findAllTwingraphs(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get entities in a graph instance
     * @summary Get entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {'node' | 'relationship'} modelType the entity model type
     * @param {Array<string>} ids the entities to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public getEntities(organizationId: string, graphId: string, modelType: 'node' | 'relationship', ids: Array<string>, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).getEntities(organizationId, graphId, modelType, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return the metaData of the specified graph
     * @summary Return the metaData of the specified graph
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public getGraphMetaData(organizationId: string, graphId: string, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).getGraphMetaData(organizationId, graphId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import a new version of a twin graph
     * @summary Import a new version of a twin graph
     * @param {string} organizationId the Organization identifier
     * @param {TwinGraphImport} twinGraphImport the graph to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public importGraph(organizationId: string, twinGraphImport: TwinGraphImport, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).importGraph(organizationId, twinGraphImport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of a job
     * @summary Get the status of a job
     * @param {string} organizationId the Organization identifier
     * @param {string} jobId the job identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public jobStatus(organizationId: string, jobId: string, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).jobStatus(organizationId, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a query on a graph instance
     * @summary Run a query on a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {TwinGraphQuery} twinGraphQuery the query to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public query(organizationId: string, graphId: string, twinGraphQuery: TwinGraphQuery, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).query(organizationId, graphId, twinGraphQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update entities in a graph instance
     * @summary Update entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {'node' | 'relationship'} modelType the entity model type
     * @param {Array<GraphProperties>} graphProperties the entities to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public updateEntities(organizationId: string, graphId: string, modelType: 'node' | 'relationship', graphProperties: Array<GraphProperties>, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).updateEntities(organizationId, graphId, modelType, graphProperties, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the metaData of the specified graph
     * @summary Update the metaData of the specified graph
     * @param {string} organizationId the Organization identifier
     * @param {string} graphId the Graph Identifier
     * @param {{ [key: string]: string; }} requestBody the metaData to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TwingraphApi
     */
    public updateGraphMetaData(organizationId: string, graphId: string, requestBody: { [key: string]: string; }, options?: AxiosRequestConfig) {
        return TwingraphApiFp(this.configuration).updateGraphMetaData(organizationId, graphId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValidatorApi - axios parameter creator
 * @export
 */
export const ValidatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register a new validator
         * @param {string} organizationId the Organization identifier
         * @param {Validator} validator the Validator to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createValidator: async (organizationId: string, validator: Validator, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createValidator', 'organizationId', organizationId)
            // verify required parameter 'validator' is not null or undefined
            assertParamExists('createValidator', 'validator', validator)
            const localVarPath = `/organizations/{organization_id}/datasets/validators`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validator, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {ValidatorRun} validatorRun the Validator Run to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createValidatorRun: async (organizationId: string, validatorId: string, validatorRun: ValidatorRun, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createValidatorRun', 'organizationId', organizationId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('createValidatorRun', 'validatorId', validatorId)
            // verify required parameter 'validatorRun' is not null or undefined
            assertParamExists('createValidatorRun', 'validatorRun', validatorRun)
            const localVarPath = `/organizations/{organization_id}/datasets/validators/{validator_id}/history`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatorRun, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteValidator: async (organizationId: string, validatorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteValidator', 'organizationId', organizationId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('deleteValidator', 'validatorId', validatorId)
            const localVarPath = `/organizations/{organization_id}/datasets/validators/{validator_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {string} validatorrunId the Validator Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteValidatorRun: async (organizationId: string, validatorId: string, validatorrunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteValidatorRun', 'organizationId', organizationId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('deleteValidatorRun', 'validatorId', validatorId)
            // verify required parameter 'validatorrunId' is not null or undefined
            assertParamExists('deleteValidatorRun', 'validatorrunId', validatorrunId)
            const localVarPath = `/organizations/{organization_id}/datasets/validators/{validator_id}/history/{validatorrun_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)))
                .replace(`{${"validatorrun_id"}}`, encodeURIComponent(String(validatorrunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Validator Runs
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllValidatorRuns: async (organizationId: string, validatorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllValidatorRuns', 'organizationId', organizationId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('findAllValidatorRuns', 'validatorId', validatorId)
            const localVarPath = `/organizations/{organization_id}/datasets/validators/{validator_id}/history`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Validators
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllValidators: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllValidators', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/datasets/validators`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findValidatorById: async (organizationId: string, validatorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findValidatorById', 'organizationId', organizationId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('findValidatorById', 'validatorId', validatorId)
            const localVarPath = `/organizations/{organization_id}/datasets/validators/{validator_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {string} validatorrunId the Validator Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findValidatorRunById: async (organizationId: string, validatorId: string, validatorrunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findValidatorRunById', 'organizationId', organizationId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('findValidatorRunById', 'validatorId', validatorId)
            // verify required parameter 'validatorrunId' is not null or undefined
            assertParamExists('findValidatorRunById', 'validatorrunId', validatorrunId)
            const localVarPath = `/organizations/{organization_id}/datasets/validators/{validator_id}/history/{validatorrun_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)))
                .replace(`{${"validatorrun_id"}}`, encodeURIComponent(String(validatorrunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run a Validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {ValidatorRun} validatorRun the Validator to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runValidator: async (organizationId: string, validatorId: string, validatorRun: ValidatorRun, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('runValidator', 'organizationId', organizationId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('runValidator', 'validatorId', validatorId)
            // verify required parameter 'validatorRun' is not null or undefined
            assertParamExists('runValidator', 'validatorRun', validatorRun)
            const localVarPath = `/organizations/{organization_id}/datasets/validators/{validator_id}/run`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatorRun, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValidatorApi - functional programming interface
 * @export
 */
export const ValidatorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValidatorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register a new validator
         * @param {string} organizationId the Organization identifier
         * @param {Validator} validator the Validator to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createValidator(organizationId: string, validator: Validator, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Validator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createValidator(organizationId, validator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {ValidatorRun} validatorRun the Validator Run to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createValidatorRun(organizationId: string, validatorId: string, validatorRun: ValidatorRun, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createValidatorRun(organizationId, validatorId, validatorRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteValidator(organizationId: string, validatorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteValidator(organizationId, validatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {string} validatorrunId the Validator Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteValidatorRun(organizationId: string, validatorId: string, validatorrunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteValidatorRun(organizationId, validatorId, validatorrunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Validator Runs
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllValidatorRuns(organizationId: string, validatorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValidatorRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllValidatorRuns(organizationId, validatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Validators
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllValidators(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Validator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllValidators(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of a validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findValidatorById(organizationId: string, validatorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Validator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findValidatorById(organizationId, validatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of a validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {string} validatorrunId the Validator Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findValidatorRunById(organizationId: string, validatorId: string, validatorrunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findValidatorRunById(organizationId, validatorId, validatorrunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run a Validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {ValidatorRun} validatorRun the Validator to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runValidator(organizationId: string, validatorId: string, validatorRun: ValidatorRun, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runValidator(organizationId, validatorId, validatorRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValidatorApi - factory interface
 * @export
 */
export const ValidatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValidatorApiFp(configuration)
    return {
        /**
         * 
         * @summary Register a new validator
         * @param {string} organizationId the Organization identifier
         * @param {Validator} validator the Validator to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createValidator(organizationId: string, validator: Validator, options?: any): AxiosPromise<Validator> {
            return localVarFp.createValidator(organizationId, validator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {ValidatorRun} validatorRun the Validator Run to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createValidatorRun(organizationId: string, validatorId: string, validatorRun: ValidatorRun, options?: any): AxiosPromise<ValidatorRun> {
            return localVarFp.createValidatorRun(organizationId, validatorId, validatorRun, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteValidator(organizationId: string, validatorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteValidator(organizationId, validatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {string} validatorrunId the Validator Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteValidatorRun(organizationId: string, validatorId: string, validatorrunId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteValidatorRun(organizationId, validatorId, validatorrunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Validator Runs
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllValidatorRuns(organizationId: string, validatorId: string, options?: any): AxiosPromise<Array<ValidatorRun>> {
            return localVarFp.findAllValidatorRuns(organizationId, validatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Validators
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllValidators(organizationId: string, options?: any): AxiosPromise<Array<Validator>> {
            return localVarFp.findAllValidators(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findValidatorById(organizationId: string, validatorId: string, options?: any): AxiosPromise<Validator> {
            return localVarFp.findValidatorById(organizationId, validatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {string} validatorrunId the Validator Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findValidatorRunById(organizationId: string, validatorId: string, validatorrunId: string, options?: any): AxiosPromise<ValidatorRun> {
            return localVarFp.findValidatorRunById(organizationId, validatorId, validatorrunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run a Validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {ValidatorRun} validatorRun the Validator to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runValidator(organizationId: string, validatorId: string, validatorRun: ValidatorRun, options?: any): AxiosPromise<ValidatorRun> {
            return localVarFp.runValidator(organizationId, validatorId, validatorRun, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ValidatorApi - object-oriented interface
 * @export
 * @class ValidatorApi
 * @extends {BaseAPI}
 */
export class ValidatorApi extends BaseAPI {
    /**
     * 
     * @summary Register a new validator
     * @param {string} organizationId the Organization identifier
     * @param {Validator} validator the Validator to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public createValidator(organizationId: string, validator: Validator, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).createValidator(organizationId, validator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new validator run
     * @param {string} organizationId the Organization identifier
     * @param {string} validatorId the ValidatorRun identifier
     * @param {ValidatorRun} validatorRun the Validator Run to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public createValidatorRun(organizationId: string, validatorId: string, validatorRun: ValidatorRun, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).createValidatorRun(organizationId, validatorId, validatorRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a validator
     * @param {string} organizationId the Organization identifier
     * @param {string} validatorId the Validator identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public deleteValidator(organizationId: string, validatorId: string, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).deleteValidator(organizationId, validatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a validator run
     * @param {string} organizationId the Organization identifier
     * @param {string} validatorId the Validator identifier
     * @param {string} validatorrunId the Validator Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public deleteValidatorRun(organizationId: string, validatorId: string, validatorrunId: string, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).deleteValidatorRun(organizationId, validatorId, validatorrunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Validator Runs
     * @param {string} organizationId the Organization identifier
     * @param {string} validatorId the ValidatorRun identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public findAllValidatorRuns(organizationId: string, validatorId: string, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).findAllValidatorRuns(organizationId, validatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Validators
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public findAllValidators(organizationId: string, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).findAllValidators(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a validator
     * @param {string} organizationId the Organization identifier
     * @param {string} validatorId the Validator identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public findValidatorById(organizationId: string, validatorId: string, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).findValidatorById(organizationId, validatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a validator run
     * @param {string} organizationId the Organization identifier
     * @param {string} validatorId the Validator identifier
     * @param {string} validatorrunId the Validator Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public findValidatorRunById(organizationId: string, validatorId: string, validatorrunId: string, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).findValidatorRunById(organizationId, validatorId, validatorrunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run a Validator
     * @param {string} organizationId the Organization identifier
     * @param {string} validatorId the ValidatorRun identifier
     * @param {ValidatorRun} validatorRun the Validator to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public runValidator(organizationId: string, validatorId: string, validatorRun: ValidatorRun, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).runValidator(organizationId, validatorId, validatorRun, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkspaceApi - axios parameter creator
 * @export
 */
export const WorkspaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspaceAccessControl: async (organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceAccessControl' is not null or undefined
            assertParamExists('addWorkspaceAccessControl', 'workspaceAccessControl', workspaceAccessControl)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a secret for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceSecret} workspaceSecret the definition of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret: async (organizationId: string, workspaceId: string, workspaceSecret: WorkspaceSecret, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSecret', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createSecret', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceSecret' is not null or undefined
            assertParamExists('createSecret', 'workspaceSecret', workspaceSecret)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/secret`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceSecret, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace: async (organizationId: string, workspace: Workspace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createWorkspace', 'workspace', workspace)
            const localVarPath = `/organizations/{organization_id}/workspaces`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllWorkspaceFiles: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteAllWorkspaceFiles', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteAllWorkspaceFiles', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFile: async (organizationId: string, workspaceId: string, fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'fileName', fileName)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files/delete`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadWorkspaceFile: async (organizationId: string, workspaceId: string, fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('downloadWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('downloadWorkspaceFile', 'fileName', fileName)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files/download`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaceFiles: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllWorkspaceFiles', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findAllWorkspaceFiles', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaces: async (organizationId: string, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllWorkspaces', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/workspaces`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkspaceById: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findWorkspaceById', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findWorkspaceById', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions: async (organizationId: string, workspaceId: string, role: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspacePermissions', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspacePermissions', 'workspaceId', workspaceId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getWorkspacePermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurity: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceSecurity', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurityUsers: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceSecurityUsers', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import a workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importWorkspace: async (organizationId: string, workspace: Workspace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('importWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('importWorkspace', 'workspace', workspace)
            const localVarPath = `/organizations/{organization_id}/workspaces/import`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeWorkspaceAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Workspace default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceRole} workspaceRole the new Workspace default security.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceDefaultSecurity: async (organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setWorkspaceDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('setWorkspaceDefaultSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceRole' is not null or undefined
            assertParamExists('setWorkspaceDefaultSecurity', 'workspaceRole', workspaceRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Workspace} workspace The new Workspace details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace: async (organizationId: string, workspaceId: string, workspace: Workspace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceId', workspaceId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateWorkspace', 'workspace', workspace)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'identityId', identityId)
            // verify required parameter 'workspaceRole' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'workspaceRole', workspaceRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {any} file 
         * @param {boolean} [overwrite] 
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadWorkspaceFile: async (organizationId: string, workspaceId: string, file: any, overwrite?: boolean, destination?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('uploadWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('uploadWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadWorkspaceFile', 'file', file)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


            if (overwrite !== undefined) { 
                localVarFormParams.append('overwrite', overwrite as any);
            }
    
            if (destination !== undefined) { 
                localVarFormParams.append('destination', destination as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspaceApi - functional programming interface
 * @export
 */
export const WorkspaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a secret for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceSecret} workspaceSecret the definition of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSecret(organizationId: string, workspaceId: string, workspaceSecret: WorkspaceSecret, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSecret(organizationId, workspaceId, workspaceSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspace(organizationId: string, workspace: Workspace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspace(organizationId, workspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllWorkspaceFiles(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspace(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspace(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceFile(organizationId, workspaceId, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadWorkspaceFile(organizationId, workspaceId, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllWorkspaceFiles(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllWorkspaces(organizationId: string, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workspace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllWorkspaces(organizationId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findWorkspaceById(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findWorkspaceById(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceAccessControl(organizationId, workspaceId, identityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspacePermissions(organizationId: string, workspaceId: string, role: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspacePermissions(organizationId, workspaceId, role, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceSecurity(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceSecurityUsers(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Import a workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importWorkspace(organizationId: string, workspace: Workspace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importWorkspace(organizationId, workspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeWorkspaceAccessControl(organizationId, workspaceId, identityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set the Workspace default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceRole} workspaceRole the new Workspace default security.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Workspace} workspace The new Workspace details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspace(organizationId: string, workspaceId: string, workspace: Workspace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspace(organizationId, workspaceId, workspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {any} file 
         * @param {boolean} [overwrite] 
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadWorkspaceFile(organizationId: string, workspaceId: string, file: any, overwrite?: boolean, destination?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkspaceApi - factory interface
 * @export
 */
export const WorkspaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspaceApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: any): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.addWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a secret for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceSecret} workspaceSecret the definition of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret(organizationId: string, workspaceId: string, workspaceSecret: WorkspaceSecret, options?: any): AxiosPromise<void> {
            return localVarFp.createSecret(organizationId, workspaceId, workspaceSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(organizationId: string, workspace: Workspace, options?: any): AxiosPromise<Workspace> {
            return localVarFp.createWorkspace(organizationId, workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Workspace> {
            return localVarFp.deleteWorkspace(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: any): AxiosPromise<any> {
            return localVarFp.downloadWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Array<WorkspaceFile>> {
            return localVarFp.findAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaces(organizationId: string, page?: number, size?: number, options?: any): AxiosPromise<Array<Workspace>> {
            return localVarFp.findAllWorkspaces(organizationId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkspaceById(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Workspace> {
            return localVarFp.findWorkspaceById(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: any): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.getWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions(organizationId: string, workspaceId: string, role: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getWorkspacePermissions(organizationId, workspaceId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: any): AxiosPromise<WorkspaceSecurity> {
            return localVarFp.getWorkspaceSecurity(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getWorkspaceSecurityUsers(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import a workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importWorkspace(organizationId: string, workspace: Workspace, options?: any): AxiosPromise<Workspace> {
            return localVarFp.importWorkspace(organizationId, workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Workspace default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceRole} workspaceRole the new Workspace default security.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: any): AxiosPromise<WorkspaceSecurity> {
            return localVarFp.setWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Workspace} workspace The new Workspace details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(organizationId: string, workspaceId: string, workspace: Workspace, options?: any): AxiosPromise<Workspace> {
            return localVarFp.updateWorkspace(organizationId, workspaceId, workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: any): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {any} file 
         * @param {boolean} [overwrite] 
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadWorkspaceFile(organizationId: string, workspaceId: string, file: any, overwrite?: boolean, destination?: string, options?: any): AxiosPromise<WorkspaceFile> {
            return localVarFp.uploadWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspaceApi - object-oriented interface
 * @export
 * @class WorkspaceApi
 * @extends {BaseAPI}
 */
export class WorkspaceApi extends BaseAPI {
    /**
     * 
     * @summary Add a control access to the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public addWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).addWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a secret for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {WorkspaceSecret} workspaceSecret the definition of the secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createSecret(organizationId: string, workspaceId: string, workspaceSecret: WorkspaceSecret, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createSecret(organizationId, workspaceId, workspaceSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new workspace
     * @param {string} organizationId the Organization identifier
     * @param {Workspace} workspace the Workspace to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createWorkspace(organizationId: string, workspace: Workspace, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createWorkspace(organizationId, workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all Workspace files
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspace(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspace(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace file
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} fileName the file name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download the Workspace File specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} fileName the file name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public downloadWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).downloadWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Workspace files
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public findAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).findAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Workspaces
     * @param {string} organizationId the Organization identifier
     * @param {number} [page] page number to query
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public findAllWorkspaces(organizationId: string, page?: number, size?: number, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).findAllWorkspaces(organizationId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public findWorkspaceById(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).findWorkspaceById(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace permission by given role
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} role the Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspacePermissions(organizationId: string, workspaceId: string, role: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspacePermissions(organizationId, workspaceId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace security information
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceSecurity(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceSecurityUsers(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import a workspace
     * @param {string} organizationId the Organization identifier
     * @param {Workspace} workspace the Workspace to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public importWorkspace(organizationId: string, workspace: Workspace, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).importWorkspace(organizationId, workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public removeWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).removeWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Workspace default security
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {WorkspaceRole} workspaceRole the new Workspace default security.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public setWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).setWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {Workspace} workspace The new Workspace details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspace(organizationId: string, workspaceId: string, workspace: Workspace, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspace(organizationId, workspaceId, workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} identityId the User identifier
     * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a file for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {any} file 
     * @param {boolean} [overwrite] 
     * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public uploadWorkspaceFile(organizationId: string, workspaceId: string, file: any, overwrite?: boolean, destination?: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).uploadWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options).then((request) => request(this.axios, this.basePath));
    }
}


