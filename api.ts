/* tslint:disable */
/* eslint-disable */
/**
 * Cosmo Tech Platform API
 * Cosmo Tech Platform API
 *
 * The version of the OpenAPI document: 4.0.0-onprem.10
 * Contact: platform@cosmotech.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * a RBAC by component
 * @export
 * @interface ComponentRolePermissions
 */
export interface ComponentRolePermissions {
    /**
     * 
     * @type {string}
     * @memberof ComponentRolePermissions
     */
    'component'?: string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ComponentRolePermissions
     */
    'roles'?: { [key: string]: Array<string>; };
}
/**
 * a version of a Connector
 * @export
 * @interface Connector
 */
export interface Connector {
    /**
     * the Connector version unique identifier
     * @type {string}
     * @memberof Connector
     */
    'id'?: string;
    /**
     * the Connector key which group Connector versions
     * @type {string}
     * @memberof Connector
     */
    'key'?: string;
    /**
     * the Connector name
     * @type {string}
     * @memberof Connector
     */
    'name'?: string;
    /**
     * the Connector description
     * @type {string}
     * @memberof Connector
     */
    'description'?: string;
    /**
     * the registry repository containing the image
     * @type {string}
     * @memberof Connector
     */
    'repository'?: string;
    /**
     * the Connector version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof Connector
     */
    'version'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Connector
     */
    'tags'?: Array<string>;
    /**
     * the user id which own this connector version
     * @type {string}
     * @memberof Connector
     */
    'ownerId'?: string;
    /**
     * an optional URL link to connector page
     * @type {string}
     * @memberof Connector
     */
    'url'?: string;
    /**
     * 
     * @type {Array<IoTypesEnum>}
     * @memberof Connector
     */
    'ioTypes'?: Array<IoTypesEnum>;
    /**
     * the list of connector parameters groups
     * @type {Array<ConnectorParameterGroup>}
     * @memberof Connector
     */
    'parameterGroups'?: Array<ConnectorParameterGroup>;
}
/**
 * a connector parameter
 * @export
 * @interface ConnectorParameter
 */
export interface ConnectorParameter {
    /**
     * the connector parameter id
     * @type {string}
     * @memberof ConnectorParameter
     */
    'id': string;
    /**
     * the list of translated parameter group labels
     * @type {string}
     * @memberof ConnectorParameter
     */
    'label': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof ConnectorParameter
     */
    'valueType'?: string;
    /**
     * the list of available and valid values for the parameter
     * @type {Array<string>}
     * @memberof ConnectorParameter
     */
    'options'?: Array<string>;
    /**
     * the default value
     * @type {string}
     * @memberof ConnectorParameter
     */
    'default'?: string;
    /**
     * associated environment variable in connector image
     * @type {string}
     * @memberof ConnectorParameter
     */
    'envVar'?: string;
}
/**
 * a connector parameters group
 * @export
 * @interface ConnectorParameterGroup
 */
export interface ConnectorParameterGroup {
    /**
     * the connector parameter group id
     * @type {string}
     * @memberof ConnectorParameterGroup
     */
    'id': string;
    /**
     * the list of translated parameter group labels
     * @type {string}
     * @memberof ConnectorParameterGroup
     */
    'label': string;
    /**
     * the list of parameters
     * @type {Array<ConnectorParameter>}
     * @memberof ConnectorParameterGroup
     */
    'parameters': Array<ConnectorParameter>;
}
/**
 * define cpus and memory needs
 * @export
 * @interface ContainerResourceSizeInfo
 */
export interface ContainerResourceSizeInfo {
    /**
     * define cpu needs
     * @type {string}
     * @memberof ContainerResourceSizeInfo
     */
    'cpu': string;
    /**
     * define memory needs
     * @type {string}
     * @memberof ContainerResourceSizeInfo
     */
    'memory': string;
}
/**
 * a description object for resource requests and limits (default same configuration as basic sizing)
 * @export
 * @interface ContainerResourceSizing
 */
export interface ContainerResourceSizing {
    /**
     * 
     * @type {ContainerResourceSizeInfo}
     * @memberof ContainerResourceSizing
     */
    'requests': ContainerResourceSizeInfo;
    /**
     * 
     * @type {ContainerResourceSizeInfo}
     * @memberof ContainerResourceSizing
     */
    'limits': ContainerResourceSizeInfo;
}
/**
 * Newle created Run info
 * @export
 * @interface CreatedRun
 */
export interface CreatedRun {
    /**
     * Run id
     * @type {string}
     * @memberof CreatedRun
     */
    'id': string;
}
/**
 * a Dataset
 * @export
 * @interface Dataset
 */
export interface Dataset {
    /**
     * the Dataset unique identifier
     * @type {string}
     * @memberof Dataset
     */
    'id'?: string;
    /**
     * the Dataset name
     * @type {string}
     * @memberof Dataset
     */
    'name'?: string;
    /**
     * the Dataset description
     * @type {string}
     * @memberof Dataset
     */
    'description'?: string;
    /**
     * the User id which own this Dataset
     * @type {string}
     * @memberof Dataset
     */
    'ownerId'?: string;
    /**
     * the name of the owner
     * @type {string}
     * @memberof Dataset
     */
    'ownerName'?: string;
    /**
     * the Organization Id related to this Dataset
     * @type {string}
     * @memberof Dataset
     */
    'organizationId'?: string;
    /**
     * the Dataset id which is the parent of this Dataset
     * @type {string}
     * @memberof Dataset
     */
    'parentId'?: string;
    /**
     * list of workspace linked to this dataset
     * @type {Array<string>}
     * @memberof Dataset
     */
    'linkedWorkspaceIdList'?: Array<string>;
    /**
     * the twin graph id
     * @type {string}
     * @memberof Dataset
     */
    'twingraphId'?: string;
    /**
     * is this the main dataset
     * @type {boolean}
     * @memberof Dataset
     */
    'main'?: boolean;
    /**
     * the Dataset creation date
     * @type {number}
     * @memberof Dataset
     */
    'creationDate'?: number;
    /**
     * the last time a refresh was done
     * @type {number}
     * @memberof Dataset
     */
    'refreshDate'?: number;
    /**
     * 
     * @type {DatasetSourceType}
     * @memberof Dataset
     */
    'sourceType'?: DatasetSourceType;
    /**
     * 
     * @type {SourceInfo}
     * @memberof Dataset
     */
    'source'?: SourceInfo;
    /**
     * 
     * @type {IngestionStatusEnum}
     * @memberof Dataset
     */
    'ingestionStatus'?: IngestionStatusEnum | null;
    /**
     * 
     * @type {TwincacheStatusEnum}
     * @memberof Dataset
     */
    'twincacheStatus'?: TwincacheStatusEnum | null;
    /**
     * the list of queries
     * @type {Array<string>}
     * @memberof Dataset
     */
    'queries'?: Array<string>;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Dataset
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {DatasetConnector}
     * @memberof Dataset
     */
    'connector'?: DatasetConnector;
    /**
     * the list of other Datasets ids to compose as fragments
     * @type {Array<string>}
     * @memberof Dataset
     */
    'fragmentsIds'?: Array<string>;
    /**
     * the validator id
     * @type {string}
     * @memberof Dataset
     */
    'validatorId'?: string;
    /**
     * the list of compatible Solutions versions
     * @type {Array<DatasetCompatibility>}
     * @memberof Dataset
     */
    'compatibility'?: Array<DatasetCompatibility>;
    /**
     * 
     * @type {DatasetSecurity}
     * @memberof Dataset
     */
    'security'?: DatasetSecurity;
}


/**
 * a Dataset access control item
 * @export
 * @interface DatasetAccessControl
 */
export interface DatasetAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof DatasetAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof DatasetAccessControl
     */
    'role': string;
}
/**
 * a Dataset compatibility constraint to a Solution version open range
 * @export
 * @interface DatasetCompatibility
 */
export interface DatasetCompatibility {
    /**
     * the Solution key which group Solution versions
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'solutionKey': string;
    /**
     * the Solution minimum version compatibility (version included)
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'minimumVersion'?: string;
    /**
     * the Solution maximum version compatibility (version included)
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'maximumVersion'?: string;
}
/**
 * the Connector setup bound to a Dataset
 * @export
 * @interface DatasetConnector
 */
export interface DatasetConnector {
    /**
     * the Connector id
     * @type {string}
     * @memberof DatasetConnector
     */
    'id'?: string;
    /**
     * the Connector name
     * @type {string}
     * @memberof DatasetConnector
     */
    'name'?: string;
    /**
     * the Connector version
     * @type {string}
     * @memberof DatasetConnector
     */
    'version'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DatasetConnector
     */
    'parametersValues'?: { [key: string]: string; };
}
/**
 * the Dataset Copy Parameters
 * @export
 * @interface DatasetCopyParameters
 */
export interface DatasetCopyParameters {
    /**
     * the source Dataset id
     * @type {string}
     * @memberof DatasetCopyParameters
     */
    'sourceId'?: string;
    /**
     * the target Dataset id
     * @type {string}
     * @memberof DatasetCopyParameters
     */
    'targetId'?: string;
    /**
     * freeform options to path to connectors
     * @type {{ [key: string]: any; }}
     * @memberof DatasetCopyParameters
     */
    'options'?: { [key: string]: any; };
}
/**
 * the Dataset Role
 * @export
 * @interface DatasetRole
 */
export interface DatasetRole {
    /**
     * the Dataset Role
     * @type {string}
     * @memberof DatasetRole
     */
    'role': string;
}
/**
 * the search options
 * @export
 * @interface DatasetSearch
 */
export interface DatasetSearch {
    /**
     * the dataset tag list to search
     * @type {Array<string>}
     * @memberof DatasetSearch
     */
    'datasetTags': Array<string>;
}
/**
 * the dataset security information
 * @export
 * @interface DatasetSecurity
 */
export interface DatasetSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof DatasetSecurity
     */
    'default': string;
    /**
     * the list which can access this Dataset with detailed access control information
     * @type {Array<DatasetAccessControl>}
     * @memberof DatasetSecurity
     */
    'accessControlList': Array<DatasetAccessControl>;
}
/**
 * the Dataset Source Type
 * @export
 * @enum {string}
 */

export const DatasetSourceType = {
    Adt: 'ADT',
    AzureStorage: 'AzureStorage',
    File: 'File',
    None: 'None',
    Twincache: 'Twincache',
    Etl: 'ETL'
} as const;

export type DatasetSourceType = typeof DatasetSourceType[keyof typeof DatasetSourceType];


/**
 * a twin graph hash
 * @export
 * @interface DatasetTwinGraphHash
 */
export interface DatasetTwinGraphHash {
    /**
     * the hash of the graph
     * @type {string}
     * @memberof DatasetTwinGraphHash
     */
    'hash'?: string;
}
/**
 * a twin graph query in cypher language
 * @export
 * @interface DatasetTwinGraphInfo
 */
export interface DatasetTwinGraphInfo {
    /**
     * the import job id
     * @type {string}
     * @memberof DatasetTwinGraphInfo
     */
    'jobId'?: string;
    /**
     * the Dataset id
     * @type {string}
     * @memberof DatasetTwinGraphInfo
     */
    'datasetId'?: string;
    /**
     * Twingraph status
     * @type {string}
     * @memberof DatasetTwinGraphInfo
     */
    'status'?: string;
}
/**
 * a twin graph query in cypher language
 * @export
 * @interface DatasetTwinGraphQuery
 */
export interface DatasetTwinGraphQuery {
    /**
     * the query in cypher language
     * @type {string}
     * @memberof DatasetTwinGraphQuery
     */
    'query': string;
}
/**
 * Configuration of scenario runs deletion automatic mecanism
 * @export
 * @interface DeleteHistoricalData
 */
export interface DeleteHistoricalData {
    /**
     * Activate or Deactivate historical data deletion
     * @type {boolean}
     * @memberof DeleteHistoricalData
     */
    'enable': boolean;
    /**
     * define the polling frequency of scenario run status (in millis)
     * @type {number}
     * @memberof DeleteHistoricalData
     */
    'pollFrequency'?: number;
    /**
     * define the polling timeout
     * @type {number}
     * @memberof DeleteHistoricalData
     */
    'timeOut'?: number;
}
/**
 * 
 * @export
 * @interface FileUploadMetadata
 */
export interface FileUploadMetadata {
    /**
     * 
     * @type {string}
     * @memberof FileUploadMetadata
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileUploadMetadata
     */
    'size'?: number;
}
/**
 * files read on upload
 * @export
 * @interface FileUploadValidation
 */
export interface FileUploadValidation {
    /**
     * list of filename found on nodes folder
     * @type {Array<FileUploadMetadata>}
     * @memberof FileUploadValidation
     */
    'nodes'?: Array<FileUploadMetadata>;
    /**
     * list of filename found on edges folder
     * @type {Array<FileUploadMetadata>}
     * @memberof FileUploadValidation
     */
    'edges'?: Array<FileUploadMetadata>;
}
/**
 * 
 * @export
 * @interface GraphProperties
 */
export interface GraphProperties {
    /**
     * the type of the relationship
     * @type {string}
     * @memberof GraphProperties
     */
    'type'?: string;
    /**
     * the source node of the relationship
     * @type {string}
     * @memberof GraphProperties
     */
    'source'?: string;
    /**
     * the target node of the relationship
     * @type {string}
     * @memberof GraphProperties
     */
    'target'?: string;
    /**
     * the name of the graph data object
     * @type {string}
     * @memberof GraphProperties
     */
    'name'?: string;
    /**
     * the parameters of the graph data object
     * @type {string}
     * @memberof GraphProperties
     */
    'params'?: string;
}
/**
 * the Dataset ingestion status
 * @export
 * @enum {string}
 */

export const IngestionStatusEnum = {
    None: 'NONE',
    Pending: 'PENDING',
    Error: 'ERROR',
    Success: 'SUCCESS'
} as const;

export type IngestionStatusEnum = typeof IngestionStatusEnum[keyof typeof IngestionStatusEnum];


/**
 * The read and write capabilities of connector
 * @export
 * @enum {string}
 */

export const IoTypesEnum = {
    Read: 'read',
    Write: 'write'
} as const;

export type IoTypesEnum = typeof IoTypesEnum[keyof typeof IoTypesEnum];


/**
 * an Organization
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * the Organization unique identifier
     * @type {string}
     * @memberof Organization
     */
    'id'?: string;
    /**
     * the Organization name
     * @type {string}
     * @memberof Organization
     */
    'name'?: string;
    /**
     * the Owner User Id
     * @type {string}
     * @memberof Organization
     */
    'ownerId'?: string;
    /**
     * 
     * @type {OrganizationSecurity}
     * @memberof Organization
     */
    'security'?: OrganizationSecurity;
}
/**
 * a Organization access control item
 * @export
 * @interface OrganizationAccessControl
 */
export interface OrganizationAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof OrganizationAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof OrganizationAccessControl
     */
    'role': string;
}
/**
 * the Organization Role
 * @export
 * @interface OrganizationRole
 */
export interface OrganizationRole {
    /**
     * the Organization Role
     * @type {string}
     * @memberof OrganizationRole
     */
    'role': string;
}
/**
 * the Organization security information
 * @export
 * @interface OrganizationSecurity
 */
export interface OrganizationSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof OrganizationSecurity
     */
    'default': string;
    /**
     * the list which can access this Organization with detailed access control information
     * @type {Array<OrganizationAccessControl>}
     * @memberof OrganizationSecurity
     */
    'accessControlList': Array<OrganizationAccessControl>;
}
/**
 * the result of a SQL Query
 * @export
 * @interface QueryResult
 */
export interface QueryResult {
    /**
     * the list of results
     * @type {Array<{ [key: string]: any; }>}
     * @memberof QueryResult
     */
    'result'?: Array<{ [key: string]: any; }>;
}
/**
 * define cpus and memory needs
 * @export
 * @interface ResourceSizeInfo
 */
export interface ResourceSizeInfo {
    /**
     * define cpu needs
     * @type {string}
     * @memberof ResourceSizeInfo
     */
    'cpu': string;
    /**
     * define memory needs
     * @type {string}
     * @memberof ResourceSizeInfo
     */
    'memory': string;
}
/**
 * a Run with only base properties
 * @export
 * @interface Run
 */
export interface Run {
    /**
     * the Run
     * @type {string}
     * @memberof Run
     */
    'id'?: string;
    /**
     * 
     * @type {RunState}
     * @memberof Run
     */
    'state'?: RunState;
    /**
     * the Organization id
     * @type {string}
     * @memberof Run
     */
    'organizationId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof Run
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech Simulation Run Id
     * @type {string}
     * @memberof Run
     */
    'csmSimulationRun'?: string;
    /**
     * the base name for workflow name generation
     * @type {string}
     * @memberof Run
     */
    'generateName'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof Run
     */
    'workflowName'?: string;
    /**
     * the user id which own this run
     * @type {string}
     * @memberof Run
     */
    'ownerId'?: string;
    /**
     * the Workspace Id
     * @type {string}
     * @memberof Run
     */
    'workspaceId'?: string;
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof Run
     */
    'workspaceKey'?: string;
    /**
     * the Runner Id
     * @type {string}
     * @memberof Run
     */
    'runnerId'?: string;
    /**
     * the Solution Id
     * @type {string}
     * @memberof Run
     */
    'solutionId'?: string;
    /**
     * the Solution Run Template id
     * @type {string}
     * @memberof Run
     */
    'runTemplateId'?: string;
    /**
     * the compute size needed for this Analysis. Standard sizes are basic and highcpu. Default is basic
     * @type {string}
     * @memberof Run
     */
    'computeSize'?: string;
    /**
     * the Run creation date
     * @type {string}
     * @memberof Run
     */
    'createdAt'?: string;
    /**
     * the list of Dataset Id associated to this Run
     * @type {Array<string>}
     * @memberof Run
     */
    'datasetList'?: Array<string>;
    /**
     * the list of Run Template parameters values
     * @type {Array<RunTemplateParameterValue>}
     * @memberof Run
     */
    'parametersValues'?: Array<RunTemplateParameterValue>;
    /**
     * the node label request
     * @type {string}
     * @memberof Run
     */
    'nodeLabel'?: string;
    /**
     * the containers list. This information is not returned by the API.
     * @type {Array<RunContainer>}
     * @memberof Run
     */
    'containers'?: Array<RunContainer>;
}


/**
 * a Run container description
 * @export
 * @interface RunContainer
 */
export interface RunContainer {
    /**
     * the container Id
     * @type {string}
     * @memberof RunContainer
     */
    'id'?: string;
    /**
     * the container name
     * @type {string}
     * @memberof RunContainer
     */
    'name': string;
    /**
     * the metadata labels
     * @type {{ [key: string]: string; }}
     * @memberof RunContainer
     */
    'labels'?: { [key: string]: string; };
    /**
     * environment variable map
     * @type {{ [key: string]: string; }}
     * @memberof RunContainer
     */
    'envVars'?: { [key: string]: string; };
    /**
     * the container image URI
     * @type {string}
     * @memberof RunContainer
     */
    'image': string;
    /**
     * the container entry point
     * @type {string}
     * @memberof RunContainer
     */
    'entrypoint'?: string;
    /**
     * the list of run arguments for the container
     * @type {Array<string>}
     * @memberof RunContainer
     */
    'runArgs'?: Array<string>;
    /**
     * the list of dependencies container name to run this container
     * @type {Array<string>}
     * @memberof RunContainer
     */
    'dependencies'?: Array<string>;
    /**
     * whether or not this container is a Cosmo Tech solution container
     * @type {boolean}
     * @memberof RunContainer
     */
    'solutionContainer'?: boolean;
    /**
     * the node label request
     * @type {string}
     * @memberof RunContainer
     */
    'nodeLabel'?: string;
    /**
     * 
     * @type {ContainerResourceSizing}
     * @memberof RunContainer
     */
    'runSizing'?: ContainerResourceSizing;
}
/**
 * Run Data to send
 * @export
 * @interface RunData
 */
export interface RunData {
    /**
     * Database name
     * @type {string}
     * @memberof RunData
     */
    'database_name'?: string;
    /**
     * Table name
     * @type {string}
     * @memberof RunData
     */
    'table_name'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof RunData
     */
    'data'?: Array<{ [key: string]: any; }>;
}
/**
 * a data result query in SQL
 * @export
 * @interface RunDataQuery
 */
export interface RunDataQuery {
    /**
     * the query in SQL
     * @type {string}
     * @memberof RunDataQuery
     */
    'query': string;
}
/**
 * the output logs of a run
 * @export
 * @interface RunLogs
 */
export interface RunLogs {
    /**
     * the Run Id
     * @type {string}
     * @memberof RunLogs
     */
    'runId': string;
    /**
     * run log entries in chronological order
     * @type {Array<RunLogsEntry>}
     * @memberof RunLogs
     */
    'logs': Array<RunLogsEntry>;
}
/**
 * single run log entry
 * @export
 * @interface RunLogsEntry
 */
export interface RunLogsEntry {
    /**
     * log line data
     * @type {string}
     * @memberof RunLogsEntry
     */
    'line': string;
}
/**
 * the memory and CPU requested by the pod
 * @export
 * @interface RunResourceRequested
 */
export interface RunResourceRequested {
    /**
     * the cpu requested
     * @type {number}
     * @memberof RunResourceRequested
     */
    'cpu'?: number;
    /**
     * the memory requested
     * @type {number}
     * @memberof RunResourceRequested
     */
    'memory'?: number;
}
/**
 * the Run end-to-end state
 * @export
 * @enum {string}
 */

export const RunState = {
    Running: 'Running',
    Successful: 'Successful',
    Failed: 'Failed',
    Unknown: 'Unknown'
} as const;

export type RunState = typeof RunState[keyof typeof RunState];


/**
 * a Run status
 * @export
 * @interface RunStatus
 */
export interface RunStatus {
    /**
     * the Run id
     * @type {string}
     * @memberof RunStatus
     */
    'id'?: string;
    /**
     * the Organization id
     * @type {string}
     * @memberof RunStatus
     */
    'organizationId'?: string;
    /**
     * the Workspace id
     * @type {string}
     * @memberof RunStatus
     */
    'workspaceId'?: string;
    /**
     * the Runner id
     * @type {string}
     * @memberof RunStatus
     */
    'runnerId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof RunStatus
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof RunStatus
     */
    'workflowName'?: string;
    /**
     * the Run start Date Time
     * @type {string}
     * @memberof RunStatus
     */
    'startTime'?: string;
    /**
     * the Run end Date Time
     * @type {string}
     * @memberof RunStatus
     */
    'endTime'?: string;
    /**
     * high-level summary of where the workflow is in its lifecycle
     * @type {string}
     * @memberof RunStatus
     */
    'phase'?: string;
    /**
     * progress to completion
     * @type {string}
     * @memberof RunStatus
     */
    'progress'?: string;
    /**
     * a  human readable message indicating details about why the workflow is in this condition
     * @type {string}
     * @memberof RunStatus
     */
    'message'?: string;
    /**
     * estimatedDuration in seconds
     * @type {number}
     * @memberof RunStatus
     */
    'estimatedDuration'?: number;
    /**
     * status of Run nodes
     * @type {Array<RunStatusNode>}
     * @memberof RunStatus
     */
    'nodes'?: Array<RunStatusNode>;
    /**
     * 
     * @type {RunState}
     * @memberof RunStatus
     */
    'state'?: RunState;
}


/**
 * status of a Run Node
 * @export
 * @interface RunStatusNode
 */
export interface RunStatusNode {
    /**
     * the node id
     * @type {string}
     * @memberof RunStatusNode
     */
    'id'?: string;
    /**
     * the node unique name
     * @type {string}
     * @memberof RunStatusNode
     */
    'name'?: string;
    /**
     * the Run container name
     * @type {string}
     * @memberof RunStatusNode
     */
    'containerName'?: string;
    /**
     * the list of outbound nodes
     * @type {Array<string>}
     * @memberof RunStatusNode
     */
    'outboundNodes'?: Array<string>;
    /**
     * 
     * @type {RunResourceRequested}
     * @memberof RunStatusNode
     */
    'resourcesDuration'?: RunResourceRequested;
    /**
     * estimatedDuration in seconds
     * @type {number}
     * @memberof RunStatusNode
     */
    'estimatedDuration'?: number;
    /**
     * HostNodeName name of the Kubernetes node on which the Pod is running, if applicable
     * @type {string}
     * @memberof RunStatusNode
     */
    'hostNodeName'?: string;
    /**
     * a human readable message indicating details about why the node is in this condition
     * @type {string}
     * @memberof RunStatusNode
     */
    'message'?: string;
    /**
     * high-level summary of where the node is in its lifecycle
     * @type {string}
     * @memberof RunStatusNode
     */
    'phase'?: string;
    /**
     * progress to completion
     * @type {string}
     * @memberof RunStatusNode
     */
    'progress'?: string;
    /**
     * the node start time
     * @type {string}
     * @memberof RunStatusNode
     */
    'startTime'?: string;
    /**
     * the node end time
     * @type {string}
     * @memberof RunStatusNode
     */
    'endTime'?: string;
}
/**
 * a Solution Run Template
 * @export
 * @interface RunTemplate
 */
export interface RunTemplate {
    /**
     * the Solution Run Template id
     * @type {string}
     * @memberof RunTemplate
     */
    'id': string;
    /**
     * the Run Template name
     * @type {string}
     * @memberof RunTemplate
     * @deprecated
     */
    'name'?: string;
    /**
     * a translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplate
     */
    'labels'?: { [key: string]: string; };
    /**
     * the Run Template description
     * @type {string}
     * @memberof RunTemplate
     */
    'description'?: string;
    /**
     * the Cosmo Tech simulation name. This information is send to the Engine. Mandatory information if no Engine is defined
     * @type {string}
     * @memberof RunTemplate
     */
    'csmSimulation'?: string;
    /**
     * the list of Run Template tags
     * @type {Array<string>}
     * @memberof RunTemplate
     */
    'tags'?: Array<string>;
    /**
     * the compute size needed for this Run Template. Standard sizes are basic and highcpu. Default is basic
     * @type {string}
     * @memberof RunTemplate
     */
    'computeSize'?: string;
    /**
     * 
     * @type {RunTemplateResourceSizing}
     * @memberof RunTemplate
     */
    'runSizing'?: RunTemplateResourceSizing;
    /**
     * set to true if the run template does not want to check data ingestion state (no probes or not control plane)
     * @type {boolean}
     * @memberof RunTemplate
     */
    'noDataIngestionState'?: boolean;
    /**
     * whether or not the fetch dataset step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'fetchDatasets'?: boolean;
    /**
     * whether or not the scenario data download transform step step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'scenarioDataDownloadTransform'?: boolean;
    /**
     * whether or not the fetch parameters step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'fetchScenarioParameters'?: boolean;
    /**
     * whether or not the apply parameter step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'applyParameters'?: boolean;
    /**
     * whether or not the validate step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'validateData'?: boolean;
    /**
     * whether or not the Datasets values are send to the DataWarehouse prior to Simulation Run. If not set follow the Workspace setting
     * @type {boolean}
     * @memberof RunTemplate
     */
    'sendDatasetsToDataWarehouse'?: boolean;
    /**
     * whether or not the input parameters values are send to the DataWarehouse prior to Simulation Run. If not set follow the Workspace setting
     * @type {boolean}
     * @memberof RunTemplate
     */
    'sendInputParametersToDataWarehouse'?: boolean;
    /**
     * whether or not the pre-run step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'preRun'?: boolean;
    /**
     * whether or not the run step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'run'?: boolean;
    /**
     * whether or not the post-run step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'postRun'?: boolean;
    /**
     * whether or not to store the scenario parameters in json instead of csv
     * @type {boolean}
     * @memberof RunTemplate
     */
    'parametersJson'?: boolean;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'parametersHandlerSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'datasetValidatorSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'preRunSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'runSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'postRunSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'scenariodataTransformSource'?: RunTemplateStepSource;
    /**
     * the ordered list of parameters groups for the Run Template
     * @type {Array<string>}
     * @memberof RunTemplate
     */
    'parameterGroups'?: Array<string>;
    /**
     * whether or not to stack adjacent scenario run steps in one container run which will chain steps
     * @type {boolean}
     * @memberof RunTemplate
     */
    'stackSteps'?: boolean;
    /**
     * an optional URL to the git repository
     * @type {string}
     * @memberof RunTemplate
     */
    'gitRepositoryUrl'?: string;
    /**
     * an optional git branch name
     * @type {string}
     * @memberof RunTemplate
     */
    'gitBranchName'?: string;
    /**
     * an optional directory where to find the run template source
     * @type {string}
     * @memberof RunTemplate
     */
    'runTemplateSourceDir'?: string;
    /**
     * 
     * @type {RunTemplateOrchestrator}
     * @memberof RunTemplate
     */
    'orchestratorType'?: RunTemplateOrchestrator;
    /**
     * an optional duration in seconds in which a workflow is allowed to run
     * @type {number}
     * @memberof RunTemplate
     */
    'executionTimeout'?: number;
    /**
     * 
     * @type {DeleteHistoricalData}
     * @memberof RunTemplate
     */
    'deleteHistoricalData'?: DeleteHistoricalData;
}


/**
 * the Orchestrator to use for the Run Template
 * @export
 * @enum {string}
 */

export const RunTemplateOrchestrator = {
    ArgoWorkflow: 'argoWorkflow',
    CsmOrc: 'csmOrc'
} as const;

export type RunTemplateOrchestrator = typeof RunTemplateOrchestrator[keyof typeof RunTemplateOrchestrator];


/**
 * a Run Template Parameter
 * @export
 * @interface RunTemplateParameter
 */
export interface RunTemplateParameter {
    /**
     * the Parameter id
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'id': string;
    /**
     * a translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameter
     */
    'labels'?: { [key: string]: string; };
    /**
     * the variable type for the parameter. Basic types or special type %DATASETID%
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'varType'?: string;
    /**
     * the default value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'defaultValue'?: string;
    /**
     * the minimum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'minValue'?: string;
    /**
     * the maximum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'maxValue'?: string;
    /**
     * a regex to validate the value
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'regexValidation'?: string;
    /**
     * freeform options
     * @type {{ [key: string]: any; }}
     * @memberof RunTemplateParameter
     */
    'options'?: { [key: string]: any; };
}
/**
 * a Parameter Group for a Run Template
 * @export
 * @interface RunTemplateParameterGroup
 */
export interface RunTemplateParameterGroup {
    /**
     * the Parameter Group id
     * @type {string}
     * @memberof RunTemplateParameterGroup
     */
    'id': string;
    /**
     * a translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameterGroup
     */
    'labels'?: { [key: string]: string; };
    /**
     * does the group define a table
     * @type {boolean}
     * @memberof RunTemplateParameterGroup
     */
    'isTable'?: boolean;
    /**
     * freeform options
     * @type {{ [key: string]: any; }}
     * @memberof RunTemplateParameterGroup
     */
    'options'?: { [key: string]: any; };
    /**
     * the Run Template Group parent Id
     * @type {string}
     * @memberof RunTemplateParameterGroup
     */
    'parentId'?: string;
    /**
     * an ordered list of Run Template Parameters
     * @type {Array<string>}
     * @memberof RunTemplateParameterGroup
     */
    'parameters'?: Array<string>;
}
/**
 * the value of Analysis parameter for a Runner for this Run
 * @export
 * @interface RunTemplateParameterValue
 */
export interface RunTemplateParameterValue {
    /**
     * the parameter Id
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'parameterId': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'value': string;
}
/**
 * a description object for resource requests and limits (default same configuration as basic sizing)
 * @export
 * @interface RunTemplateResourceSizing
 */
export interface RunTemplateResourceSizing {
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunTemplateResourceSizing
     */
    'requests': ResourceSizeInfo;
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunTemplateResourceSizing
     */
    'limits': ResourceSizeInfo;
}
/**
 * the source local, cloud or git repository
 * @export
 * @enum {string}
 */

export const RunTemplateStepSource = {
    Cloud: 'cloud',
    Git: 'git',
    Local: 'local',
    Platform: 'platform'
} as const;

export type RunTemplateStepSource = typeof RunTemplateStepSource[keyof typeof RunTemplateStepSource];


/**
 * a Runner with base information
 * @export
 * @interface Runner
 */
export interface Runner {
    /**
     * the Runner unique identifier
     * @type {string}
     * @memberof Runner
     */
    'id'?: string;
    /**
     * the Runner name
     * @type {string}
     * @memberof Runner
     */
    'name'?: string;
    /**
     * the Runner description
     * @type {string}
     * @memberof Runner
     */
    'description'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Runner
     */
    'tags'?: Array<string>;
    /**
     * the Runner parent id
     * @type {string}
     * @memberof Runner
     */
    'parentId'?: string;
    /**
     * the user id which own this Runner
     * @type {string}
     * @memberof Runner
     */
    'ownerId'?: string;
    /**
     * the runner root id
     * @type {string}
     * @memberof Runner
     */
    'rootId'?: string;
    /**
     * the Solution Id associated with this Runner
     * @type {string}
     * @memberof Runner
     */
    'solutionId'?: string;
    /**
     * the Solution Run Template Id associated with this Runner
     * @type {string}
     * @memberof Runner
     */
    'runTemplateId'?: string;
    /**
     * the associated Organization Id
     * @type {string}
     * @memberof Runner
     */
    'organizationId'?: string;
    /**
     * the associated Workspace Id
     * @type {string}
     * @memberof Runner
     */
    'workspaceId'?: string;
    /**
     * the Runner creation date
     * @type {number}
     * @memberof Runner
     */
    'creationDate'?: number;
    /**
     * the last time a Runner was updated
     * @type {number}
     * @memberof Runner
     */
    'lastUpdate'?: number;
    /**
     * the name of the owner
     * @type {string}
     * @memberof Runner
     */
    'ownerName'?: string;
    /**
     * the Solution name
     * @type {string}
     * @memberof Runner
     */
    'solutionName'?: string;
    /**
     * the Solution Run Template name associated with this Runner
     * @type {string}
     * @memberof Runner
     */
    'runTemplateName'?: string;
    /**
     * the list of Dataset Id associated to this Runner Run Template
     * @type {Array<string>}
     * @memberof Runner
     */
    'datasetList'?: Array<string>;
    /**
     * 
     * @type {RunnerResourceSizing}
     * @memberof Runner
     */
    'runSizing'?: RunnerResourceSizing;
    /**
     * the list of Solution Run Template parameters values
     * @type {Array<RunnerRunTemplateParameterValue>}
     * @memberof Runner
     */
    'parametersValues'?: Array<RunnerRunTemplateParameterValue>;
    /**
     * last run id from current runner
     * @type {string}
     * @memberof Runner
     */
    'lastRunId'?: string;
    /**
     * 
     * @type {RunnerValidationStatus}
     * @memberof Runner
     */
    'validationStatus'?: RunnerValidationStatus;
    /**
     * 
     * @type {RunnerSecurity}
     * @memberof Runner
     */
    'security'?: RunnerSecurity;
}


/**
 * a Runner access control item
 * @export
 * @interface RunnerAccessControl
 */
export interface RunnerAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof RunnerAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof RunnerAccessControl
     */
    'role': string;
}
/**
 * a description object for resource requests and limits (default same configuration as basic sizing)
 * @export
 * @interface RunnerResourceSizing
 */
export interface RunnerResourceSizing {
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunnerResourceSizing
     */
    'requests': ResourceSizeInfo;
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunnerResourceSizing
     */
    'limits': ResourceSizeInfo;
}
/**
 * the Runner Role
 * @export
 * @interface RunnerRole
 */
export interface RunnerRole {
    /**
     * the Runner Role
     * @type {string}
     * @memberof RunnerRole
     */
    'role': string;
}
/**
 * the value of a Solution Run Template parameter for a Runner
 * @export
 * @interface RunnerRunTemplateParameterValue
 */
export interface RunnerRunTemplateParameterValue {
    /**
     * the parameter Id
     * @type {string}
     * @memberof RunnerRunTemplateParameterValue
     */
    'parameterId': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof RunnerRunTemplateParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value
     * @type {string}
     * @memberof RunnerRunTemplateParameterValue
     */
    'value': string;
    /**
     * whether or not the value is inherited from parent or has been changed
     * @type {boolean}
     * @memberof RunnerRunTemplateParameterValue
     */
    'isInherited'?: boolean;
}
/**
 * the Runner security information
 * @export
 * @interface RunnerSecurity
 */
export interface RunnerSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof RunnerSecurity
     */
    'default': string;
    /**
     * the list which can access this Runner with detailed access control information
     * @type {Array<RunnerAccessControl>}
     * @memberof RunnerSecurity
     */
    'accessControlList': Array<RunnerAccessControl>;
}
/**
 * the validation status of the runner
 * @export
 * @enum {string}
 */

export const RunnerValidationStatus = {
    Draft: 'Draft',
    Rejected: 'Rejected',
    Unknown: 'Unknown',
    Validated: 'Validated'
} as const;

export type RunnerValidationStatus = typeof RunnerValidationStatus[keyof typeof RunnerValidationStatus];


/**
 * 
 * @export
 * @interface SendRunDataRequest
 */
export interface SendRunDataRequest {
    /**
     * 
     * @type {string}
     * @memberof SendRunDataRequest
     */
    'id'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof SendRunDataRequest
     */
    'data'?: Array<{ [key: string]: any; }>;
}
/**
 * a version of a Solution
 * @export
 * @interface Solution
 */
export interface Solution {
    /**
     * the Solution version unique identifier
     * @type {string}
     * @memberof Solution
     */
    'id'?: string;
    /**
     * the Organization unique identifier
     * @type {string}
     * @memberof Solution
     */
    'organizationId'?: string;
    /**
     * the Solution key which group Solution versions
     * @type {string}
     * @memberof Solution
     */
    'key'?: string;
    /**
     * the Solution name
     * @type {string}
     * @memberof Solution
     */
    'name'?: string;
    /**
     * the Solution description
     * @type {string}
     * @memberof Solution
     */
    'description'?: string;
    /**
     * the registry repository containing the image
     * @type {string}
     * @memberof Solution
     */
    'repository'?: string;
    /**
     * set to true if the runtemplate wants to always pull the image
     * @type {boolean}
     * @memberof Solution
     */
    'alwaysPull'?: boolean;
    /**
     * the main Cosmo Tech simulator name used in standard Run Template
     * @type {string}
     * @memberof Solution
     */
    'csmSimulator'?: string;
    /**
     * the Solution version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof Solution
     */
    'version'?: string;
    /**
     * the User id which own this Solution
     * @type {string}
     * @memberof Solution
     */
    'ownerId'?: string;
    /**
     * the MAJOR.MINOR version used to build this solution
     * @type {string}
     * @memberof Solution
     */
    'sdkVersion'?: string;
    /**
     * an optional URL link to solution page
     * @type {string}
     * @memberof Solution
     */
    'url'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Solution
     */
    'tags'?: Array<string>;
    /**
     * the list of Run Template Parameters
     * @type {Array<RunTemplateParameter>}
     * @memberof Solution
     */
    'parameters'?: Array<RunTemplateParameter>;
    /**
     * the list of parameters groups for the Run Templates
     * @type {Array<RunTemplateParameterGroup>}
     * @memberof Solution
     */
    'parameterGroups'?: Array<RunTemplateParameterGroup>;
    /**
     * list of Run Template
     * @type {Array<RunTemplate>}
     * @memberof Solution
     */
    'runTemplates': Array<RunTemplate>;
    /**
     * 
     * @type {SolutionSecurity}
     * @memberof Solution
     */
    'security'?: SolutionSecurity;
}
/**
 * a Solution access control item
 * @export
 * @interface SolutionAccessControl
 */
export interface SolutionAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof SolutionAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof SolutionAccessControl
     */
    'role': string;
}
/**
 * the Solution Role
 * @export
 * @interface SolutionRole
 */
export interface SolutionRole {
    /**
     * the Solution Role
     * @type {string}
     * @memberof SolutionRole
     */
    'role': string;
}
/**
 * the Solution security information
 * @export
 * @interface SolutionSecurity
 */
export interface SolutionSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof SolutionSecurity
     */
    'default': string;
    /**
     * the list which can access this Solution with detailed access control information
     * @type {Array<SolutionAccessControl>}
     * @memberof SolutionSecurity
     */
    'accessControlList': Array<SolutionAccessControl>;
}
/**
 * Source job import information
 * @export
 * @interface SourceInfo
 */
export interface SourceInfo {
    /**
     * the source name containing the files to import
     * @type {string}
     * @memberof SourceInfo
     */
    'name'?: string;
    /**
     * the source location containing the files to import
     * @type {string}
     * @memberof SourceInfo
     */
    'location': string;
    /**
     * the source location containing the files to import
     * @type {string}
     * @memberof SourceInfo
     */
    'path'?: string;
    /**
     * indicate the last import jobId
     * @type {string}
     * @memberof SourceInfo
     */
    'jobId'?: string;
}
/**
 * a twin graph query in cypher language
 * @export
 * @interface SubDatasetGraphQuery
 */
export interface SubDatasetGraphQuery {
    /**
     * the name of the subdataset
     * @type {string}
     * @memberof SubDatasetGraphQuery
     */
    'name'?: string;
    /**
     * the description of the subdataset
     * @type {string}
     * @memberof SubDatasetGraphQuery
     */
    'description'?: string;
    /**
     * the query in cypher language
     * @type {Array<string>}
     * @memberof SubDatasetGraphQuery
     */
    'queries'?: Array<string>;
    /**
     * is this the main dataset
     * @type {boolean}
     * @memberof SubDatasetGraphQuery
     */
    'main'?: boolean;
}
/**
 * Processing result
 * @export
 * @interface TwinGraphBatchResult
 */
export interface TwinGraphBatchResult {
    /**
     * 
     * @type {number}
     * @memberof TwinGraphBatchResult
     */
    'totalLines': number;
    /**
     * 
     * @type {number}
     * @memberof TwinGraphBatchResult
     */
    'processedLines': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TwinGraphBatchResult
     */
    'errors': Array<string>;
}
/**
 * the twincache data status
 * @export
 * @enum {string}
 */

export const TwincacheStatusEnum = {
    Empty: 'EMPTY',
    Full: 'FULL'
} as const;

export type TwincacheStatusEnum = typeof TwincacheStatusEnum[keyof typeof TwincacheStatusEnum];


/**
 * a Workspace
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * Workspace unique identifier generated by the API
     * @type {string}
     * @memberof Workspace
     */
    'id'?: string;
    /**
     * Organization unique identifier under which the workspace resides
     * @type {string}
     * @memberof Workspace
     */
    'organizationId'?: string;
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof Workspace
     */
    'key': string;
    /**
     * Workspace name. This name is display in the sample webApp
     * @type {string}
     * @memberof Workspace
     */
    'name': string;
    /**
     * the Workspace description
     * @type {string}
     * @memberof Workspace
     */
    'description'?: string;
    /**
     * list of dataset linked to this dataset
     * @type {Array<string>}
     * @memberof Workspace
     */
    'linkedDatasetIdList'?: Array<string>;
    /**
     * the Workspace version MAJOR.MINOR.PATCH.
     * @type {string}
     * @memberof Workspace
     */
    'version'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Workspace
     */
    'tags'?: Array<string>;
    /**
     * the user id which own this workspace. set by the API from Authentification service receved id
     * @type {string}
     * @memberof Workspace
     */
    'ownerId'?: string;
    /**
     * 
     * @type {WorkspaceSolution}
     * @memberof Workspace
     */
    'solution': WorkspaceSolution;
    /**
     * 
     * @type {WorkspaceWebApp}
     * @memberof Workspace
     */
    'webApp'?: WorkspaceWebApp;
    /**
     * default setting for all Scenarios and Run Templates to set whether or not the Dataset values and the input parameters values are send to the DataWarehouse prior to the ScenarioRun
     * @type {boolean}
     * @memberof Workspace
     */
    'sendInputToDataWarehouse'?: boolean;
    /**
     * Set this property to true to use a dedicated Azure Event Hub Namespace for this Workspace. The Event Hub Namespace must be named \\\'<organization_id\\>-<workspace_id\\>\\\' (in lower case). This Namespace must also contain two Event Hubs named \\\'probesmeasures\\\' and \\\'scenariorun\\\'.
     * @type {boolean}
     * @memberof Workspace
     */
    'useDedicatedEventHubNamespace'?: boolean;
    /**
     * the Dedicated Event Hub SAS key name, default to RootManageSharedAccessKey. Ask you DevOps Team to add the associated value to your Workspace Secret
     * @type {string}
     * @memberof Workspace
     */
    'dedicatedEventHubSasKeyName'?: string;
    /**
     * the Event Hub authentication strategy, SHARED_ACCESS_POLICY or TENANT_CLIENT_CREDENTIALS. Default to the one defined for the tenant.
     * @type {string}
     * @memberof Workspace
     */
    'dedicatedEventHubAuthenticationStrategy'?: string;
    /**
     * default setting for all Scenarios and Run Templates to set whether or not the ScenarioRun is send to the Event Hub
     * @type {boolean}
     * @memberof Workspace
     */
    'sendScenarioRunToEventHub'?: boolean;
    /**
     * Set this property to false to not send scenario metada to Azure Event Hub Namespace for this Workspace. The Event Hub Namespace must be named \\\'<organization_id\\>-<workspace_id\\>\\\' (in lower case). This Namespace must also contain two Event Hubs named \\\'scenariometadata\\\' and \\\'scenariorunmetadata\\\'.
     * @type {boolean}
     * @memberof Workspace
     */
    'sendScenarioMetadataToEventHub'?: boolean;
    /**
     * Activate the copy of dataset on scenario creation, meaning that each scenario created in this workspace will make this copy. when false, scenario use directly the dataset specified.
     * @type {boolean}
     * @memberof Workspace
     */
    'datasetCopy'?: boolean;
    /**
     * 
     * @type {WorkspaceSecurity}
     * @memberof Workspace
     */
    'security'?: WorkspaceSecurity;
}
/**
 * a Workspace access control item
 * @export
 * @interface WorkspaceAccessControl
 */
export interface WorkspaceAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof WorkspaceAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof WorkspaceAccessControl
     */
    'role': string;
}
/**
 * a Workspace File resource
 * @export
 * @interface WorkspaceFile
 */
export interface WorkspaceFile {
    /**
     * the Workspace File name
     * @type {string}
     * @memberof WorkspaceFile
     */
    'fileName'?: string;
}
/**
 * the Workspace Role
 * @export
 * @interface WorkspaceRole
 */
export interface WorkspaceRole {
    /**
     * the Workspace Role
     * @type {string}
     * @memberof WorkspaceRole
     */
    'role': string;
}
/**
 * the workspace security information
 * @export
 * @interface WorkspaceSecurity
 */
export interface WorkspaceSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof WorkspaceSecurity
     */
    'default': string;
    /**
     * the list which can access this Workspace with detailed access control information
     * @type {Array<WorkspaceAccessControl>}
     * @memberof WorkspaceSecurity
     */
    'accessControlList': Array<WorkspaceAccessControl>;
}
/**
 * the Workspace Solution configuration
 * @export
 * @interface WorkspaceSolution
 */
export interface WorkspaceSolution {
    /**
     * the Solution Id attached to this workspace
     * @type {string}
     * @memberof WorkspaceSolution
     */
    'solutionId'?: string;
    /**
     * the list of Solution Run Template Id to filter
     * @type {Array<string>}
     * @memberof WorkspaceSolution
     */
    'runTemplateFilter'?: Array<string>;
    /**
     * a map of RunTemplateId/DatasetId to set a default dataset for a Run Template
     * @type {{ [key: string]: any; }}
     * @memberof WorkspaceSolution
     */
    'defaultRunTemplateDataset'?: { [key: string]: any; };
}
/**
 * a Workspace Web Application
 * @export
 * @interface WorkspaceWebApp
 */
export interface WorkspaceWebApp {
    /**
     * the Workspace Web Application URL
     * @type {string}
     * @memberof WorkspaceWebApp
     */
    'url': string;
    /**
     * a map of iframeKey/iframeURL
     * @type {{ [key: string]: any; }}
     * @memberof WorkspaceWebApp
     */
    'iframes'?: { [key: string]: any; };
    /**
     * free form options for Web Application
     * @type {{ [key: string]: any; }}
     * @memberof WorkspaceWebApp
     */
    'options'?: { [key: string]: any; };
}

/**
 * ConnectorApi - axios parameter creator
 * @export
 */
export const ConnectorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllConnectors: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findConnectorById: async (connectorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('findConnectorById', 'connectorId', connectorId)
            const localVarPath = `/connectors/{connector_id}`
                .replace(`{${"connector_id"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerConnector: async (connector: Connector, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connector' is not null or undefined
            assertParamExists('registerConnector', 'connector', connector)
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connector, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterConnector: async (connectorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('unregisterConnector', 'connectorId', connectorId)
            const localVarPath = `/connectors/{connector_id}`
                .replace(`{${"connector_id"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorApi - functional programming interface
 * @export
 */
export const ConnectorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllConnectors(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Connector>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllConnectors(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorApi.findAllConnectors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findConnectorById(connectorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findConnectorById(connectorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorApi.findConnectorById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerConnector(connector: Connector, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerConnector(connector, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorApi.registerConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unregisterConnector(connectorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unregisterConnector(connectorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorApi.unregisterConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectorApi - factory interface
 * @export
 */
export const ConnectorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllConnectors(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Connector>> {
            return localVarFp.findAllConnectors(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findConnectorById(connectorId: string, options?: RawAxiosRequestConfig): AxiosPromise<Connector> {
            return localVarFp.findConnectorById(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerConnector(connector: Connector, options?: RawAxiosRequestConfig): AxiosPromise<Connector> {
            return localVarFp.registerConnector(connector, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterConnector(connectorId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unregisterConnector(connectorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorApi - object-oriented interface
 * @export
 * @class ConnectorApi
 * @extends {BaseAPI}
 */
export class ConnectorApi extends BaseAPI {
    /**
     * 
     * @summary List all Connectors
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public findAllConnectors(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).findAllConnectors(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a connector
     * @param {string} connectorId the Connector identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public findConnectorById(connectorId: string, options?: RawAxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).findConnectorById(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new connector
     * @param {Connector} connector the Connector to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public registerConnector(connector: Connector, options?: RawAxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).registerConnector(connector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unregister a connector
     * @param {string} connectorId the Connector identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public unregisterConnector(connectorId: string, options?: RawAxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).unregisterConnector(connectorId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatasetApi - axios parameter creator
 * @export
 */
export const DatasetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a control access to the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDatasetAccessControl: async (organizationId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('addDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'datasetAccessControl' is not null or undefined
            assertParamExists('addDatasetAccessControl', 'datasetAccessControl', datasetAccessControl)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceDatasetCompatibilityElements: async (organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'datasetId', datasetId)
            // verify required parameter 'datasetCompatibility' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'datasetCompatibility', datasetCompatibility)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/compatibility`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetCompatibility, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Not implemented!
         * @summary Copy a Dataset to another Dataset.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyDataset: async (organizationId: string, datasetCopyParameters: DatasetCopyParameters, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('copyDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetCopyParameters' is not null or undefined
            assertParamExists('copyDataset', 'datasetCopyParameters', datasetCopyParameters)
            const localVarPath = `/organizations/{organization_id}/datasets/copy`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetCopyParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset: async (organizationId: string, dataset: Dataset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createDataset', 'organizationId', organizationId)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('createDataset', 'dataset', dataset)
            const localVarPath = `/organizations/{organization_id}/datasets`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a copy of the dataset using the results of the list of queries given in parameter.
         * @summary Create a sub-dataset from the dataset in parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {SubDatasetGraphQuery} subDatasetGraphQuery the Cypher query to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubDataset: async (organizationId: string, datasetId: string, subDatasetGraphQuery: SubDatasetGraphQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSubDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('createSubDataset', 'datasetId', datasetId)
            // verify required parameter 'subDatasetGraphQuery' is not null or undefined
            assertParamExists('createSubDataset', 'subDatasetGraphQuery', subDatasetGraphQuery)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/subdataset`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subDatasetGraphQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create new entities in a graph instance
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {CreateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTwingraphEntities: async (organizationId: string, datasetId: string, type: CreateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createTwingraphEntities', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('createTwingraphEntities', 'datasetId', datasetId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createTwingraphEntities', 'type', type)
            // verify required parameter 'graphProperties' is not null or undefined
            assertParamExists('createTwingraphEntities', 'graphProperties', graphProperties)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(graphProperties, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteDataset', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete entities in a graph instance
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DeleteTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTwingraphEntities: async (organizationId: string, datasetId: string, type: DeleteTwingraphEntitiesTypeEnum, ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteTwingraphEntities', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteTwingraphEntities', 'datasetId', datasetId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteTwingraphEntities', 'type', type)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteTwingraphEntities', 'ids', ids)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download the compressed graph reference by the hash in a zip file
         * @summary Download a graph as a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTwingraph: async (organizationId: string, hash: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadTwingraph', 'organizationId', organizationId)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('downloadTwingraph', 'hash', hash)
            const localVarPath = `/organizations/{organization_id}/datasets/twingraph/download/{hash}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDatasets: async (organizationId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllDatasets', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/datasets`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDatasetById: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findDatasetById', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('findDatasetById', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetAccessControl: async (organizationId: string, datasetId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getDatasetAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Dataset security information
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetSecurity: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetSecurity', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetSecurity', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Dataset security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetSecurityUsers: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetSecurityUsers', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of the import workflow lauch on the dataset\'s refresh. This endpoint needs to be called to update a dataset IngestionStatus or TwincacheStatus
         * @summary Get the dataset\'s refresh job status
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetTwingraphStatus: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetTwingraphStatus', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetTwingraphStatus', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/status`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get entities in a graph instance
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {GetTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwingraphEntities: async (organizationId: string, datasetId: string, type: GetTwingraphEntitiesTypeEnum, ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getTwingraphEntities', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getTwingraphEntities', 'datasetId', datasetId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getTwingraphEntities', 'type', type)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getTwingraphEntities', 'ids', ids)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkWorkspace: async (organizationId: string, datasetId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('linkWorkspace', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('linkWorkspace', 'datasetId', datasetId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('linkWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/link`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh dataset from parent source. At date, sources can be:      dataset (refresh from another dataset)      Azure Digital twin      Azure storage      Local File (import a new file)  During refresh, datas are overwritten 
         * @summary Refresh data on dataset from dataset\'s source
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshDataset: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('refreshDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('refreshDataset', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/refresh`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllDatasetCompatibilityElements: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllDatasetCompatibilityElements', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('removeAllDatasetCompatibilityElements', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/compatibility`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatasetAccessControl: async (organizationId: string, datasetId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('removeDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeDatasetAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rollback the twingraph on a dataset after a failed refresh
         * @summary Rollback the dataset after a failed refresh
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackRefresh: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('rollbackRefresh', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('rollbackRefresh', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/refresh/rollback`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Datasets by tags
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDatasets: async (organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('searchDatasets', 'organizationId', organizationId)
            // verify required parameter 'datasetSearch' is not null or undefined
            assertParamExists('searchDatasets', 'datasetSearch', datasetSearch)
            const localVarPath = `/organizations/{organization_id}/datasets/search`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Dataset default security
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDatasetDefaultSecurity: async (organizationId: string, datasetId: string, datasetRole: DatasetRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setDatasetDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('setDatasetDefaultSecurity', 'datasetId', datasetId)
            // verify required parameter 'datasetRole' is not null or undefined
            assertParamExists('setDatasetDefaultSecurity', 'datasetRole', datasetRole)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Graph Identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphBatchQuery: async (organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('twingraphBatchQuery', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('twingraphBatchQuery', 'datasetId', datasetId)
            // verify required parameter 'datasetTwinGraphQuery' is not null or undefined
            assertParamExists('twingraphBatchQuery', 'datasetTwinGraphQuery', datasetTwinGraphQuery)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/batch-query`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetTwinGraphQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Async batch update by loading a CSV file on a graph instance 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DatasetTwinGraphQuery} twinGraphQuery 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphBatchUpdate: async (organizationId: string, datasetId: string, twinGraphQuery: DatasetTwinGraphQuery, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('twingraphBatchUpdate', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('twingraphBatchUpdate', 'datasetId', datasetId)
            // verify required parameter 'twinGraphQuery' is not null or undefined
            assertParamExists('twingraphBatchUpdate', 'twinGraphQuery', twinGraphQuery)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('twingraphBatchUpdate', 'body', body)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/batch`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (twinGraphQuery !== undefined) {
                for (const [key, value] of Object.entries(twinGraphQuery)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/csv';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a query on a graph instance and return the result as a json
         * @summary Return the result of a query made on the graph instance as a json
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphQuery: async (organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('twingraphQuery', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('twingraphQuery', 'datasetId', datasetId)
            // verify required parameter 'datasetTwinGraphQuery' is not null or undefined
            assertParamExists('twingraphQuery', 'datasetTwinGraphQuery', datasetTwinGraphQuery)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetTwinGraphQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkWorkspace: async (organizationId: string, datasetId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('unlinkWorkspace', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('unlinkWorkspace', 'datasetId', datasetId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('unlinkWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/unlink`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset: async (organizationId: string, datasetId: string, dataset: Dataset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateDataset', 'datasetId', datasetId)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('updateDataset', 'dataset', dataset)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {DatasetRole} datasetRole The new Dataset Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatasetAccessControl: async (organizationId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'identityId', identityId)
            // verify required parameter 'datasetRole' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'datasetRole', datasetRole)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {UpdateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTwingraphEntities: async (organizationId: string, datasetId: string, type: UpdateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateTwingraphEntities', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateTwingraphEntities', 'datasetId', datasetId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('updateTwingraphEntities', 'type', type)
            // verify required parameter 'graphProperties' is not null or undefined
            assertParamExists('updateTwingraphEntities', 'graphProperties', graphProperties)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(graphProperties, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. 
         * @summary Upload data from zip file to dataset\'s twingraph
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTwingraph: async (organizationId: string, datasetId: string, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('uploadTwingraph', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('uploadTwingraph', 'datasetId', datasetId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadTwingraph', 'body', body)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetApi - functional programming interface
 * @export
 */
export const DatasetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDatasetAccessControl(organizationId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDatasetAccessControl(organizationId, datasetId, datasetAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.addDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DatasetCompatibility>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.addOrReplaceDatasetCompatibilityElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Not implemented!
         * @summary Copy a Dataset to another Dataset.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetCopyParameters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyDataset(organizationId, datasetCopyParameters, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.copyDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataset(organizationId: string, dataset: Dataset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataset(organizationId, dataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a copy of the dataset using the results of the list of queries given in parameter.
         * @summary Create a sub-dataset from the dataset in parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {SubDatasetGraphQuery} subDatasetGraphQuery the Cypher query to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubDataset(organizationId: string, datasetId: string, subDatasetGraphQuery: SubDatasetGraphQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubDataset(organizationId, datasetId, subDatasetGraphQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createSubDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * create new entities in a graph instance
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {CreateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTwingraphEntities(organizationId: string, datasetId: string, type: CreateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTwingraphEntities(organizationId, datasetId, type, graphProperties, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createTwingraphEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataset(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.deleteDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * delete entities in a graph instance
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DeleteTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTwingraphEntities(organizationId: string, datasetId: string, type: DeleteTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTwingraphEntities(organizationId, datasetId, type, ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.deleteTwingraphEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download the compressed graph reference by the hash in a zip file
         * @summary Download a graph as a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTwingraph(organizationId: string, hash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTwingraph(organizationId, hash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.downloadTwingraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllDatasets(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllDatasets(organizationId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.findAllDatasets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDatasetById(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDatasetById(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.findDatasetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetAccessControl(organizationId, datasetId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Dataset security information
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetSecurity(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetSecurity(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Dataset security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetSecurityUsers(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetSecurityUsers(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the status of the import workflow lauch on the dataset\'s refresh. This endpoint needs to be called to update a dataset IngestionStatus or TwincacheStatus
         * @summary Get the dataset\'s refresh job status
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetTwingraphStatus(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetTwingraphStatus(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetTwingraphStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * get entities in a graph instance
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {GetTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTwingraphEntities(organizationId: string, datasetId: string, type: GetTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTwingraphEntities(organizationId, datasetId, type, ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getTwingraphEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkWorkspace(organizationId, datasetId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.linkWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refresh dataset from parent source. At date, sources can be:      dataset (refresh from another dataset)      Azure Digital twin      Azure storage      Local File (import a new file)  During refresh, datas are overwritten 
         * @summary Refresh data on dataset from dataset\'s source
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetTwinGraphInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshDataset(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.refreshDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllDatasetCompatibilityElements(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.removeAllDatasetCompatibilityElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDatasetAccessControl(organizationId, datasetId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.removeDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rollback the twingraph on a dataset after a failed refresh
         * @summary Rollback the dataset after a failed refresh
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rollbackRefresh(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rollbackRefresh(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.rollbackRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Datasets by tags
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDatasets(organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDatasets(organizationId, datasetSearch, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.searchDatasets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Dataset default security
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDatasetDefaultSecurity(organizationId: string, datasetId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDatasetDefaultSecurity(organizationId, datasetId, datasetRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.setDatasetDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Graph Identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async twingraphBatchQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetTwinGraphHash>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.twingraphBatchQuery(organizationId, datasetId, datasetTwinGraphQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.twingraphBatchQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Async batch update by loading a CSV file on a graph instance 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DatasetTwinGraphQuery} twinGraphQuery 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async twingraphBatchUpdate(organizationId: string, datasetId: string, twinGraphQuery: DatasetTwinGraphQuery, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwinGraphBatchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.twingraphBatchUpdate(organizationId, datasetId, twinGraphQuery, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.twingraphBatchUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Run a query on a graph instance and return the result as a json
         * @summary Return the result of a query made on the graph instance as a json
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async twingraphQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.twingraphQuery(organizationId, datasetId, datasetTwinGraphQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.twingraphQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkWorkspace(organizationId, datasetId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.unlinkWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataset(organizationId, datasetId, dataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {DatasetRole} datasetRole The new Dataset Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDatasetAccessControl(organizationId, datasetId, identityId, datasetRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {UpdateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTwingraphEntities(organizationId: string, datasetId: string, type: UpdateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTwingraphEntities(organizationId, datasetId, type, graphProperties, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateTwingraphEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. 
         * @summary Upload data from zip file to dataset\'s twingraph
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadTwingraph(organizationId: string, datasetId: string, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadValidation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadTwingraph(organizationId, datasetId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.uploadTwingraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatasetApi - factory interface
 * @export
 */
export const DatasetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDatasetAccessControl(organizationId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<DatasetAccessControl> {
            return localVarFp.addDatasetAccessControl(organizationId, datasetId, datasetAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: RawAxiosRequestConfig): AxiosPromise<Array<DatasetCompatibility>> {
            return localVarFp.addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options).then((request) => request(axios, basePath));
        },
        /**
         * Not implemented!
         * @summary Copy a Dataset to another Dataset.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: RawAxiosRequestConfig): AxiosPromise<DatasetCopyParameters> {
            return localVarFp.copyDataset(organizationId, datasetCopyParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset(organizationId: string, dataset: Dataset, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.createDataset(organizationId, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a copy of the dataset using the results of the list of queries given in parameter.
         * @summary Create a sub-dataset from the dataset in parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {SubDatasetGraphQuery} subDatasetGraphQuery the Cypher query to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubDataset(organizationId: string, datasetId: string, subDatasetGraphQuery: SubDatasetGraphQuery, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.createSubDataset(organizationId, datasetId, subDatasetGraphQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * create new entities in a graph instance
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {CreateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTwingraphEntities(organizationId: string, datasetId: string, type: CreateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createTwingraphEntities(organizationId, datasetId, type, graphProperties, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDataset(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete entities in a graph instance
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DeleteTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTwingraphEntities(organizationId: string, datasetId: string, type: DeleteTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTwingraphEntities(organizationId, datasetId, type, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Download the compressed graph reference by the hash in a zip file
         * @summary Download a graph as a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTwingraph(organizationId: string, hash: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadTwingraph(organizationId, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDatasets(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Dataset>> {
            return localVarFp.findAllDatasets(organizationId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDatasetById(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.findDatasetById(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<DatasetAccessControl> {
            return localVarFp.getDatasetAccessControl(organizationId, datasetId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Dataset security information
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetSecurity(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<DatasetSecurity> {
            return localVarFp.getDatasetSecurity(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Dataset security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetSecurityUsers(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getDatasetSecurityUsers(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of the import workflow lauch on the dataset\'s refresh. This endpoint needs to be called to update a dataset IngestionStatus or TwincacheStatus
         * @summary Get the dataset\'s refresh job status
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetTwingraphStatus(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getDatasetTwingraphStatus(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * get entities in a graph instance
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {GetTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwingraphEntities(organizationId: string, datasetId: string, type: GetTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getTwingraphEntities(organizationId, datasetId, type, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.linkWorkspace(organizationId, datasetId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh dataset from parent source. At date, sources can be:      dataset (refresh from another dataset)      Azure Digital twin      Azure storage      Local File (import a new file)  During refresh, datas are overwritten 
         * @summary Refresh data on dataset from dataset\'s source
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<DatasetTwinGraphInfo> {
            return localVarFp.refreshDataset(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeAllDatasetCompatibilityElements(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeDatasetAccessControl(organizationId, datasetId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rollback the twingraph on a dataset after a failed refresh
         * @summary Rollback the dataset after a failed refresh
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackRefresh(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.rollbackRefresh(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Datasets by tags
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDatasets(organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Dataset>> {
            return localVarFp.searchDatasets(organizationId, datasetSearch, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Dataset default security
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDatasetDefaultSecurity(organizationId: string, datasetId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig): AxiosPromise<DatasetSecurity> {
            return localVarFp.setDatasetDefaultSecurity(organizationId, datasetId, datasetRole, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Graph Identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphBatchQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig): AxiosPromise<DatasetTwinGraphHash> {
            return localVarFp.twingraphBatchQuery(organizationId, datasetId, datasetTwinGraphQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Async batch update by loading a CSV file on a graph instance 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DatasetTwinGraphQuery} twinGraphQuery 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphBatchUpdate(organizationId: string, datasetId: string, twinGraphQuery: DatasetTwinGraphQuery, body: File, options?: RawAxiosRequestConfig): AxiosPromise<TwinGraphBatchResult> {
            return localVarFp.twingraphBatchUpdate(organizationId, datasetId, twinGraphQuery, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a query on a graph instance and return the result as a json
         * @summary Return the result of a query made on the graph instance as a json
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.twingraphQuery(organizationId, datasetId, datasetTwinGraphQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.unlinkWorkspace(organizationId, datasetId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.updateDataset(organizationId, datasetId, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {DatasetRole} datasetRole The new Dataset Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig): AxiosPromise<DatasetAccessControl> {
            return localVarFp.updateDatasetAccessControl(organizationId, datasetId, identityId, datasetRole, options).then((request) => request(axios, basePath));
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {UpdateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTwingraphEntities(organizationId: string, datasetId: string, type: UpdateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.updateTwingraphEntities(organizationId, datasetId, type, graphProperties, options).then((request) => request(axios, basePath));
        },
        /**
         * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. 
         * @summary Upload data from zip file to dataset\'s twingraph
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTwingraph(organizationId: string, datasetId: string, body: File, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadValidation> {
            return localVarFp.uploadTwingraph(organizationId, datasetId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetApi - object-oriented interface
 * @export
 * @class DatasetApi
 * @extends {BaseAPI}
 */
export class DatasetApi extends BaseAPI {
    /**
     * 
     * @summary Add a control access to the Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public addDatasetAccessControl(organizationId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).addDatasetAccessControl(organizationId, datasetId, datasetAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Dataset Compatibility elements.
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Not implemented!
     * @summary Copy a Dataset to another Dataset.
     * @param {string} organizationId the Organization identifier
     * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).copyDataset(organizationId, datasetCopyParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Dataset
     * @param {string} organizationId the Organization identifier
     * @param {Dataset} dataset the Dataset to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createDataset(organizationId: string, dataset: Dataset, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createDataset(organizationId, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a copy of the dataset using the results of the list of queries given in parameter.
     * @summary Create a sub-dataset from the dataset in parameter
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {SubDatasetGraphQuery} subDatasetGraphQuery the Cypher query to filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createSubDataset(organizationId: string, datasetId: string, subDatasetGraphQuery: SubDatasetGraphQuery, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createSubDataset(organizationId, datasetId, subDatasetGraphQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create new entities in a graph instance
     * @summary Create new entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {CreateTwingraphEntitiesTypeEnum} type the entity model type
     * @param {Array<GraphProperties>} graphProperties the entities to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createTwingraphEntities(organizationId: string, datasetId: string, type: CreateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createTwingraphEntities(organizationId, datasetId, type, graphProperties, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteDataset(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete entities in a graph instance
     * @summary Delete entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {DeleteTwingraphEntitiesTypeEnum} type the entity model type
     * @param {Array<string>} ids the entities to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteTwingraphEntities(organizationId: string, datasetId: string, type: DeleteTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteTwingraphEntities(organizationId, datasetId, type, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download the compressed graph reference by the hash in a zip file
     * @summary Download a graph as a zip file
     * @param {string} organizationId the Organization identifier
     * @param {string} hash the Graph download identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public downloadTwingraph(organizationId: string, hash: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).downloadTwingraph(organizationId, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Datasets
     * @param {string} organizationId the Organization identifier
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public findAllDatasets(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).findAllDatasets(organizationId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public findDatasetById(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).findDatasetById(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetAccessControl(organizationId, datasetId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Dataset security information
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetSecurity(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetSecurity(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Dataset security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetSecurityUsers(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetSecurityUsers(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of the import workflow lauch on the dataset\'s refresh. This endpoint needs to be called to update a dataset IngestionStatus or TwincacheStatus
     * @summary Get the dataset\'s refresh job status
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetTwingraphStatus(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetTwingraphStatus(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get entities in a graph instance
     * @summary Get entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {GetTwingraphEntitiesTypeEnum} type the entity model type
     * @param {Array<string>} ids the entities to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getTwingraphEntities(organizationId: string, datasetId: string, type: GetTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getTwingraphEntities(organizationId, datasetId, type, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} workspaceId workspace id to be linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public linkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).linkWorkspace(organizationId, datasetId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh dataset from parent source. At date, sources can be:      dataset (refresh from another dataset)      Azure Digital twin      Azure storage      Local File (import a new file)  During refresh, datas are overwritten 
     * @summary Refresh data on dataset from dataset\'s source
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public refreshDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).refreshDataset(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Dataset Compatibility elements from the Dataset specified
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).removeAllDatasetCompatibilityElements(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public removeDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).removeDatasetAccessControl(organizationId, datasetId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rollback the twingraph on a dataset after a failed refresh
     * @summary Rollback the dataset after a failed refresh
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public rollbackRefresh(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).rollbackRefresh(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Datasets by tags
     * @param {string} organizationId the Organization identifier
     * @param {DatasetSearch} datasetSearch the Dataset search parameters
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public searchDatasets(organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).searchDatasets(organizationId, datasetSearch, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Dataset default security
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public setDatasetDefaultSecurity(organizationId: string, datasetId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).setDatasetDefaultSecurity(organizationId, datasetId, datasetRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a query on a graph instance and return the result as a zip file in async mode
     * @summary Run a query on a graph instance and return the result as a zip file in async mode
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Graph Identifier
     * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public twingraphBatchQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).twingraphBatchQuery(organizationId, datasetId, datasetTwinGraphQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Async batch update by loading a CSV file on a graph instance 
     * @summary Async batch update by loading a CSV file on a graph instance 
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {DatasetTwinGraphQuery} twinGraphQuery 
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public twingraphBatchUpdate(organizationId: string, datasetId: string, twinGraphQuery: DatasetTwinGraphQuery, body: File, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).twingraphBatchUpdate(organizationId, datasetId, twinGraphQuery, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a query on a graph instance and return the result as a json
     * @summary Return the result of a query made on the graph instance as a json
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public twingraphQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).twingraphQuery(organizationId, datasetId, datasetTwinGraphQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} workspaceId workspace id to be linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public unlinkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).unlinkWorkspace(organizationId, datasetId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {Dataset} dataset the new Dataset details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateDataset(organizationId, datasetId, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} identityId the User identifier
     * @param {DatasetRole} datasetRole The new Dataset Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateDatasetAccessControl(organizationId, datasetId, identityId, datasetRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update entities in a graph instance
     * @summary Update entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {UpdateTwingraphEntitiesTypeEnum} type the entity model type
     * @param {Array<GraphProperties>} graphProperties the entities to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateTwingraphEntities(organizationId: string, datasetId: string, type: UpdateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateTwingraphEntities(organizationId, datasetId, type, graphProperties, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. 
     * @summary Upload data from zip file to dataset\'s twingraph
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public uploadTwingraph(organizationId: string, datasetId: string, body: File, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).uploadTwingraph(organizationId, datasetId, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CreateTwingraphEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type CreateTwingraphEntitiesTypeEnum = typeof CreateTwingraphEntitiesTypeEnum[keyof typeof CreateTwingraphEntitiesTypeEnum];
/**
 * @export
 */
export const DeleteTwingraphEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type DeleteTwingraphEntitiesTypeEnum = typeof DeleteTwingraphEntitiesTypeEnum[keyof typeof DeleteTwingraphEntitiesTypeEnum];
/**
 * @export
 */
export const GetTwingraphEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type GetTwingraphEntitiesTypeEnum = typeof GetTwingraphEntitiesTypeEnum[keyof typeof GetTwingraphEntitiesTypeEnum];
/**
 * @export
 */
export const UpdateTwingraphEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type UpdateTwingraphEntitiesTypeEnum = typeof UpdateTwingraphEntitiesTypeEnum[keyof typeof UpdateTwingraphEntitiesTypeEnum];


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationAccessControl: async (organizationId: string, organizationAccessControl: OrganizationAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'organizationAccessControl' is not null or undefined
            assertParamExists('addOrganizationAccessControl', 'organizationAccessControl', organizationAccessControl)
            const localVarPath = `/organizations/{organization_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrganizations: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganizationById: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findOrganizationById', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAccessControl: async (organizationId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getOrganizationAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationPermissions: async (organizationId: string, role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationPermissions', 'organizationId', organizationId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getOrganizationPermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurity: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationSecurity', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurityUsers: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationSecurityUsers', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new organization
         * @param {Organization} organization the Organization to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOrganization: async (organization: Organization, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('registerOrganization', 'organization', organization)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationAccessControl: async (organizationId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeOrganizationAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Organization default security
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationDefaultSecurity: async (organizationId: string, organizationRole: OrganizationRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setOrganizationDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'organizationRole' is not null or undefined
            assertParamExists('setOrganizationDefaultSecurity', 'organizationRole', organizationRole)
            const localVarPath = `/organizations/{organization_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unregister an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterOrganization: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('unregisterOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {Organization} organization the new Organization details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (organizationId: string, organization: Organization, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganization', 'organizationId', organizationId)
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('updateOrganization', 'organization', organization)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationAccessControl: async (organizationId: string, identityId: string, organizationRole: OrganizationRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'identityId', identityId)
            // verify required parameter 'organizationRole' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'organizationRole', organizationRole)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrganizationAccessControl(organizationId, organizationAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.addOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllOrganizations(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllOrganizations(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.findAllOrganizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOrganizationById(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOrganizationById(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.findOrganizationById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ComponentRolePermissions>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getAllPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationAccessControl(organizationId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationPermissions(organizationId: string, role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationPermissions(organizationId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationSecurity(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationSecurity(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationSecurityUsers(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationSecurityUsers(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new organization
         * @param {Organization} organization the Organization to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerOrganization(organization: Organization, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerOrganization(organization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.registerOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeOrganizationAccessControl(organizationId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.removeOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Organization default security
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOrganizationDefaultSecurity(organizationId, organizationRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.setOrganizationDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unregister an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unregisterOrganization(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unregisterOrganization(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.unregisterOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {Organization} organization the new Organization details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(organizationId: string, organization: Organization, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(organizationId, organization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationAccessControl(organizationId, identityId, organizationRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.addOrganizationAccessControl(organizationId, organizationAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrganizations(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Organization>> {
            return localVarFp.findAllOrganizations(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganizationById(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.findOrganizationById(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPermissions(options?: RawAxiosRequestConfig): AxiosPromise<Array<ComponentRolePermissions>> {
            return localVarFp.getAllPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.getOrganizationAccessControl(organizationId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationPermissions(organizationId: string, role: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getOrganizationPermissions(organizationId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurity(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationSecurity> {
            return localVarFp.getOrganizationSecurity(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurityUsers(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getOrganizationSecurityUsers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new organization
         * @param {Organization} organization the Organization to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOrganization(organization: Organization, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.registerOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeOrganizationAccessControl(organizationId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Organization default security
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationSecurity> {
            return localVarFp.setOrganizationDefaultSecurity(organizationId, organizationRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unregister an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterOrganization(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unregisterOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {Organization} organization the new Organization details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organizationId: string, organization: Organization, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.updateOrganization(organizationId, organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.updateOrganizationAccessControl(organizationId, identityId, organizationRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * 
     * @summary Add a control access to the Organization
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public addOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).addOrganizationAccessControl(organizationId, organizationAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Organizations
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public findAllOrganizations(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).findAllOrganizations(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an Organization
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public findOrganizationById(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).findOrganizationById(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all permissions per components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getAllPermissions(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getAllPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Organization
     * @param {string} organizationId the Organization identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationAccessControl(organizationId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization permissions by given role
     * @param {string} organizationId the Organization identifier
     * @param {string} role the Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationPermissions(organizationId: string, role: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationPermissions(organizationId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization security information
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationSecurity(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationSecurity(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization security users list
     * @param {string} organizationId The Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationSecurityUsers(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationSecurityUsers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new organization
     * @param {Organization} organization the Organization to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public registerOrganization(organization: Organization, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).registerOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization
     * @param {string} organizationId the Organization identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public removeOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).removeOrganizationAccessControl(organizationId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Organization default security
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public setOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).setOrganizationDefaultSecurity(organizationId, organizationRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unregister an organization
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public unregisterOrganization(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).unregisterOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an Organization
     * @param {string} organizationId the Organization identifier
     * @param {Organization} organization the new Organization details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganization(organizationId: string, organization: Organization, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganization(organizationId, organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for an Organization
     * @param {string} organizationId the Organization identifier
     * @param {string} identityId the User identifier
     * @param {OrganizationRole} organizationRole The new Organization Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganizationAccessControl(organizationId, identityId, organizationRole, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RunApi - axios parameter creator
 * @export
 */
export const RunApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('deleteRun', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('deleteRun', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRun', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRun', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the logs for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogs: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunLogs', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunLogs', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunLogs', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRunLogs', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/logs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the status for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatus: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunStatus', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunStatus', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunStatus', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRunStatus', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/status`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the list of Runs for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns: async (organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listRuns', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listRuns', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('listRuns', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary query the run data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {RunDataQuery} runDataQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryRunData: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('queryRunData', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('queryRunData', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('queryRunData', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('queryRunData', 'runId', runId)
            // verify required parameter 'runDataQuery' is not null or undefined
            assertParamExists('queryRunData', 'runDataQuery', runDataQuery)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/data/query`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runDataQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send data associated to a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRunData: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('sendRunData', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('sendRunData', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('sendRunData', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('sendRunData', 'runId', runId)
            // verify required parameter 'sendRunDataRequest' is not null or undefined
            assertParamExists('sendRunData', 'sendRunDataRequest', sendRunDataRequest)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/data/send`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendRunDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunApi - functional programming interface
 * @export
 */
export const RunApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRun(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.deleteRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Run>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRun(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.getRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the logs for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunLogs(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunLogs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunLogs(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.getRunLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the status for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunStatus(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunStatus(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.getRunStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the list of Runs for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuns(organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Run>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuns(organizationId, workspaceId, runnerId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.listRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary query the run data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {RunDataQuery} runDataQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryRunData(organizationId, workspaceId, runnerId, runId, runDataQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.queryRunData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send data associated to a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendRunData(organizationId, workspaceId, runnerId, runId, sendRunDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.sendRunData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RunApi - factory interface
 * @export
 */
export const RunApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): AxiosPromise<Run> {
            return localVarFp.getRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the logs for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogs(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunLogs> {
            return localVarFp.getRunLogs(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the status for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatus(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunStatus> {
            return localVarFp.getRunStatus(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the list of Runs for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Run>> {
            return localVarFp.listRuns(organizationId, workspaceId, runnerId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary query the run data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {RunDataQuery} runDataQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options?: RawAxiosRequestConfig): AxiosPromise<QueryResult> {
            return localVarFp.queryRunData(organizationId, workspaceId, runnerId, runId, runDataQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send data associated to a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunData> {
            return localVarFp.sendRunData(organizationId, workspaceId, runnerId, runId, sendRunDataRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunApi - object-oriented interface
 * @export
 * @class RunApi
 * @extends {BaseAPI}
 */
export class RunApi extends BaseAPI {
    /**
     * 
     * @summary Delete a run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public deleteRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).deleteRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public getRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).getRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the logs for the Run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public getRunLogs(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).getRunLogs(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the status for the Run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public getRunStatus(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).getRunStatus(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the list of Runs for the Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public listRuns(organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).listRuns(organizationId, workspaceId, runnerId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary query the run data
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {RunDataQuery} runDataQuery the query to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public queryRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).queryRunData(organizationId, workspaceId, runnerId, runId, runDataQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send data associated to a run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public sendRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).sendRunData(organizationId, workspaceId, runnerId, runId, sendRunDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RunnerApi - axios parameter creator
 * @export
 */
export const RunnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a control access to the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('addRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'runnerAccessControl' is not null or undefined
            assertParamExists('addRunnerAccessControl', 'runnerAccessControl', runnerAccessControl)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Runner} runner the Runner to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunner: async (organizationId: string, workspaceId: string, runner: Runner, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runner' is not null or undefined
            assertParamExists('createRunner', 'runner', runner)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunner: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('deleteRunner', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunner: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunner', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Runner permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerPermissions: async (organizationId: string, workspaceId: string, runnerId: string, role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerPermissions', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunnerPermissions', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerPermissions', 'runnerId', runnerId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getRunnerPermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Runner security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerSecurity: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunnerSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerSecurity', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Runner security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerSecurityUsers: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunnerSecurityUsers', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerSecurityUsers', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Runners
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunners: async (organizationId: string, workspaceId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listRunners', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listRunners', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('removeRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeRunnerAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Runner default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRunnerDefaultSecurity: async (organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setRunnerDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('setRunnerDefaultSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('setRunnerDefaultSecurity', 'runnerId', runnerId)
            // verify required parameter 'runnerRole' is not null or undefined
            assertParamExists('setRunnerDefaultSecurity', 'runnerRole', runnerRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a run with runner parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRun: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('startRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('startRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('startRun', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/start`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop the last run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('stopRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('stopRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('stopRun', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/stop`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {Runner} runner the new Runner details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunner: async (organizationId: string, workspaceId: string, runnerId: string, runner: Runner, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('updateRunner', 'runnerId', runnerId)
            // verify required parameter 'runner' is not null or undefined
            assertParamExists('updateRunner', 'runner', runner)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {RunnerRole} runnerRole The new Runner Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'identityId', identityId)
            // verify required parameter 'runnerRole' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'runnerRole', runnerRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunnerApi - functional programming interface
 * @export
 */
export const RunnerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunnerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRunnerAccessControl(organizationId, workspaceId, runnerId, runnerAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.addRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Runner} runner the Runner to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRunner(organizationId: string, workspaceId: string, runner: Runner, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Runner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRunner(organizationId, workspaceId, runner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.createRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRunner(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.deleteRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of an runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Runner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunner(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Runner permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerPermissions(organizationId: string, workspaceId: string, runnerId: string, role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerPermissions(organizationId, workspaceId, runnerId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunnerPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Runner security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerSecurity(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerSecurity(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunnerSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Runner security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerSecurityUsers(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerSecurityUsers(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunnerSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Runners
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRunners(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Runner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRunners(organizationId, workspaceId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.listRunners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.removeRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Runner default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRunnerDefaultSecurity(organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRunnerDefaultSecurity(organizationId, workspaceId, runnerId, runnerRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.setRunnerDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Start a run with runner parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRun(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.startRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stop the last run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopRun(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.stopRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {Runner} runner the new Runner details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRunner(organizationId: string, workspaceId: string, runnerId: string, runner: Runner, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Runner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRunner(organizationId, workspaceId, runnerId, runner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.updateRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {RunnerRole} runnerRole The new Runner Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, runnerRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.updateRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RunnerApi - factory interface
 * @export
 */
export const RunnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunnerApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<RunnerAccessControl> {
            return localVarFp.addRunnerAccessControl(organizationId, workspaceId, runnerId, runnerAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Runner} runner the Runner to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunner(organizationId: string, workspaceId: string, runner: Runner, options?: RawAxiosRequestConfig): AxiosPromise<Runner> {
            return localVarFp.createRunner(organizationId, workspaceId, runner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRunner(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<Runner> {
            return localVarFp.getRunner(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunnerAccessControl> {
            return localVarFp.getRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Runner permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerPermissions(organizationId: string, workspaceId: string, runnerId: string, role: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getRunnerPermissions(organizationId, workspaceId, runnerId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Runner security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerSecurity(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunnerSecurity> {
            return localVarFp.getRunnerSecurity(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Runner security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerSecurityUsers(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getRunnerSecurityUsers(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Runners
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunners(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Runner>> {
            return localVarFp.listRunners(organizationId, workspaceId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Runner default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRunnerDefaultSecurity(organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig): AxiosPromise<RunnerSecurity> {
            return localVarFp.setRunnerDefaultSecurity(organizationId, workspaceId, runnerId, runnerRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a run with runner parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatedRun> {
            return localVarFp.startRun(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop the last run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stopRun(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {Runner} runner the new Runner details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunner(organizationId: string, workspaceId: string, runnerId: string, runner: Runner, options?: RawAxiosRequestConfig): AxiosPromise<Runner> {
            return localVarFp.updateRunner(organizationId, workspaceId, runnerId, runner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {RunnerRole} runnerRole The new Runner Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig): AxiosPromise<RunnerAccessControl> {
            return localVarFp.updateRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, runnerRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunnerApi - object-oriented interface
 * @export
 * @class RunnerApi
 * @extends {BaseAPI}
 */
export class RunnerApi extends BaseAPI {
    /**
     * 
     * @summary Add a control access to the Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public addRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).addRunnerAccessControl(organizationId, workspaceId, runnerId, runnerAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {Runner} runner the Runner to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public createRunner(organizationId: string, workspaceId: string, runner: Runner, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).createRunner(organizationId, workspaceId, runner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public deleteRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).deleteRunner(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunner(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Runner permission by given role
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} role the Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerPermissions(organizationId: string, workspaceId: string, runnerId: string, role: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerPermissions(organizationId, workspaceId, runnerId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Runner security information
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerSecurity(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerSecurity(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Runner security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerSecurityUsers(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerSecurityUsers(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Runners
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public listRunners(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).listRunners(organizationId, workspaceId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public removeRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).removeRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Runner default security
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public setRunnerDefaultSecurity(organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).setRunnerDefaultSecurity(organizationId, workspaceId, runnerId, runnerRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a run with runner parameters
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public startRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).startRun(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop the last run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public stopRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).stopRun(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {Runner} runner the new Runner details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public updateRunner(organizationId: string, workspaceId: string, runnerId: string, runner: Runner, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).updateRunner(organizationId, workspaceId, runnerId, runner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} identityId the User identifier
     * @param {RunnerRole} runnerRole The new Runner Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public updateRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).updateRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, runnerRole, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SolutionApi - axios parameter creator
 * @export
 */
export const SolutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Parameter Groups. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameterGroups: async (organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceParameterGroups', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('addOrReplaceParameterGroups', 'solutionId', solutionId)
            // verify required parameter 'runTemplateParameterGroup' is not null or undefined
            assertParamExists('addOrReplaceParameterGroups', 'runTemplateParameterGroup', runTemplateParameterGroup)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateParameterGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Parameters. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameters: async (organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceParameters', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('addOrReplaceParameters', 'solutionId', solutionId)
            // verify required parameter 'runTemplateParameter' is not null or undefined
            assertParamExists('addOrReplaceParameters', 'runTemplateParameter', runTemplateParameter)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Run Templates. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceRunTemplates: async (organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceRunTemplates', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('addOrReplaceRunTemplates', 'solutionId', solutionId)
            // verify required parameter 'runTemplate' is not null or undefined
            assertParamExists('addOrReplaceRunTemplates', 'runTemplate', runTemplate)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a control access to the Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionAccessControl} solutionAccessControl the new Solution security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSolutionAccessControl: async (organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('addSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'solutionAccessControl' is not null or undefined
            assertParamExists('addSolutionAccessControl', 'solutionAccessControl', solutionAccessControl)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolution: async (organizationId: string, solution: Solution, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSolution', 'organizationId', organizationId)
            // verify required parameter 'solution' is not null or undefined
            assertParamExists('createSolution', 'solution', solution)
            const localVarPath = `/organizations/{organization_id}/solutions`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolution: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolution', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionRunTemplate: async (organizationId: string, solutionId: string, runTemplateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'runTemplateId', runTemplateId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates/{run_template_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllSolutions: async (organizationId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllSolutions', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/solutions`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSolutionById: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findSolutionById', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('findSolutionById', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionAccessControl: async (organizationId: string, solutionId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getSolutionAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Solution security information
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionSecurity: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getSolutionSecurity', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getSolutionSecurity', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Solution security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionSecurityUsers: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getSolutionSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getSolutionSecurityUsers', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Run Templates from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllRunTemplates: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllRunTemplates', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('removeAllRunTemplates', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Parameter Groups from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameterGroups: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllSolutionParameterGroups', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('removeAllSolutionParameterGroups', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Parameters from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameters: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllSolutionParameters', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('removeAllSolutionParameters', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSolutionAccessControl: async (organizationId: string, solutionId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('removeSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeSolutionAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Solution default security
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionRole} solutionRole This change the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSolutionDefaultSecurity: async (organizationId: string, solutionId: string, solutionRole: SolutionRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setSolutionDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('setSolutionDefaultSecurity', 'solutionId', solutionId)
            // verify required parameter 'solutionRole' is not null or undefined
            assertParamExists('setSolutionDefaultSecurity', 'solutionRole', solutionRole)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Solution} solution the new Solution details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolution: async (organizationId: string, solutionId: string, solution: Solution, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolution', 'solutionId', solutionId)
            // verify required parameter 'solution' is not null or undefined
            assertParamExists('updateSolution', 'solution', solution)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {SolutionRole} solutionRole The new Solution Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionAccessControl: async (organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'identityId', identityId)
            // verify required parameter 'solutionRole' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'solutionRole', solutionRole)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionRunTemplate: async (organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'runTemplateId', runTemplateId)
            // verify required parameter 'runTemplate' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'runTemplate', runTemplate)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates/{run_template_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SolutionApi - functional programming interface
 * @export
 */
export const SolutionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SolutionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Parameter Groups. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplateParameterGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.addOrReplaceParameterGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add Parameters. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplateParameter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceParameters(organizationId, solutionId, runTemplateParameter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.addOrReplaceParameters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add Run Templates. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceRunTemplates(organizationId, solutionId, runTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.addOrReplaceRunTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a control access to the Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionAccessControl} solutionAccessControl the new Solution security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSolutionAccessControl(organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSolutionAccessControl(organizationId, solutionId, solutionAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.addSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSolution(organizationId: string, solution: Solution, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSolution(organizationId, solution, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.createSolution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolution(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolutionRunTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllSolutions(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Solution>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllSolutions(organizationId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.findAllSolutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSolutionById(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSolutionById(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.findSolutionById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolutionAccessControl(organizationId, solutionId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Solution security information
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolutionSecurity(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolutionSecurity(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getSolutionSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Solution security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolutionSecurityUsers(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolutionSecurityUsers(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getSolutionSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove all Run Templates from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllRunTemplates(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllRunTemplates(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.removeAllRunTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove all Parameter Groups from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllSolutionParameterGroups(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllSolutionParameterGroups(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.removeAllSolutionParameterGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove all Parameters from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllSolutionParameters(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllSolutionParameters(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.removeAllSolutionParameters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSolutionAccessControl(organizationId, solutionId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.removeSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Solution default security
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionRole} solutionRole This change the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSolutionDefaultSecurity(organizationId: string, solutionId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSolutionDefaultSecurity(organizationId, solutionId, solutionRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.setSolutionDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Solution} solution the new Solution details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolution(organizationId: string, solutionId: string, solution: Solution, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolution(organizationId, solutionId, solution, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {SolutionRole} solutionRole The new Solution Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionAccessControl(organizationId, solutionId, identityId, solutionRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionRunTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SolutionApi - factory interface
 * @export
 */
export const SolutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SolutionApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Parameter Groups. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunTemplateParameterGroup>> {
            return localVarFp.addOrReplaceParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Parameters. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunTemplateParameter>> {
            return localVarFp.addOrReplaceParameters(organizationId, solutionId, runTemplateParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Run Templates. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunTemplate>> {
            return localVarFp.addOrReplaceRunTemplates(organizationId, solutionId, runTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a control access to the Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionAccessControl} solutionAccessControl the new Solution security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSolutionAccessControl(organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<SolutionAccessControl> {
            return localVarFp.addSolutionAccessControl(organizationId, solutionId, solutionAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolution(organizationId: string, solution: Solution, options?: RawAxiosRequestConfig): AxiosPromise<Solution> {
            return localVarFp.createSolution(organizationId, solution, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSolution(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllSolutions(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Solution>> {
            return localVarFp.findAllSolutions(organizationId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSolutionById(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Solution> {
            return localVarFp.findSolutionById(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<SolutionAccessControl> {
            return localVarFp.getSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Solution security information
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionSecurity(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<SolutionSecurity> {
            return localVarFp.getSolutionSecurity(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Solution security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionSecurityUsers(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getSolutionSecurityUsers(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Run Templates from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllRunTemplates(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeAllRunTemplates(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Parameter Groups from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameterGroups(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeAllSolutionParameterGroups(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Parameters from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameters(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeAllSolutionParameters(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Solution default security
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionRole} solutionRole This change the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSolutionDefaultSecurity(organizationId: string, solutionId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig): AxiosPromise<SolutionSecurity> {
            return localVarFp.setSolutionDefaultSecurity(organizationId, solutionId, solutionRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Solution} solution the new Solution details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolution(organizationId: string, solutionId: string, solution: Solution, options?: RawAxiosRequestConfig): AxiosPromise<Solution> {
            return localVarFp.updateSolution(organizationId, solutionId, solution, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {SolutionRole} solutionRole The new Solution Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig): AxiosPromise<SolutionAccessControl> {
            return localVarFp.updateSolutionAccessControl(organizationId, solutionId, identityId, solutionRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunTemplate>> {
            return localVarFp.updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SolutionApi - object-oriented interface
 * @export
 * @class SolutionApi
 * @extends {BaseAPI}
 */
export class SolutionApi extends BaseAPI {
    /**
     * 
     * @summary Add Parameter Groups. Any item with the same ID will be overwritten
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public addOrReplaceParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).addOrReplaceParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Parameters. Any item with the same ID will be overwritten
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public addOrReplaceParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).addOrReplaceParameters(organizationId, solutionId, runTemplateParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Run Templates. Any item with the same ID will be overwritten
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplate>} runTemplate the Run Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public addOrReplaceRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).addOrReplaceRunTemplates(organizationId, solutionId, runTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a control access to the Solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {SolutionAccessControl} solutionAccessControl the new Solution security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public addSolutionAccessControl(organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).addSolutionAccessControl(organizationId, solutionId, solutionAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new solution
     * @param {string} organizationId the Organization identifier
     * @param {Solution} solution the Solution to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public createSolution(organizationId: string, solution: Solution, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).createSolution(organizationId, solution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolution(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified Solution Run Template
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Solutions
     * @param {string} organizationId the Organization identifier
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public findAllSolutions(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).findAllSolutions(organizationId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public findSolutionById(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).findSolutionById(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Solution security information
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getSolutionSecurity(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getSolutionSecurity(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Solution security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getSolutionSecurityUsers(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getSolutionSecurityUsers(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Run Templates from the Solution specified
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public removeAllRunTemplates(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).removeAllRunTemplates(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Parameter Groups from the Solution specified
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public removeAllSolutionParameterGroups(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).removeAllSolutionParameterGroups(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Parameters from the Solution specified
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public removeAllSolutionParameters(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).removeAllSolutionParameters(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization Solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public removeSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).removeSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Solution default security
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {SolutionRole} solutionRole This change the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public setSolutionDefaultSecurity(organizationId: string, solutionId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).setSolutionDefaultSecurity(organizationId, solutionId, solutionRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Solution} solution the new Solution details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolution(organizationId: string, solutionId: string, solution: Solution, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolution(organizationId, solutionId, solution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} identityId the User identifier
     * @param {SolutionRole} solutionRole The new Solution Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionAccessControl(organizationId, solutionId, identityId, solutionRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified Solution Run Template
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {RunTemplate} runTemplate the Run Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspaceApi - axios parameter creator
 * @export
 */
export const WorkspaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspaceAccessControl: async (organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceAccessControl' is not null or undefined
            assertParamExists('addWorkspaceAccessControl', 'workspaceAccessControl', workspaceAccessControl)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace: async (organizationId: string, workspace: Workspace, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createWorkspace', 'workspace', workspace)
            const localVarPath = `/organizations/{organization_id}/workspaces`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllWorkspaceFiles: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteAllWorkspaceFiles', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteAllWorkspaceFiles', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFile: async (organizationId: string, workspaceId: string, fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'fileName', fileName)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files/delete`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadWorkspaceFile: async (organizationId: string, workspaceId: string, fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('downloadWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('downloadWorkspaceFile', 'fileName', fileName)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files/download`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaceFiles: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllWorkspaceFiles', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findAllWorkspaceFiles', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaces: async (organizationId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllWorkspaces', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/workspaces`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkspaceById: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findWorkspaceById', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findWorkspaceById', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions: async (organizationId: string, workspaceId: string, role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspacePermissions', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspacePermissions', 'workspaceId', workspaceId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getWorkspacePermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurity: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceSecurity', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurityUsers: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceSecurityUsers', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataset: async (organizationId: string, workspaceId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('linkDataset', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('linkDataset', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('linkDataset', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/link`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (datasetId !== undefined) {
                localVarQueryParameter['datasetId'] = datasetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeWorkspaceAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Workspace default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceDefaultSecurity: async (organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setWorkspaceDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('setWorkspaceDefaultSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceRole' is not null or undefined
            assertParamExists('setWorkspaceDefaultSecurity', 'workspaceRole', workspaceRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataset: async (organizationId: string, workspaceId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('unlinkDataset', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('unlinkDataset', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('unlinkDataset', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/unlink`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (datasetId !== undefined) {
                localVarQueryParameter['datasetId'] = datasetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Workspace} workspace The new Workspace details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace: async (organizationId: string, workspaceId: string, workspace: Workspace, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceId', workspaceId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateWorkspace', 'workspace', workspace)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'identityId', identityId)
            // verify required parameter 'workspaceRole' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'workspaceRole', workspaceRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {File} file 
         * @param {boolean} [overwrite] 
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadWorkspaceFile: async (organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('uploadWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('uploadWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadWorkspaceFile', 'file', file)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


            if (overwrite !== undefined) { 
                localVarFormParams.append('overwrite', String(overwrite) as any);
            }
    
            if (destination !== undefined) { 
                localVarFormParams.append('destination', destination as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspaceApi - functional programming interface
 * @export
 */
export const WorkspaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.addWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspace(organizationId: string, workspace: Workspace, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspace(organizationId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.createWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllWorkspaceFiles(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteAllWorkspaceFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspace(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceFile(organizationId, workspaceId, fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteWorkspaceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadWorkspaceFile(organizationId, workspaceId, fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.downloadWorkspaceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllWorkspaceFiles(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.findAllWorkspaceFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllWorkspaces(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workspace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllWorkspaces(organizationId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.findAllWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findWorkspaceById(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findWorkspaceById(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.findWorkspaceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceAccessControl(organizationId, workspaceId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspacePermissions(organizationId: string, workspaceId: string, role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspacePermissions(organizationId, workspaceId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspacePermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceSecurity(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspaceSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceSecurityUsers(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspaceSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkDataset(organizationId, workspaceId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.linkDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeWorkspaceAccessControl(organizationId, workspaceId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.removeWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Workspace default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.setWorkspaceDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkDataset(organizationId, workspaceId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.unlinkDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Workspace} workspace The new Workspace details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspace(organizationId: string, workspaceId: string, workspace: Workspace, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspace(organizationId, workspaceId, workspace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.updateWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.updateWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {File} file 
         * @param {boolean} [overwrite] 
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadWorkspaceFile(organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.uploadWorkspaceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspaceApi - factory interface
 * @export
 */
export const WorkspaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspaceApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.addWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(organizationId: string, workspace: Workspace, options?: RawAxiosRequestConfig): AxiosPromise<Workspace> {
            return localVarFp.createWorkspace(organizationId, workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkspace(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceFile>> {
            return localVarFp.findAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaces(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Workspace>> {
            return localVarFp.findAllWorkspaces(organizationId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkspaceById(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Workspace> {
            return localVarFp.findWorkspaceById(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.getWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspacePermissions(organizationId: string, workspaceId: string, role: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getWorkspacePermissions(organizationId, workspaceId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSecurity> {
            return localVarFp.getWorkspaceSecurity(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getWorkspaceSecurityUsers(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Workspace> {
            return localVarFp.linkDataset(organizationId, workspaceId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Workspace default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSecurity> {
            return localVarFp.setWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Workspace> {
            return localVarFp.unlinkDataset(organizationId, workspaceId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Workspace} workspace The new Workspace details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(organizationId: string, workspaceId: string, workspace: Workspace, options?: RawAxiosRequestConfig): AxiosPromise<Workspace> {
            return localVarFp.updateWorkspace(organizationId, workspaceId, workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {File} file 
         * @param {boolean} [overwrite] 
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadWorkspaceFile(organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceFile> {
            return localVarFp.uploadWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspaceApi - object-oriented interface
 * @export
 * @class WorkspaceApi
 * @extends {BaseAPI}
 */
export class WorkspaceApi extends BaseAPI {
    /**
     * 
     * @summary Add a control access to the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public addWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).addWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new workspace
     * @param {string} organizationId the Organization identifier
     * @param {Workspace} workspace the Workspace to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createWorkspace(organizationId: string, workspace: Workspace, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createWorkspace(organizationId, workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all Workspace files
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspace(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace file
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} fileName the file name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download the Workspace File specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} fileName the file name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public downloadWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).downloadWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Workspace files
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public findAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).findAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Workspaces
     * @param {string} organizationId the Organization identifier
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public findAllWorkspaces(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).findAllWorkspaces(organizationId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public findWorkspaceById(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).findWorkspaceById(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace permission by given role
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} role the Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspacePermissions(organizationId: string, workspaceId: string, role: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspacePermissions(organizationId, workspaceId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace security information
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceSecurity(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceSecurityUsers(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId dataset id to be linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public linkDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).linkDataset(organizationId, workspaceId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public removeWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).removeWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Workspace default security
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public setWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).setWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId dataset id to be linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public unlinkDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).unlinkDataset(organizationId, workspaceId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {Workspace} workspace The new Workspace details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspace(organizationId: string, workspaceId: string, workspace: Workspace, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspace(organizationId, workspaceId, workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} identityId the User identifier
     * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a file for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {File} file 
     * @param {boolean} [overwrite] 
     * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public uploadWorkspaceFile(organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).uploadWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options).then((request) => request(this.axios, this.basePath));
    }
}



