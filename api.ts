/* tslint:disable */
/* eslint-disable */
/**
 * Cosmo Tech Platform API
 * Cosmo Tech Platform API
 *
 * The version of the OpenAPI document: 4.0.1-SNAPSHOT
 * Contact: platform@cosmotech.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Misc information about the api
 * @export
 * @interface AboutInfo
 */
export interface AboutInfo {
    /**
     * 
     * @type {AboutInfoVersion}
     * @memberof AboutInfo
     */
    'version': AboutInfoVersion;
}
/**
 * API version details
 * @export
 * @interface AboutInfoVersion
 */
export interface AboutInfoVersion {
    /**
     * Full version representation
     * @type {string}
     * @memberof AboutInfoVersion
     */
    'full': string;
    /**
     * Release main version representation
     * @type {string}
     * @memberof AboutInfoVersion
     */
    'release': string;
    /**
     * Major version number
     * @type {number}
     * @memberof AboutInfoVersion
     */
    'major': number;
    /**
     * Minor version number
     * @type {number}
     * @memberof AboutInfoVersion
     */
    'minor': number;
    /**
     * Patch version number
     * @type {number}
     * @memberof AboutInfoVersion
     */
    'patch': number;
    /**
     * Label version, may be empty
     * @type {string}
     * @memberof AboutInfoVersion
     */
    'label': string;
    /**
     * Build VCS id
     * @type {string}
     * @memberof AboutInfoVersion
     */
    'build': string;
}
/**
 * a RBAC by component
 * @export
 * @interface ComponentRolePermissions
 */
export interface ComponentRolePermissions {
    /**
     * 
     * @type {string}
     * @memberof ComponentRolePermissions
     */
    'component': string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ComponentRolePermissions
     */
    'roles': { [key: string]: Array<string>; };
}
/**
 * a version of a Connector
 * @export
 * @interface Connector
 */
export interface Connector {
    /**
     * the Connector version unique identifier
     * @type {string}
     * @memberof Connector
     */
    'id'?: string;
    /**
     * the Connector key which group Connector versions
     * @type {string}
     * @memberof Connector
     */
    'key'?: string;
    /**
     * the Connector name
     * @type {string}
     * @memberof Connector
     */
    'name'?: string;
    /**
     * the Connector description
     * @type {string}
     * @memberof Connector
     */
    'description'?: string;
    /**
     * the registry repository containing the image
     * @type {string}
     * @memberof Connector
     */
    'repository'?: string;
    /**
     * the Connector version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof Connector
     */
    'version'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Connector
     */
    'tags'?: Array<string>;
    /**
     * the user id which own this connector version
     * @type {string}
     * @memberof Connector
     */
    'ownerId'?: string;
    /**
     * an optional URL link to connector page
     * @type {string}
     * @memberof Connector
     */
    'url'?: string;
    /**
     * 
     * @type {Array<IoTypesEnum>}
     * @memberof Connector
     */
    'ioTypes'?: Array<IoTypesEnum>;
    /**
     * the list of connector parameters groups
     * @type {Array<ConnectorParameterGroup>}
     * @memberof Connector
     */
    'parameterGroups'?: Array<ConnectorParameterGroup>;
}
/**
 * a connector parameter
 * @export
 * @interface ConnectorParameter
 */
export interface ConnectorParameter {
    /**
     * the connector parameter id
     * @type {string}
     * @memberof ConnectorParameter
     */
    'id': string;
    /**
     * the list of translated parameter group labels
     * @type {string}
     * @memberof ConnectorParameter
     */
    'label': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof ConnectorParameter
     */
    'valueType'?: string;
    /**
     * the list of available and valid values for the parameter
     * @type {Array<string>}
     * @memberof ConnectorParameter
     */
    'options'?: Array<string>;
    /**
     * the default value
     * @type {string}
     * @memberof ConnectorParameter
     */
    'default'?: string;
    /**
     * associated environment variable in connector image
     * @type {string}
     * @memberof ConnectorParameter
     */
    'envVar'?: string;
}
/**
 * a connector parameters group
 * @export
 * @interface ConnectorParameterGroup
 */
export interface ConnectorParameterGroup {
    /**
     * the connector parameter group id
     * @type {string}
     * @memberof ConnectorParameterGroup
     */
    'id': string;
    /**
     * the list of translated parameter group labels
     * @type {string}
     * @memberof ConnectorParameterGroup
     */
    'label': string;
    /**
     * the list of parameters
     * @type {Array<ConnectorParameter>}
     * @memberof ConnectorParameterGroup
     */
    'parameters': Array<ConnectorParameter>;
}
/**
 * define cpus and memory needs
 * @export
 * @interface ContainerResourceSizeInfo
 */
export interface ContainerResourceSizeInfo {
    /**
     * define cpu needs
     * @type {string}
     * @memberof ContainerResourceSizeInfo
     */
    'cpu': string;
    /**
     * define memory needs
     * @type {string}
     * @memberof ContainerResourceSizeInfo
     */
    'memory': string;
}
/**
 * a description object for resource requests and limits (default same configuration as basic sizing)
 * @export
 * @interface ContainerResourceSizing
 */
export interface ContainerResourceSizing {
    /**
     * 
     * @type {ContainerResourceSizeInfo}
     * @memberof ContainerResourceSizing
     */
    'requests': ContainerResourceSizeInfo;
    /**
     * 
     * @type {ContainerResourceSizeInfo}
     * @memberof ContainerResourceSizing
     */
    'limits': ContainerResourceSizeInfo;
}
/**
 * Newle created Run info
 * @export
 * @interface CreatedRun
 */
export interface CreatedRun {
    /**
     * Run id
     * @type {string}
     * @memberof CreatedRun
     */
    'id': string;
}
/**
 * a Dataset
 * @export
 * @interface Dataset
 */
export interface Dataset {
    /**
     * the Dataset unique identifier
     * @type {string}
     * @memberof Dataset
     */
    'id'?: string;
    /**
     * the Dataset name
     * @type {string}
     * @memberof Dataset
     */
    'name'?: string;
    /**
     * the Dataset description
     * @type {string}
     * @memberof Dataset
     */
    'description'?: string;
    /**
     * the User id which own this Dataset
     * @type {string}
     * @memberof Dataset
     */
    'ownerId'?: string;
    /**
     * the name of the owner
     * @type {string}
     * @memberof Dataset
     */
    'ownerName'?: string;
    /**
     * the Organization Id related to this Dataset
     * @type {string}
     * @memberof Dataset
     */
    'organizationId'?: string;
    /**
     * the Dataset id which is the parent of this Dataset
     * @type {string}
     * @memberof Dataset
     */
    'parentId'?: string;
    /**
     * list of workspace linked to this dataset
     * @type {Array<string>}
     * @memberof Dataset
     */
    'linkedWorkspaceIdList'?: Array<string>;
    /**
     * the twin graph id
     * @type {string}
     * @memberof Dataset
     */
    'twingraphId'?: string;
    /**
     * is this the main dataset
     * @type {boolean}
     * @memberof Dataset
     */
    'main'?: boolean;
    /**
     * the Dataset creation date
     * @type {number}
     * @memberof Dataset
     */
    'creationDate'?: number;
    /**
     * the last time a refresh was done
     * @type {number}
     * @memberof Dataset
     */
    'refreshDate'?: number;
    /**
     * 
     * @type {DatasetSourceType}
     * @memberof Dataset
     */
    'sourceType'?: DatasetSourceType;
    /**
     * 
     * @type {SourceInfo}
     * @memberof Dataset
     */
    'source'?: SourceInfo;
    /**
     * 
     * @type {IngestionStatusEnum}
     * @memberof Dataset
     */
    'ingestionStatus'?: IngestionStatusEnum | null;
    /**
     * 
     * @type {TwincacheStatusEnum}
     * @memberof Dataset
     */
    'twincacheStatus'?: TwincacheStatusEnum | null;
    /**
     * the list of queries
     * @type {Array<string>}
     * @memberof Dataset
     */
    'queries'?: Array<string>;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Dataset
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {DatasetConnector}
     * @memberof Dataset
     */
    'connector'?: DatasetConnector;
    /**
     * the list of other Datasets ids to compose as fragments
     * @type {Array<string>}
     * @memberof Dataset
     */
    'fragmentsIds'?: Array<string>;
    /**
     * the validator id
     * @type {string}
     * @memberof Dataset
     */
    'validatorId'?: string;
    /**
     * the list of compatible Solutions versions
     * @type {Array<DatasetCompatibility>}
     * @memberof Dataset
     */
    'compatibility'?: Array<DatasetCompatibility>;
    /**
     * 
     * @type {DatasetSecurity}
     * @memberof Dataset
     */
    'security'?: DatasetSecurity;
}


/**
 * a Dataset access control item
 * @export
 * @interface DatasetAccessControl
 */
export interface DatasetAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof DatasetAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof DatasetAccessControl
     */
    'role': string;
}
/**
 * a Dataset compatibility constraint to a Solution version open range
 * @export
 * @interface DatasetCompatibility
 */
export interface DatasetCompatibility {
    /**
     * the Solution key which group Solution versions
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'solutionKey': string;
    /**
     * the Solution minimum version compatibility (version included)
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'minimumVersion'?: string;
    /**
     * the Solution maximum version compatibility (version included)
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'maximumVersion'?: string;
}
/**
 * the Connector setup bound to a Dataset
 * @export
 * @interface DatasetConnector
 */
export interface DatasetConnector {
    /**
     * the Connector id
     * @type {string}
     * @memberof DatasetConnector
     */
    'id'?: string;
    /**
     * the Connector name
     * @type {string}
     * @memberof DatasetConnector
     */
    'name'?: string;
    /**
     * the Connector version
     * @type {string}
     * @memberof DatasetConnector
     */
    'version'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DatasetConnector
     */
    'parametersValues'?: { [key: string]: string; };
}
/**
 * the Dataset Copy Parameters
 * @export
 * @interface DatasetCopyParameters
 */
export interface DatasetCopyParameters {
    /**
     * the source Dataset id
     * @type {string}
     * @memberof DatasetCopyParameters
     */
    'sourceId'?: string;
    /**
     * the target Dataset id
     * @type {string}
     * @memberof DatasetCopyParameters
     */
    'targetId'?: string;
    /**
     * freeform options to path to connectors
     * @type {{ [key: string]: any; }}
     * @memberof DatasetCopyParameters
     */
    'options'?: { [key: string]: any; };
}
/**
 * the Dataset Role
 * @export
 * @interface DatasetRole
 */
export interface DatasetRole {
    /**
     * the Dataset Role
     * @type {string}
     * @memberof DatasetRole
     */
    'role': string;
}
/**
 * the search options
 * @export
 * @interface DatasetSearch
 */
export interface DatasetSearch {
    /**
     * the dataset tag list to search
     * @type {Array<string>}
     * @memberof DatasetSearch
     */
    'datasetTags': Array<string>;
}
/**
 * the dataset security information
 * @export
 * @interface DatasetSecurity
 */
export interface DatasetSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof DatasetSecurity
     */
    'default': string;
    /**
     * the list which can access this Dataset with detailed access control information
     * @type {Array<DatasetAccessControl>}
     * @memberof DatasetSecurity
     */
    'accessControlList': Array<DatasetAccessControl>;
}
/**
 * the Dataset Source Type
 * @export
 * @enum {string}
 */

export const DatasetSourceType = {
    Adt: 'ADT',
    AzureStorage: 'AzureStorage',
    File: 'File',
    None: 'None',
    Twincache: 'Twincache',
    Etl: 'ETL'
} as const;

export type DatasetSourceType = typeof DatasetSourceType[keyof typeof DatasetSourceType];


/**
 * a twin graph hash
 * @export
 * @interface DatasetTwinGraphHash
 */
export interface DatasetTwinGraphHash {
    /**
     * the hash of the graph
     * @type {string}
     * @memberof DatasetTwinGraphHash
     */
    'hash'?: string;
}
/**
 * a twin graph query in cypher language
 * @export
 * @interface DatasetTwinGraphInfo
 */
export interface DatasetTwinGraphInfo {
    /**
     * the import job id
     * @type {string}
     * @memberof DatasetTwinGraphInfo
     */
    'jobId'?: string;
    /**
     * the Dataset id
     * @type {string}
     * @memberof DatasetTwinGraphInfo
     */
    'datasetId'?: string;
    /**
     * Twingraph status
     * @type {string}
     * @memberof DatasetTwinGraphInfo
     */
    'status'?: string;
}
/**
 * a twin graph query in cypher language
 * @export
 * @interface DatasetTwinGraphQuery
 */
export interface DatasetTwinGraphQuery {
    /**
     * the query in cypher language
     * @type {string}
     * @memberof DatasetTwinGraphQuery
     */
    'query': string;
}
/**
 * 
 * @export
 * @interface FileUploadMetadata
 */
export interface FileUploadMetadata {
    /**
     * 
     * @type {string}
     * @memberof FileUploadMetadata
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof FileUploadMetadata
     */
    'size'?: number;
}
/**
 * files read on upload
 * @export
 * @interface FileUploadValidation
 */
export interface FileUploadValidation {
    /**
     * list of filename found on nodes folder
     * @type {Array<FileUploadMetadata>}
     * @memberof FileUploadValidation
     */
    'nodes'?: Array<FileUploadMetadata>;
    /**
     * list of filename found on edges folder
     * @type {Array<FileUploadMetadata>}
     * @memberof FileUploadValidation
     */
    'edges'?: Array<FileUploadMetadata>;
}
/**
 * 
 * @export
 * @interface GraphProperties
 */
export interface GraphProperties {
    /**
     * the type of the relationship
     * @type {string}
     * @memberof GraphProperties
     */
    'type'?: string;
    /**
     * the source node of the relationship
     * @type {string}
     * @memberof GraphProperties
     */
    'source'?: string;
    /**
     * the target node of the relationship
     * @type {string}
     * @memberof GraphProperties
     */
    'target'?: string;
    /**
     * the name of the graph data object
     * @type {string}
     * @memberof GraphProperties
     */
    'name'?: string;
    /**
     * the parameters of the graph data object
     * @type {string}
     * @memberof GraphProperties
     */
    'params'?: string;
}
/**
 * the Dataset ingestion status
 * @export
 * @enum {string}
 */

export const IngestionStatusEnum = {
    None: 'NONE',
    Pending: 'PENDING',
    Error: 'ERROR',
    Success: 'SUCCESS'
} as const;

export type IngestionStatusEnum = typeof IngestionStatusEnum[keyof typeof IngestionStatusEnum];


/**
 * The read and write capabilities of connector
 * @export
 * @enum {string}
 */

export const IoTypesEnum = {
    Read: 'read',
    Write: 'write'
} as const;

export type IoTypesEnum = typeof IoTypesEnum[keyof typeof IoTypesEnum];


/**
 * an Organization
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * the Organization unique identifier
     * @type {string}
     * @memberof Organization
     */
    'id': string;
    /**
     * the Organization name
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * the Owner User Id
     * @type {string}
     * @memberof Organization
     */
    'ownerId': string;
    /**
     * 
     * @type {OrganizationSecurity}
     * @memberof Organization
     */
    'security': OrganizationSecurity;
}
/**
 * Response object for organization access control
 * @export
 * @interface OrganizationAccessControl
 */
export interface OrganizationAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof OrganizationAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof OrganizationAccessControl
     */
    'role': string;
}
/**
 * Request object for creating a new organization
 * @export
 * @interface OrganizationCreateRequest
 */
export interface OrganizationCreateRequest {
    /**
     * the Organization name
     * @type {string}
     * @memberof OrganizationCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {OrganizationSecurity}
     * @memberof OrganizationCreateRequest
     */
    'security'?: OrganizationSecurity;
}
/**
 * the Organization Role
 * @export
 * @interface OrganizationRole
 */
export interface OrganizationRole {
    /**
     * the Organization Role
     * @type {string}
     * @memberof OrganizationRole
     */
    'role': string;
}
/**
 * Response object for organization security information
 * @export
 * @interface OrganizationSecurity
 */
export interface OrganizationSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof OrganizationSecurity
     */
    'default': string;
    /**
     * the list which can access this Organization with detailed access control information
     * @type {Array<OrganizationAccessControl>}
     * @memberof OrganizationSecurity
     */
    'accessControlList': Array<OrganizationAccessControl>;
}
/**
 * Request object for updating an organization
 * @export
 * @interface OrganizationUpdateRequest
 */
export interface OrganizationUpdateRequest {
    /**
     * the Organization name
     * @type {string}
     * @memberof OrganizationUpdateRequest
     */
    'name'?: string;
}
/**
 * the result of a SQL Query
 * @export
 * @interface QueryResult
 */
export interface QueryResult {
    /**
     * the list of results
     * @type {Array<{ [key: string]: any; }>}
     * @memberof QueryResult
     */
    'result'?: Array<{ [key: string]: any; }>;
}
/**
 * define cpus and memory needs
 * @export
 * @interface ResourceSizeInfo
 */
export interface ResourceSizeInfo {
    /**
     * define cpu needs
     * @type {string}
     * @memberof ResourceSizeInfo
     */
    'cpu': string;
    /**
     * define memory needs
     * @type {string}
     * @memberof ResourceSizeInfo
     */
    'memory': string;
}
/**
 * a Run with only base properties
 * @export
 * @interface Run
 */
export interface Run {
    /**
     * the Run
     * @type {string}
     * @memberof Run
     */
    'id'?: string;
    /**
     * 
     * @type {RunState}
     * @memberof Run
     */
    'state'?: RunState;
    /**
     * the Organization id
     * @type {string}
     * @memberof Run
     */
    'organizationId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof Run
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech Simulation Run Id
     * @type {string}
     * @memberof Run
     */
    'csmSimulationRun'?: string;
    /**
     * the base name for workflow name generation
     * @type {string}
     * @memberof Run
     */
    'generateName'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof Run
     */
    'workflowName'?: string;
    /**
     * the user id which own this run
     * @type {string}
     * @memberof Run
     */
    'ownerId'?: string;
    /**
     * the Workspace Id
     * @type {string}
     * @memberof Run
     */
    'workspaceId'?: string;
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof Run
     */
    'workspaceKey'?: string;
    /**
     * the Runner Id
     * @type {string}
     * @memberof Run
     */
    'runnerId'?: string;
    /**
     * the Solution Id
     * @type {string}
     * @memberof Run
     */
    'solutionId'?: string;
    /**
     * the Solution Run Template id
     * @type {string}
     * @memberof Run
     */
    'runTemplateId'?: string;
    /**
     * the compute size needed for this Analysis. Standard sizes are basic and highcpu. Default is basic
     * @type {string}
     * @memberof Run
     */
    'computeSize'?: string;
    /**
     * the Run creation date
     * @type {string}
     * @memberof Run
     */
    'createdAt'?: string;
    /**
     * the list of Dataset Id associated to this Run
     * @type {Array<string>}
     * @memberof Run
     */
    'datasetList'?: Array<string>;
    /**
     * the list of Run Template parameters values
     * @type {Array<RunTemplateParameterValue>}
     * @memberof Run
     */
    'parametersValues'?: Array<RunTemplateParameterValue>;
    /**
     * the node label request
     * @type {string}
     * @memberof Run
     */
    'nodeLabel'?: string;
    /**
     * the containers list. This information is not returned by the API.
     * @type {Array<RunContainer>}
     * @memberof Run
     */
    'containers'?: Array<RunContainer>;
}


/**
 * a Run container description
 * @export
 * @interface RunContainer
 */
export interface RunContainer {
    /**
     * the container Id
     * @type {string}
     * @memberof RunContainer
     */
    'id'?: string;
    /**
     * the container name
     * @type {string}
     * @memberof RunContainer
     */
    'name': string;
    /**
     * the metadata labels
     * @type {{ [key: string]: string; }}
     * @memberof RunContainer
     */
    'labels'?: { [key: string]: string; };
    /**
     * environment variable map
     * @type {{ [key: string]: string; }}
     * @memberof RunContainer
     */
    'envVars'?: { [key: string]: string; };
    /**
     * the container image URI
     * @type {string}
     * @memberof RunContainer
     */
    'image': string;
    /**
     * the container entry point
     * @type {string}
     * @memberof RunContainer
     */
    'entrypoint'?: string;
    /**
     * the list of run arguments for the container
     * @type {Array<string>}
     * @memberof RunContainer
     */
    'runArgs'?: Array<string>;
    /**
     * the list of dependencies container name to run this container
     * @type {Array<string>}
     * @memberof RunContainer
     */
    'dependencies'?: Array<string>;
    /**
     * whether or not this container is a Cosmo Tech solution container
     * @type {boolean}
     * @memberof RunContainer
     */
    'solutionContainer'?: boolean;
    /**
     * the node label request
     * @type {string}
     * @memberof RunContainer
     */
    'nodeLabel'?: string;
    /**
     * 
     * @type {ContainerResourceSizing}
     * @memberof RunContainer
     */
    'runSizing'?: ContainerResourceSizing;
}
/**
 * Run Data to send
 * @export
 * @interface RunData
 */
export interface RunData {
    /**
     * Database name
     * @type {string}
     * @memberof RunData
     */
    'database_name'?: string;
    /**
     * Table name
     * @type {string}
     * @memberof RunData
     */
    'table_name'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof RunData
     */
    'data'?: Array<{ [key: string]: any; }>;
}
/**
 * a data result query in SQL
 * @export
 * @interface RunDataQuery
 */
export interface RunDataQuery {
    /**
     * the query in SQL
     * @type {string}
     * @memberof RunDataQuery
     */
    'query': string;
}
/**
 * the output logs of a run
 * @export
 * @interface RunLogs
 */
export interface RunLogs {
    /**
     * the Run Id
     * @type {string}
     * @memberof RunLogs
     */
    'runId': string;
    /**
     * run log entries in chronological order
     * @type {Array<RunLogsEntry>}
     * @memberof RunLogs
     */
    'logs': Array<RunLogsEntry>;
}
/**
 * single run log entry
 * @export
 * @interface RunLogsEntry
 */
export interface RunLogsEntry {
    /**
     * log line data
     * @type {string}
     * @memberof RunLogsEntry
     */
    'line': string;
}
/**
 * the memory and CPU requested by the pod
 * @export
 * @interface RunResourceRequested
 */
export interface RunResourceRequested {
    /**
     * the cpu requested
     * @type {number}
     * @memberof RunResourceRequested
     */
    'cpu'?: number;
    /**
     * the memory requested
     * @type {number}
     * @memberof RunResourceRequested
     */
    'memory'?: number;
}
/**
 * the Run end-to-end state
 * @export
 * @enum {string}
 */

export const RunState = {
    Running: 'Running',
    Successful: 'Successful',
    Failed: 'Failed',
    Unknown: 'Unknown'
} as const;

export type RunState = typeof RunState[keyof typeof RunState];


/**
 * a Run status
 * @export
 * @interface RunStatus
 */
export interface RunStatus {
    /**
     * the Run id
     * @type {string}
     * @memberof RunStatus
     */
    'id'?: string;
    /**
     * the Organization id
     * @type {string}
     * @memberof RunStatus
     */
    'organizationId'?: string;
    /**
     * the Workspace id
     * @type {string}
     * @memberof RunStatus
     */
    'workspaceId'?: string;
    /**
     * the Runner id
     * @type {string}
     * @memberof RunStatus
     */
    'runnerId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof RunStatus
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof RunStatus
     */
    'workflowName'?: string;
    /**
     * the Run start Date Time
     * @type {string}
     * @memberof RunStatus
     */
    'startTime'?: string;
    /**
     * the Run end Date Time
     * @type {string}
     * @memberof RunStatus
     */
    'endTime'?: string;
    /**
     * high-level summary of where the workflow is in its lifecycle
     * @type {string}
     * @memberof RunStatus
     */
    'phase'?: string;
    /**
     * progress to completion
     * @type {string}
     * @memberof RunStatus
     */
    'progress'?: string;
    /**
     * a  human readable message indicating details about why the workflow is in this condition
     * @type {string}
     * @memberof RunStatus
     */
    'message'?: string;
    /**
     * estimatedDuration in seconds
     * @type {number}
     * @memberof RunStatus
     */
    'estimatedDuration'?: number;
    /**
     * status of Run nodes
     * @type {Array<RunStatusNode>}
     * @memberof RunStatus
     */
    'nodes'?: Array<RunStatusNode>;
    /**
     * 
     * @type {RunState}
     * @memberof RunStatus
     */
    'state'?: RunState;
}


/**
 * status of a Run Node
 * @export
 * @interface RunStatusNode
 */
export interface RunStatusNode {
    /**
     * the node id
     * @type {string}
     * @memberof RunStatusNode
     */
    'id'?: string;
    /**
     * the node unique name
     * @type {string}
     * @memberof RunStatusNode
     */
    'name'?: string;
    /**
     * the Run container name
     * @type {string}
     * @memberof RunStatusNode
     */
    'containerName'?: string;
    /**
     * the list of outbound nodes
     * @type {Array<string>}
     * @memberof RunStatusNode
     */
    'outboundNodes'?: Array<string>;
    /**
     * 
     * @type {RunResourceRequested}
     * @memberof RunStatusNode
     */
    'resourcesDuration'?: RunResourceRequested;
    /**
     * estimatedDuration in seconds
     * @type {number}
     * @memberof RunStatusNode
     */
    'estimatedDuration'?: number;
    /**
     * HostNodeName name of the Kubernetes node on which the Pod is running, if applicable
     * @type {string}
     * @memberof RunStatusNode
     */
    'hostNodeName'?: string;
    /**
     * a human readable message indicating details about why the node is in this condition
     * @type {string}
     * @memberof RunStatusNode
     */
    'message'?: string;
    /**
     * high-level summary of where the node is in its lifecycle
     * @type {string}
     * @memberof RunStatusNode
     */
    'phase'?: string;
    /**
     * progress to completion
     * @type {string}
     * @memberof RunStatusNode
     */
    'progress'?: string;
    /**
     * the node start time
     * @type {string}
     * @memberof RunStatusNode
     */
    'startTime'?: string;
    /**
     * the node end time
     * @type {string}
     * @memberof RunStatusNode
     */
    'endTime'?: string;
}
/**
 * A Solution Run Template
 * @export
 * @interface RunTemplate
 */
export interface RunTemplate {
    /**
     * The Solution Run Template id
     * @type {string}
     * @memberof RunTemplate
     */
    'id': string;
    /**
     * The Run Template name
     * @type {string}
     * @memberof RunTemplate
     */
    'name'?: string;
    /**
     * a translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplate
     */
    'labels'?: { [key: string]: string; };
    /**
     * The Run Template description
     * @type {string}
     * @memberof RunTemplate
     */
    'description'?: string;
    /**
     * The list of Run Template tags
     * @type {Array<string>}
     * @memberof RunTemplate
     */
    'tags'?: Array<string>;
    /**
     * The compute size needed for this Run Template
     * @type {string}
     * @memberof RunTemplate
     */
    'computeSize'?: string;
    /**
     * 
     * @type {RunTemplateResourceSizing}
     * @memberof RunTemplate
     */
    'runSizing'?: RunTemplateResourceSizing;
    /**
     * The ordered list of parameters groups for the Run Template
     * @type {Array<string>}
     * @memberof RunTemplate
     */
    'parameterGroups'?: Array<string>;
    /**
     * An optional duration in seconds in which a workflow is allowed to run
     * @type {number}
     * @memberof RunTemplate
     */
    'executionTimeout'?: number;
}
/**
 * A Run Template Parameter
 * @export
 * @interface RunTemplateParameter
 */
export interface RunTemplateParameter {
    /**
     * the Parameter id
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'id': string;
    /**
     * a translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameter
     */
    'labels'?: { [key: string]: string; };
    /**
     * the variable type for the parameter. Basic types or special type %DATASETID%
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'varType'?: string;
    /**
     * The default value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'defaultValue'?: string;
    /**
     * The minimum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'minValue'?: string;
    /**
     * The maximum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'maxValue'?: string;
    /**
     * A regex to validate the value
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'regexValidation'?: string;
    /**
     * Freeform options
     * @type {{ [key: string]: any; }}
     * @memberof RunTemplateParameter
     */
    'options'?: { [key: string]: any; };
}
/**
 * A Parameter Group for a Run Template
 * @export
 * @interface RunTemplateParameterGroup
 */
export interface RunTemplateParameterGroup {
    /**
     * the Parameter Group id
     * @type {string}
     * @memberof RunTemplateParameterGroup
     */
    'id': string;
    /**
     * a translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameterGroup
     */
    'labels'?: { [key: string]: string; };
    /**
     * Does the group define a table
     * @type {boolean}
     * @memberof RunTemplateParameterGroup
     */
    'isTable'?: boolean;
    /**
     * Freeform options
     * @type {{ [key: string]: any; }}
     * @memberof RunTemplateParameterGroup
     */
    'options'?: { [key: string]: any; };
    /**
     * The Run Template Group parent Id
     * @type {string}
     * @memberof RunTemplateParameterGroup
     */
    'parentId'?: string;
    /**
     * An ordered list of Run Template Parameters
     * @type {Array<string>}
     * @memberof RunTemplateParameterGroup
     */
    'parameters'?: Array<string>;
}
/**
 * the value of Analysis parameter for a Runner for this Run
 * @export
 * @interface RunTemplateParameterValue
 */
export interface RunTemplateParameterValue {
    /**
     * the parameter Id
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'parameterId': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'value': string;
}
/**
 * A description object for resource requests and limits
 * @export
 * @interface RunTemplateResourceSizing
 */
export interface RunTemplateResourceSizing {
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunTemplateResourceSizing
     */
    'requests': ResourceSizeInfo;
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunTemplateResourceSizing
     */
    'limits': ResourceSizeInfo;
}
/**
 * a Runner with base information
 * @export
 * @interface Runner
 */
export interface Runner {
    /**
     * the Runner unique identifier
     * @type {string}
     * @memberof Runner
     */
    'id'?: string;
    /**
     * the Runner name
     * @type {string}
     * @memberof Runner
     */
    'name'?: string;
    /**
     * the Runner description
     * @type {string}
     * @memberof Runner
     */
    'description'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Runner
     */
    'tags'?: Array<string>;
    /**
     * the Runner parent id
     * @type {string}
     * @memberof Runner
     */
    'parentId'?: string;
    /**
     * the user id which own this Runner
     * @type {string}
     * @memberof Runner
     */
    'ownerId'?: string;
    /**
     * the runner root id
     * @type {string}
     * @memberof Runner
     */
    'rootId'?: string;
    /**
     * the Solution Id associated with this Runner
     * @type {string}
     * @memberof Runner
     */
    'solutionId'?: string;
    /**
     * the Solution Run Template Id associated with this Runner
     * @type {string}
     * @memberof Runner
     */
    'runTemplateId'?: string;
    /**
     * the associated Organization Id
     * @type {string}
     * @memberof Runner
     */
    'organizationId'?: string;
    /**
     * the associated Workspace Id
     * @type {string}
     * @memberof Runner
     */
    'workspaceId'?: string;
    /**
     * the Runner creation date
     * @type {number}
     * @memberof Runner
     */
    'creationDate'?: number;
    /**
     * the last time a Runner was updated
     * @type {number}
     * @memberof Runner
     */
    'lastUpdate'?: number;
    /**
     * the name of the owner
     * @type {string}
     * @memberof Runner
     */
    'ownerName'?: string;
    /**
     * the Solution name
     * @type {string}
     * @memberof Runner
     */
    'solutionName'?: string;
    /**
     * the Solution Run Template name associated with this Runner
     * @type {string}
     * @memberof Runner
     */
    'runTemplateName'?: string;
    /**
     * the list of Dataset Id associated to this Runner Run Template
     * @type {Array<string>}
     * @memberof Runner
     */
    'datasetList'?: Array<string>;
    /**
     * 
     * @type {RunnerResourceSizing}
     * @memberof Runner
     */
    'runSizing'?: RunnerResourceSizing;
    /**
     * the list of Solution Run Template parameters values
     * @type {Array<RunnerRunTemplateParameterValue>}
     * @memberof Runner
     */
    'parametersValues'?: Array<RunnerRunTemplateParameterValue>;
    /**
     * last run id from current runner
     * @type {string}
     * @memberof Runner
     */
    'lastRunId'?: string;
    /**
     * 
     * @type {RunnerValidationStatus}
     * @memberof Runner
     */
    'validationStatus'?: RunnerValidationStatus;
    /**
     * 
     * @type {RunnerSecurity}
     * @memberof Runner
     */
    'security'?: RunnerSecurity;
}


/**
 * a Runner access control item
 * @export
 * @interface RunnerAccessControl
 */
export interface RunnerAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof RunnerAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof RunnerAccessControl
     */
    'role': string;
}
/**
 * a description object for resource requests and limits (default same configuration as basic sizing)
 * @export
 * @interface RunnerResourceSizing
 */
export interface RunnerResourceSizing {
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunnerResourceSizing
     */
    'requests': ResourceSizeInfo;
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunnerResourceSizing
     */
    'limits': ResourceSizeInfo;
}
/**
 * the Runner Role
 * @export
 * @interface RunnerRole
 */
export interface RunnerRole {
    /**
     * the Runner Role
     * @type {string}
     * @memberof RunnerRole
     */
    'role': string;
}
/**
 * the value of a Solution Run Template parameter for a Runner
 * @export
 * @interface RunnerRunTemplateParameterValue
 */
export interface RunnerRunTemplateParameterValue {
    /**
     * the parameter Id
     * @type {string}
     * @memberof RunnerRunTemplateParameterValue
     */
    'parameterId': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof RunnerRunTemplateParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value
     * @type {string}
     * @memberof RunnerRunTemplateParameterValue
     */
    'value': string;
    /**
     * whether or not the value is inherited from parent or has been changed
     * @type {boolean}
     * @memberof RunnerRunTemplateParameterValue
     */
    'isInherited'?: boolean;
}
/**
 * the Runner security information
 * @export
 * @interface RunnerSecurity
 */
export interface RunnerSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof RunnerSecurity
     */
    'default': string;
    /**
     * the list which can access this Runner with detailed access control information
     * @type {Array<RunnerAccessControl>}
     * @memberof RunnerSecurity
     */
    'accessControlList': Array<RunnerAccessControl>;
}
/**
 * the validation status of the runner
 * @export
 * @enum {string}
 */

export const RunnerValidationStatus = {
    Draft: 'Draft',
    Rejected: 'Rejected',
    Unknown: 'Unknown',
    Validated: 'Validated'
} as const;

export type RunnerValidationStatus = typeof RunnerValidationStatus[keyof typeof RunnerValidationStatus];


/**
 * 
 * @export
 * @interface SendRunDataRequest
 */
export interface SendRunDataRequest {
    /**
     * 
     * @type {string}
     * @memberof SendRunDataRequest
     */
    'id'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof SendRunDataRequest
     */
    'data'?: Array<{ [key: string]: any; }>;
}
/**
 * A version of a Solution
 * @export
 * @interface Solution
 */
export interface Solution {
    /**
     * The Solution version unique identifier
     * @type {string}
     * @memberof Solution
     */
    'id': string;
    /**
     * The Organization unique identifier
     * @type {string}
     * @memberof Solution
     */
    'organizationId': string;
    /**
     * The Solution key which groups Solution versions
     * @type {string}
     * @memberof Solution
     */
    'key': string;
    /**
     * The Solution name
     * @type {string}
     * @memberof Solution
     */
    'name': string;
    /**
     * The Solution description
     * @type {string}
     * @memberof Solution
     */
    'description'?: string;
    /**
     * The registry repository containing the image
     * @type {string}
     * @memberof Solution
     */
    'repository': string;
    /**
     * Set to true if the runtemplate wants to always pull the image
     * @type {boolean}
     * @memberof Solution
     */
    'alwaysPull'?: boolean;
    /**
     * The main Cosmo Tech simulator name used in standard Run Template
     * @type {string}
     * @memberof Solution
     */
    'csmSimulator': string;
    /**
     * The Solution version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof Solution
     */
    'version': string;
    /**
     * The User id which owns this Solution
     * @type {string}
     * @memberof Solution
     */
    'ownerId': string;
    /**
     * The MAJOR.MINOR version used to build this solution
     * @type {string}
     * @memberof Solution
     */
    'sdkVersion'?: string;
    /**
     * An optional URL link to solution page
     * @type {string}
     * @memberof Solution
     */
    'url'?: string;
    /**
     * The list of tags
     * @type {Array<string>}
     * @memberof Solution
     */
    'tags'?: Array<string>;
    /**
     * The list of Run Template Parameters
     * @type {Array<RunTemplateParameter>}
     * @memberof Solution
     */
    'parameters': Array<RunTemplateParameter>;
    /**
     * The list of parameters groups for the Run Templates
     * @type {Array<RunTemplateParameterGroup>}
     * @memberof Solution
     */
    'parameterGroups': Array<RunTemplateParameterGroup>;
    /**
     * List of Run Templates
     * @type {Array<RunTemplate>}
     * @memberof Solution
     */
    'runTemplates': Array<RunTemplate>;
    /**
     * 
     * @type {SolutionSecurity}
     * @memberof Solution
     */
    'security': SolutionSecurity;
}
/**
 * A Solution access control item
 * @export
 * @interface SolutionAccessControl
 */
export interface SolutionAccessControl {
    /**
     * The identity id
     * @type {string}
     * @memberof SolutionAccessControl
     */
    'id': string;
    /**
     * The assigned role
     * @type {string}
     * @memberof SolutionAccessControl
     */
    'role': string;
}
/**
 * Request object for creating a new solution
 * @export
 * @interface SolutionCreateRequest
 */
export interface SolutionCreateRequest {
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof SolutionCreateRequest
     */
    'key': string;
    /**
     * Solution name. This name is displayed in the sample webApp
     * @type {string}
     * @memberof SolutionCreateRequest
     */
    'name': string;
    /**
     * The Solution description
     * @type {string}
     * @memberof SolutionCreateRequest
     */
    'description'?: string;
    /**
     * The registry repository containing the image
     * @type {string}
     * @memberof SolutionCreateRequest
     */
    'repository': string;
    /**
     * The Solution version MAJOR.MINOR.PATCH
     * @type {string}
     * @memberof SolutionCreateRequest
     */
    'version': string;
    /**
     * Set to true if the runtemplate wants to always pull the image
     * @type {boolean}
     * @memberof SolutionCreateRequest
     */
    'alwaysPull'?: boolean;
    /**
     * The main Cosmo Tech simulator name used in standard Run Template
     * @type {string}
     * @memberof SolutionCreateRequest
     */
    'csmSimulator': string;
    /**
     * The list of tags
     * @type {Array<string>}
     * @memberof SolutionCreateRequest
     */
    'tags'?: Array<string>;
    /**
     * The list of Run Template Parameters
     * @type {Array<RunTemplateParameter>}
     * @memberof SolutionCreateRequest
     */
    'parameters'?: Array<RunTemplateParameter>;
    /**
     * The list of parameters groups for the Run Templates
     * @type {Array<RunTemplateParameterGroup>}
     * @memberof SolutionCreateRequest
     */
    'parameterGroups'?: Array<RunTemplateParameterGroup>;
    /**
     * List of Run Templates
     * @type {Array<RunTemplate>}
     * @memberof SolutionCreateRequest
     */
    'runTemplates'?: Array<RunTemplate>;
    /**
     * The MAJOR.MINOR version used to build this solution
     * @type {string}
     * @memberof SolutionCreateRequest
     */
    'sdkVersion'?: string;
    /**
     * An optional URL link to solution page
     * @type {string}
     * @memberof SolutionCreateRequest
     */
    'url'?: string;
    /**
     * 
     * @type {SolutionSecurity}
     * @memberof SolutionCreateRequest
     */
    'security'?: SolutionSecurity;
}
/**
 * The Solution Role
 * @export
 * @interface SolutionRole
 */
export interface SolutionRole {
    /**
     * The Solution Role
     * @type {string}
     * @memberof SolutionRole
     */
    'role': string;
}
/**
 * The Solution security information
 * @export
 * @interface SolutionSecurity
 */
export interface SolutionSecurity {
    /**
     * The role by default
     * @type {string}
     * @memberof SolutionSecurity
     */
    'default': string;
    /**
     * The list which can access this Solution with detailed access control information
     * @type {Array<SolutionAccessControl>}
     * @memberof SolutionSecurity
     */
    'accessControlList': Array<SolutionAccessControl>;
}
/**
 * Request object for updating a solution
 * @export
 * @interface SolutionUpdateRequest
 */
export interface SolutionUpdateRequest {
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof SolutionUpdateRequest
     */
    'key'?: string;
    /**
     * The Solution name
     * @type {string}
     * @memberof SolutionUpdateRequest
     */
    'name'?: string;
    /**
     * The Solution description
     * @type {string}
     * @memberof SolutionUpdateRequest
     */
    'description'?: string;
    /**
     * The registry repository containing the image
     * @type {string}
     * @memberof SolutionUpdateRequest
     */
    'repository'?: string;
    /**
     * Set to true if the runtemplate wants to always pull the image
     * @type {boolean}
     * @memberof SolutionUpdateRequest
     */
    'alwaysPull'?: boolean;
    /**
     * The main Cosmo Tech simulator name used in standard Run Template
     * @type {string}
     * @memberof SolutionUpdateRequest
     */
    'csmSimulator'?: string;
    /**
     * The Solution version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof SolutionUpdateRequest
     */
    'version'?: string;
    /**
     * The MAJOR.MINOR version used to build this solution
     * @type {string}
     * @memberof SolutionUpdateRequest
     */
    'sdkVersion'?: string;
    /**
     * An optional URL link to solution page
     * @type {string}
     * @memberof SolutionUpdateRequest
     */
    'url'?: string;
    /**
     * The list of tags
     * @type {Array<string>}
     * @memberof SolutionUpdateRequest
     */
    'tags'?: Array<string>;
}
/**
 * Source job import information
 * @export
 * @interface SourceInfo
 */
export interface SourceInfo {
    /**
     * the source name containing the files to import
     * @type {string}
     * @memberof SourceInfo
     */
    'name'?: string;
    /**
     * the source location containing the files to import
     * @type {string}
     * @memberof SourceInfo
     */
    'location': string;
    /**
     * the source location containing the files to import
     * @type {string}
     * @memberof SourceInfo
     */
    'path'?: string;
    /**
     * indicate the last import jobId
     * @type {string}
     * @memberof SourceInfo
     */
    'jobId'?: string;
}
/**
 * a twin graph query in cypher language
 * @export
 * @interface SubDatasetGraphQuery
 */
export interface SubDatasetGraphQuery {
    /**
     * the name of the subdataset
     * @type {string}
     * @memberof SubDatasetGraphQuery
     */
    'name'?: string;
    /**
     * the description of the subdataset
     * @type {string}
     * @memberof SubDatasetGraphQuery
     */
    'description'?: string;
    /**
     * the query in cypher language
     * @type {Array<string>}
     * @memberof SubDatasetGraphQuery
     */
    'queries'?: Array<string>;
    /**
     * is this the main dataset
     * @type {boolean}
     * @memberof SubDatasetGraphQuery
     */
    'main'?: boolean;
}
/**
 * Processing result
 * @export
 * @interface TwinGraphBatchResult
 */
export interface TwinGraphBatchResult {
    /**
     * 
     * @type {number}
     * @memberof TwinGraphBatchResult
     */
    'totalLines': number;
    /**
     * 
     * @type {number}
     * @memberof TwinGraphBatchResult
     */
    'processedLines': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TwinGraphBatchResult
     */
    'errors': Array<string>;
}
/**
 * the twincache data status
 * @export
 * @enum {string}
 */

export const TwincacheStatusEnum = {
    Empty: 'EMPTY',
    Full: 'FULL'
} as const;

export type TwincacheStatusEnum = typeof TwincacheStatusEnum[keyof typeof TwincacheStatusEnum];


/**
 * a Workspace
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * Workspace unique identifier generated by the API
     * @type {string}
     * @memberof Workspace
     */
    'id': string;
    /**
     * Organization unique identifier under which the workspace resides
     * @type {string}
     * @memberof Workspace
     */
    'organizationId': string;
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof Workspace
     */
    'key': string;
    /**
     * Workspace name. This name is display in the sample webApp
     * @type {string}
     * @memberof Workspace
     */
    'name': string;
    /**
     * the Workspace description
     * @type {string}
     * @memberof Workspace
     */
    'description'?: string;
    /**
     * list of dataset linked to this dataset
     * @type {Array<string>}
     * @memberof Workspace
     */
    'linkedDatasetIdList'?: Array<string>;
    /**
     * the Workspace version MAJOR.MINOR.PATCH.
     * @type {string}
     * @memberof Workspace
     */
    'version'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Workspace
     */
    'tags'?: Array<string>;
    /**
     * the user id which own this workspace. set by the API from Authentification service receved id
     * @type {string}
     * @memberof Workspace
     */
    'ownerId': string;
    /**
     * 
     * @type {WorkspaceSolution}
     * @memberof Workspace
     */
    'solution': WorkspaceSolution;
    /**
     * 
     * @type {WorkspaceWebApp}
     * @memberof Workspace
     */
    'webApp'?: WorkspaceWebApp;
    /**
     * Activate the copy of dataset on scenario creation, meaning that each scenario created in this workspace will make this copy. when false, scenario use directly the dataset specified.
     * @type {boolean}
     * @memberof Workspace
     */
    'datasetCopy'?: boolean;
    /**
     * 
     * @type {WorkspaceSecurity}
     * @memberof Workspace
     */
    'security': WorkspaceSecurity;
}
/**
 * a Workspace access control item
 * @export
 * @interface WorkspaceAccessControl
 */
export interface WorkspaceAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof WorkspaceAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof WorkspaceAccessControl
     */
    'role': string;
}
/**
 * Request object for creating a new workspace
 * @export
 * @interface WorkspaceCreateRequest
 */
export interface WorkspaceCreateRequest {
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof WorkspaceCreateRequest
     */
    'key': string;
    /**
     * Workspace name. This name is displayed in the sample webApp
     * @type {string}
     * @memberof WorkspaceCreateRequest
     */
    'name': string;
    /**
     * the Workspace description
     * @type {string}
     * @memberof WorkspaceCreateRequest
     */
    'description'?: string;
    /**
     * the Workspace version MAJOR.MINOR.PATCH.
     * @type {string}
     * @memberof WorkspaceCreateRequest
     */
    'version'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof WorkspaceCreateRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {WorkspaceSolution}
     * @memberof WorkspaceCreateRequest
     */
    'solution': WorkspaceSolution;
    /**
     * 
     * @type {WorkspaceWebApp}
     * @memberof WorkspaceCreateRequest
     */
    'webApp'?: WorkspaceWebApp;
    /**
     * Activate the copy of dataset on scenario creation
     * @type {boolean}
     * @memberof WorkspaceCreateRequest
     */
    'datasetCopy'?: boolean;
    /**
     * 
     * @type {WorkspaceSecurity}
     * @memberof WorkspaceCreateRequest
     */
    'security'?: WorkspaceSecurity;
}
/**
 * a Workspace File resource
 * @export
 * @interface WorkspaceFile
 */
export interface WorkspaceFile {
    /**
     * the Workspace File name
     * @type {string}
     * @memberof WorkspaceFile
     */
    'fileName': string;
}
/**
 * the Workspace Role
 * @export
 * @interface WorkspaceRole
 */
export interface WorkspaceRole {
    /**
     * the Workspace Role
     * @type {string}
     * @memberof WorkspaceRole
     */
    'role': string;
}
/**
 * the workspace security information
 * @export
 * @interface WorkspaceSecurity
 */
export interface WorkspaceSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof WorkspaceSecurity
     */
    'default': string;
    /**
     * the list which can access this Workspace with detailed access control information
     * @type {Array<WorkspaceAccessControl>}
     * @memberof WorkspaceSecurity
     */
    'accessControlList': Array<WorkspaceAccessControl>;
}
/**
 * the Workspace Solution configuration
 * @export
 * @interface WorkspaceSolution
 */
export interface WorkspaceSolution {
    /**
     * the Solution Id attached to this workspace
     * @type {string}
     * @memberof WorkspaceSolution
     */
    'solutionId': string;
    /**
     * the list of Solution Run Template Id to filter
     * @type {Array<string>}
     * @memberof WorkspaceSolution
     */
    'runTemplateFilter'?: Array<string>;
    /**
     * a map of RunTemplateId/DatasetId to set a default dataset for a Run Template
     * @type {{ [key: string]: any; }}
     * @memberof WorkspaceSolution
     */
    'defaultRunTemplateDataset'?: { [key: string]: any; };
}
/**
 * Request object for updating a workspace
 * @export
 * @interface WorkspaceUpdateRequest
 */
export interface WorkspaceUpdateRequest {
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof WorkspaceUpdateRequest
     */
    'key'?: string;
    /**
     * Workspace name
     * @type {string}
     * @memberof WorkspaceUpdateRequest
     */
    'name'?: string;
    /**
     * the Workspace description
     * @type {string}
     * @memberof WorkspaceUpdateRequest
     */
    'description'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof WorkspaceUpdateRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {WorkspaceSolution}
     * @memberof WorkspaceUpdateRequest
     */
    'solution'?: WorkspaceSolution;
    /**
     * 
     * @type {WorkspaceWebApp}
     * @memberof WorkspaceUpdateRequest
     */
    'webApp'?: WorkspaceWebApp;
    /**
     * Activate the copy of dataset on scenario creation
     * @type {boolean}
     * @memberof WorkspaceUpdateRequest
     */
    'datasetCopy'?: boolean;
}
/**
 * a Workspace Web Application
 * @export
 * @interface WorkspaceWebApp
 */
export interface WorkspaceWebApp {
    /**
     * the Workspace Web Application URL
     * @type {string}
     * @memberof WorkspaceWebApp
     */
    'url': string;
    /**
     * a map of iframeKey/iframeURL
     * @type {{ [key: string]: any; }}
     * @memberof WorkspaceWebApp
     */
    'iframes'?: { [key: string]: any; };
    /**
     * free form options for Web Application
     * @type {{ [key: string]: any; }}
     * @memberof WorkspaceWebApp
     */
    'options'?: { [key: string]: any; };
}

/**
 * ConnectorApi - axios parameter creator
 * @export
 */
export const ConnectorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllConnectors: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findConnectorById: async (connectorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('findConnectorById', 'connectorId', connectorId)
            const localVarPath = `/connectors/{connector_id}`
                .replace(`{${"connector_id"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerConnector: async (connector: Connector, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connector' is not null or undefined
            assertParamExists('registerConnector', 'connector', connector)
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connector, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterConnector: async (connectorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('unregisterConnector', 'connectorId', connectorId)
            const localVarPath = `/connectors/{connector_id}`
                .replace(`{${"connector_id"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorApi - functional programming interface
 * @export
 */
export const ConnectorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllConnectors(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Connector>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllConnectors(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorApi.findAllConnectors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findConnectorById(connectorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findConnectorById(connectorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorApi.findConnectorById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerConnector(connector: Connector, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerConnector(connector, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorApi.registerConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unregisterConnector(connectorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unregisterConnector(connectorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectorApi.unregisterConnector']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectorApi - factory interface
 * @export
 */
export const ConnectorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllConnectors(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Connector>> {
            return localVarFp.findAllConnectors(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findConnectorById(connectorId: string, options?: RawAxiosRequestConfig): AxiosPromise<Connector> {
            return localVarFp.findConnectorById(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerConnector(connector: Connector, options?: RawAxiosRequestConfig): AxiosPromise<Connector> {
            return localVarFp.registerConnector(connector, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterConnector(connectorId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unregisterConnector(connectorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorApi - object-oriented interface
 * @export
 * @class ConnectorApi
 * @extends {BaseAPI}
 */
export class ConnectorApi extends BaseAPI {
    /**
     * 
     * @summary List all Connectors
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public findAllConnectors(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).findAllConnectors(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a connector
     * @param {string} connectorId the Connector identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public findConnectorById(connectorId: string, options?: RawAxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).findConnectorById(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new connector
     * @param {Connector} connector the Connector to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public registerConnector(connector: Connector, options?: RawAxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).registerConnector(connector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unregister a connector
     * @param {string} connectorId the Connector identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public unregisterConnector(connectorId: string, options?: RawAxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).unregisterConnector(connectorId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatasetApi - axios parameter creator
 * @export
 */
export const DatasetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a control access to the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDatasetAccessControl: async (organizationId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('addDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'datasetAccessControl' is not null or undefined
            assertParamExists('addDatasetAccessControl', 'datasetAccessControl', datasetAccessControl)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceDatasetCompatibilityElements: async (organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'datasetId', datasetId)
            // verify required parameter 'datasetCompatibility' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'datasetCompatibility', datasetCompatibility)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/compatibility`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetCompatibility, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Not implemented!
         * @summary Copy a Dataset to another Dataset.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyDataset: async (organizationId: string, datasetCopyParameters: DatasetCopyParameters, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('copyDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetCopyParameters' is not null or undefined
            assertParamExists('copyDataset', 'datasetCopyParameters', datasetCopyParameters)
            const localVarPath = `/organizations/{organization_id}/datasets/copy`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetCopyParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset: async (organizationId: string, dataset: Dataset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createDataset', 'organizationId', organizationId)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('createDataset', 'dataset', dataset)
            const localVarPath = `/organizations/{organization_id}/datasets`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a copy of the dataset using the results of the list of queries given in parameter. Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Create a sub-dataset from the dataset in parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {SubDatasetGraphQuery} subDatasetGraphQuery the Cypher query to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubDataset: async (organizationId: string, datasetId: string, subDatasetGraphQuery: SubDatasetGraphQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSubDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('createSubDataset', 'datasetId', datasetId)
            // verify required parameter 'subDatasetGraphQuery' is not null or undefined
            assertParamExists('createSubDataset', 'subDatasetGraphQuery', subDatasetGraphQuery)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/subdataset`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subDatasetGraphQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new entities in a graph instance Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {CreateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTwingraphEntities: async (organizationId: string, datasetId: string, type: CreateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createTwingraphEntities', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('createTwingraphEntities', 'datasetId', datasetId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('createTwingraphEntities', 'type', type)
            // verify required parameter 'graphProperties' is not null or undefined
            assertParamExists('createTwingraphEntities', 'graphProperties', graphProperties)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(graphProperties, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteDataset', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete entities in a graph instance Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DeleteTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTwingraphEntities: async (organizationId: string, datasetId: string, type: DeleteTwingraphEntitiesTypeEnum, ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteTwingraphEntities', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteTwingraphEntities', 'datasetId', datasetId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('deleteTwingraphEntities', 'type', type)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('deleteTwingraphEntities', 'ids', ids)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download the compressed graph reference by the hash in a zip file Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Download a graph as a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTwingraph: async (organizationId: string, hash: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadTwingraph', 'organizationId', organizationId)
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('downloadTwingraph', 'hash', hash)
            const localVarPath = `/organizations/{organization_id}/datasets/twingraph/download/{hash}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDatasets: async (organizationId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllDatasets', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/datasets`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDatasetById: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findDatasetById', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('findDatasetById', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetAccessControl: async (organizationId: string, datasetId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getDatasetAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Dataset security information
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetSecurity: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetSecurity', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetSecurity', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Dataset security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetSecurityUsers: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetSecurityUsers', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of the import workflow lauch on the dataset\'s refresh. This endpoint needs to be called to update a dataset IngestionStatus or TwincacheStatus
         * @summary Get the dataset\'s refresh job status
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetTwingraphStatus: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetTwingraphStatus', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetTwingraphStatus', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/status`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get entities in a graph instance Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {GetTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwingraphEntities: async (organizationId: string, datasetId: string, type: GetTwingraphEntitiesTypeEnum, ids: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getTwingraphEntities', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getTwingraphEntities', 'datasetId', datasetId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getTwingraphEntities', 'type', type)
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('getTwingraphEntities', 'ids', ids)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkWorkspace: async (organizationId: string, datasetId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('linkWorkspace', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('linkWorkspace', 'datasetId', datasetId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('linkWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/link`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh dataset from parent source. At date, sources can be:      dataset (refresh from another dataset)      Azure Digital twin      Azure storage      Local File (import a new file)  During refresh, datas are overwritten Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Refresh data on dataset from dataset\'s source
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshDataset: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('refreshDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('refreshDataset', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/refresh`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllDatasetCompatibilityElements: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllDatasetCompatibilityElements', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('removeAllDatasetCompatibilityElements', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/compatibility`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatasetAccessControl: async (organizationId: string, datasetId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('removeDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeDatasetAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rollback the twingraph on a dataset after a failed refresh Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Rollback the dataset after a failed refresh
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackRefresh: async (organizationId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('rollbackRefresh', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('rollbackRefresh', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/refresh/rollback`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Datasets by tags
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDatasets: async (organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('searchDatasets', 'organizationId', organizationId)
            // verify required parameter 'datasetSearch' is not null or undefined
            assertParamExists('searchDatasets', 'datasetSearch', datasetSearch)
            const localVarPath = `/organizations/{organization_id}/datasets/search`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Dataset default security
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDatasetDefaultSecurity: async (organizationId: string, datasetId: string, datasetRole: DatasetRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setDatasetDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('setDatasetDefaultSecurity', 'datasetId', datasetId)
            // verify required parameter 'datasetRole' is not null or undefined
            assertParamExists('setDatasetDefaultSecurity', 'datasetRole', datasetRole)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Graph Identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphBatchQuery: async (organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('twingraphBatchQuery', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('twingraphBatchQuery', 'datasetId', datasetId)
            // verify required parameter 'datasetTwinGraphQuery' is not null or undefined
            assertParamExists('twingraphBatchQuery', 'datasetTwinGraphQuery', datasetTwinGraphQuery)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/batch-query`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetTwinGraphQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Async batch update by loading a CSV file on a graph instance  Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DatasetTwinGraphQuery} twinGraphQuery 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphBatchUpdate: async (organizationId: string, datasetId: string, twinGraphQuery: DatasetTwinGraphQuery, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('twingraphBatchUpdate', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('twingraphBatchUpdate', 'datasetId', datasetId)
            // verify required parameter 'twinGraphQuery' is not null or undefined
            assertParamExists('twingraphBatchUpdate', 'twinGraphQuery', twinGraphQuery)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('twingraphBatchUpdate', 'body', body)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/batch`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (twinGraphQuery !== undefined) {
                for (const [key, value] of Object.entries(twinGraphQuery)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/csv';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a query on a graph instance and return the result as a json Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Return the result of a query made on the graph instance as a json
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphQuery: async (organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('twingraphQuery', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('twingraphQuery', 'datasetId', datasetId)
            // verify required parameter 'datasetTwinGraphQuery' is not null or undefined
            assertParamExists('twingraphQuery', 'datasetTwinGraphQuery', datasetTwinGraphQuery)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetTwinGraphQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkWorkspace: async (organizationId: string, datasetId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('unlinkWorkspace', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('unlinkWorkspace', 'datasetId', datasetId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('unlinkWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/unlink`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (workspaceId !== undefined) {
                localVarQueryParameter['workspaceId'] = workspaceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset: async (organizationId: string, datasetId: string, dataset: Dataset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateDataset', 'datasetId', datasetId)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('updateDataset', 'dataset', dataset)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {DatasetRole} datasetRole The new Dataset Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatasetAccessControl: async (organizationId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'identityId', identityId)
            // verify required parameter 'datasetRole' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'datasetRole', datasetRole)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {UpdateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties The entities to update Note: This endpoint is activated only if &#x60;csm.platform.twincache.useGraphModule&#x60; property is set to true 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTwingraphEntities: async (organizationId: string, datasetId: string, type: UpdateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateTwingraphEntities', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateTwingraphEntities', 'datasetId', datasetId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('updateTwingraphEntities', 'type', type)
            // verify required parameter 'graphProperties' is not null or undefined
            assertParamExists('updateTwingraphEntities', 'graphProperties', graphProperties)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/twingraph/{type}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(graphProperties, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Upload data from zip file to dataset\'s twingraph
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTwingraph: async (organizationId: string, datasetId: string, body: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('uploadTwingraph', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('uploadTwingraph', 'datasetId', datasetId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadTwingraph', 'body', body)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetApi - functional programming interface
 * @export
 */
export const DatasetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDatasetAccessControl(organizationId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDatasetAccessControl(organizationId, datasetId, datasetAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.addDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DatasetCompatibility>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.addOrReplaceDatasetCompatibilityElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Not implemented!
         * @summary Copy a Dataset to another Dataset.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetCopyParameters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyDataset(organizationId, datasetCopyParameters, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.copyDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataset(organizationId: string, dataset: Dataset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataset(organizationId, dataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a copy of the dataset using the results of the list of queries given in parameter. Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Create a sub-dataset from the dataset in parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {SubDatasetGraphQuery} subDatasetGraphQuery the Cypher query to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSubDataset(organizationId: string, datasetId: string, subDatasetGraphQuery: SubDatasetGraphQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSubDataset(organizationId, datasetId, subDatasetGraphQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createSubDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create new entities in a graph instance Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {CreateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTwingraphEntities(organizationId: string, datasetId: string, type: CreateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTwingraphEntities(organizationId, datasetId, type, graphProperties, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createTwingraphEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataset(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.deleteDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete entities in a graph instance Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DeleteTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTwingraphEntities(organizationId: string, datasetId: string, type: DeleteTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTwingraphEntities(organizationId, datasetId, type, ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.deleteTwingraphEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download the compressed graph reference by the hash in a zip file Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Download a graph as a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadTwingraph(organizationId: string, hash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadTwingraph(organizationId, hash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.downloadTwingraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllDatasets(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllDatasets(organizationId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.findAllDatasets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDatasetById(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDatasetById(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.findDatasetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetAccessControl(organizationId, datasetId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Dataset security information
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetSecurity(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetSecurity(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Dataset security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetSecurityUsers(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetSecurityUsers(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the status of the import workflow lauch on the dataset\'s refresh. This endpoint needs to be called to update a dataset IngestionStatus or TwincacheStatus
         * @summary Get the dataset\'s refresh job status
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetTwingraphStatus(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetTwingraphStatus(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetTwingraphStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get entities in a graph instance Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {GetTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTwingraphEntities(organizationId: string, datasetId: string, type: GetTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTwingraphEntities(organizationId, datasetId, type, ids, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getTwingraphEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkWorkspace(organizationId, datasetId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.linkWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refresh dataset from parent source. At date, sources can be:      dataset (refresh from another dataset)      Azure Digital twin      Azure storage      Local File (import a new file)  During refresh, datas are overwritten Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Refresh data on dataset from dataset\'s source
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetTwinGraphInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshDataset(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.refreshDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllDatasetCompatibilityElements(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.removeAllDatasetCompatibilityElements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeDatasetAccessControl(organizationId, datasetId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.removeDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rollback the twingraph on a dataset after a failed refresh Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Rollback the dataset after a failed refresh
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rollbackRefresh(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rollbackRefresh(organizationId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.rollbackRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Datasets by tags
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDatasets(organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDatasets(organizationId, datasetSearch, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.searchDatasets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Dataset default security
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDatasetDefaultSecurity(organizationId: string, datasetId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDatasetDefaultSecurity(organizationId, datasetId, datasetRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.setDatasetDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Graph Identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async twingraphBatchQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetTwinGraphHash>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.twingraphBatchQuery(organizationId, datasetId, datasetTwinGraphQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.twingraphBatchQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Async batch update by loading a CSV file on a graph instance  Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DatasetTwinGraphQuery} twinGraphQuery 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async twingraphBatchUpdate(organizationId: string, datasetId: string, twinGraphQuery: DatasetTwinGraphQuery, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwinGraphBatchResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.twingraphBatchUpdate(organizationId, datasetId, twinGraphQuery, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.twingraphBatchUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Run a query on a graph instance and return the result as a json Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Return the result of a query made on the graph instance as a json
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async twingraphQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.twingraphQuery(organizationId, datasetId, datasetTwinGraphQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.twingraphQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlinkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlinkWorkspace(organizationId, datasetId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.unlinkWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataset(organizationId, datasetId, dataset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {DatasetRole} datasetRole The new Dataset Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDatasetAccessControl(organizationId, datasetId, identityId, datasetRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {UpdateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties The entities to update Note: This endpoint is activated only if &#x60;csm.platform.twincache.useGraphModule&#x60; property is set to true 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTwingraphEntities(organizationId: string, datasetId: string, type: UpdateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTwingraphEntities(organizationId, datasetId, type, graphProperties, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateTwingraphEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Upload data from zip file to dataset\'s twingraph
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadTwingraph(organizationId: string, datasetId: string, body: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadValidation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadTwingraph(organizationId, datasetId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.uploadTwingraph']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatasetApi - factory interface
 * @export
 */
export const DatasetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDatasetAccessControl(organizationId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<DatasetAccessControl> {
            return localVarFp.addDatasetAccessControl(organizationId, datasetId, datasetAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: RawAxiosRequestConfig): AxiosPromise<Array<DatasetCompatibility>> {
            return localVarFp.addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options).then((request) => request(axios, basePath));
        },
        /**
         * Not implemented!
         * @summary Copy a Dataset to another Dataset.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: RawAxiosRequestConfig): AxiosPromise<DatasetCopyParameters> {
            return localVarFp.copyDataset(organizationId, datasetCopyParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset(organizationId: string, dataset: Dataset, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.createDataset(organizationId, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a copy of the dataset using the results of the list of queries given in parameter. Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Create a sub-dataset from the dataset in parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {SubDatasetGraphQuery} subDatasetGraphQuery the Cypher query to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubDataset(organizationId: string, datasetId: string, subDatasetGraphQuery: SubDatasetGraphQuery, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.createSubDataset(organizationId, datasetId, subDatasetGraphQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new entities in a graph instance Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Create new entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {CreateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties the entities to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTwingraphEntities(organizationId: string, datasetId: string, type: CreateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createTwingraphEntities(organizationId, datasetId, type, graphProperties, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDataset(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete entities in a graph instance Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Delete entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DeleteTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTwingraphEntities(organizationId: string, datasetId: string, type: DeleteTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTwingraphEntities(organizationId, datasetId, type, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * Download the compressed graph reference by the hash in a zip file Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Download a graph as a zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} hash the Graph download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadTwingraph(organizationId: string, hash: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadTwingraph(organizationId, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDatasets(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Dataset>> {
            return localVarFp.findAllDatasets(organizationId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDatasetById(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.findDatasetById(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<DatasetAccessControl> {
            return localVarFp.getDatasetAccessControl(organizationId, datasetId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Dataset security information
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetSecurity(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<DatasetSecurity> {
            return localVarFp.getDatasetSecurity(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Dataset security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetSecurityUsers(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getDatasetSecurityUsers(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of the import workflow lauch on the dataset\'s refresh. This endpoint needs to be called to update a dataset IngestionStatus or TwincacheStatus
         * @summary Get the dataset\'s refresh job status
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetTwingraphStatus(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getDatasetTwingraphStatus(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get entities in a graph instance Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Get entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {GetTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<string>} ids the entities to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTwingraphEntities(organizationId: string, datasetId: string, type: GetTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getTwingraphEntities(organizationId, datasetId, type, ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.linkWorkspace(organizationId, datasetId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh dataset from parent source. At date, sources can be:      dataset (refresh from another dataset)      Azure Digital twin      Azure storage      Local File (import a new file)  During refresh, datas are overwritten Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Refresh data on dataset from dataset\'s source
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<DatasetTwinGraphInfo> {
            return localVarFp.refreshDataset(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeAllDatasetCompatibilityElements(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeDatasetAccessControl(organizationId, datasetId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rollback the twingraph on a dataset after a failed refresh Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Rollback the dataset after a failed refresh
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackRefresh(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.rollbackRefresh(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Datasets by tags
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDatasets(organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Dataset>> {
            return localVarFp.searchDatasets(organizationId, datasetSearch, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Dataset default security
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDatasetDefaultSecurity(organizationId: string, datasetId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig): AxiosPromise<DatasetSecurity> {
            return localVarFp.setDatasetDefaultSecurity(organizationId, datasetId, datasetRole, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a query on a graph instance and return the result as a zip file in async mode Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Run a query on a graph instance and return the result as a zip file in async mode
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Graph Identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphBatchQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig): AxiosPromise<DatasetTwinGraphHash> {
            return localVarFp.twingraphBatchQuery(organizationId, datasetId, datasetTwinGraphQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Async batch update by loading a CSV file on a graph instance  Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Async batch update by loading a CSV file on a graph instance 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {DatasetTwinGraphQuery} twinGraphQuery 
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphBatchUpdate(organizationId: string, datasetId: string, twinGraphQuery: DatasetTwinGraphQuery, body: File, options?: RawAxiosRequestConfig): AxiosPromise<TwinGraphBatchResult> {
            return localVarFp.twingraphBatchUpdate(organizationId, datasetId, twinGraphQuery, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a query on a graph instance and return the result as a json Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Return the result of a query made on the graph instance as a json
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twingraphQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.twingraphQuery(organizationId, datasetId, datasetTwinGraphQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} workspaceId workspace id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.unlinkWorkspace(organizationId, datasetId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.updateDataset(organizationId, datasetId, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {DatasetRole} datasetRole The new Dataset Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig): AxiosPromise<DatasetAccessControl> {
            return localVarFp.updateDatasetAccessControl(organizationId, datasetId, identityId, datasetRole, options).then((request) => request(axios, basePath));
        },
        /**
         * update entities in a graph instance
         * @summary Update entities in a graph instance
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset Identifier
         * @param {UpdateTwingraphEntitiesTypeEnum} type the entity model type
         * @param {Array<GraphProperties>} graphProperties The entities to update Note: This endpoint is activated only if &#x60;csm.platform.twincache.useGraphModule&#x60; property is set to true 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTwingraphEntities(organizationId: string, datasetId: string, type: UpdateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.updateTwingraphEntities(organizationId, datasetId, type, graphProperties, options).then((request) => request(axios, basePath));
        },
        /**
         * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
         * @summary Upload data from zip file to dataset\'s twingraph
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {File} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTwingraph(organizationId: string, datasetId: string, body: File, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadValidation> {
            return localVarFp.uploadTwingraph(organizationId, datasetId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetApi - object-oriented interface
 * @export
 * @class DatasetApi
 * @extends {BaseAPI}
 */
export class DatasetApi extends BaseAPI {
    /**
     * 
     * @summary Add a control access to the Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public addDatasetAccessControl(organizationId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).addDatasetAccessControl(organizationId, datasetId, datasetAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Dataset Compatibility elements.
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Not implemented!
     * @summary Copy a Dataset to another Dataset.
     * @param {string} organizationId the Organization identifier
     * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).copyDataset(organizationId, datasetCopyParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Dataset
     * @param {string} organizationId the Organization identifier
     * @param {Dataset} dataset the Dataset to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createDataset(organizationId: string, dataset: Dataset, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createDataset(organizationId, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a copy of the dataset using the results of the list of queries given in parameter. Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
     * @summary Create a sub-dataset from the dataset in parameter
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {SubDatasetGraphQuery} subDatasetGraphQuery the Cypher query to filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createSubDataset(organizationId: string, datasetId: string, subDatasetGraphQuery: SubDatasetGraphQuery, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createSubDataset(organizationId, datasetId, subDatasetGraphQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create new entities in a graph instance Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
     * @summary Create new entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {CreateTwingraphEntitiesTypeEnum} type the entity model type
     * @param {Array<GraphProperties>} graphProperties the entities to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createTwingraphEntities(organizationId: string, datasetId: string, type: CreateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createTwingraphEntities(organizationId, datasetId, type, graphProperties, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteDataset(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete entities in a graph instance Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
     * @summary Delete entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {DeleteTwingraphEntitiesTypeEnum} type the entity model type
     * @param {Array<string>} ids the entities to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteTwingraphEntities(organizationId: string, datasetId: string, type: DeleteTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteTwingraphEntities(organizationId, datasetId, type, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download the compressed graph reference by the hash in a zip file Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
     * @summary Download a graph as a zip file
     * @param {string} organizationId the Organization identifier
     * @param {string} hash the Graph download identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public downloadTwingraph(organizationId: string, hash: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).downloadTwingraph(organizationId, hash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Datasets
     * @param {string} organizationId the Organization identifier
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public findAllDatasets(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).findAllDatasets(organizationId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public findDatasetById(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).findDatasetById(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetAccessControl(organizationId, datasetId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Dataset security information
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetSecurity(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetSecurity(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Dataset security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetSecurityUsers(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetSecurityUsers(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of the import workflow lauch on the dataset\'s refresh. This endpoint needs to be called to update a dataset IngestionStatus or TwincacheStatus
     * @summary Get the dataset\'s refresh job status
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetTwingraphStatus(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetTwingraphStatus(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get entities in a graph instance Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
     * @summary Get entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {GetTwingraphEntitiesTypeEnum} type the entity model type
     * @param {Array<string>} ids the entities to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getTwingraphEntities(organizationId: string, datasetId: string, type: GetTwingraphEntitiesTypeEnum, ids: Array<string>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getTwingraphEntities(organizationId, datasetId, type, ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} workspaceId workspace id to be linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public linkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).linkWorkspace(organizationId, datasetId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh dataset from parent source. At date, sources can be:      dataset (refresh from another dataset)      Azure Digital twin      Azure storage      Local File (import a new file)  During refresh, datas are overwritten Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
     * @summary Refresh data on dataset from dataset\'s source
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public refreshDataset(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).refreshDataset(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Dataset Compatibility elements from the Dataset specified
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).removeAllDatasetCompatibilityElements(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public removeDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).removeDatasetAccessControl(organizationId, datasetId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rollback the twingraph on a dataset after a failed refresh Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
     * @summary Rollback the dataset after a failed refresh
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public rollbackRefresh(organizationId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).rollbackRefresh(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Datasets by tags
     * @param {string} organizationId the Organization identifier
     * @param {DatasetSearch} datasetSearch the Dataset search parameters
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public searchDatasets(organizationId: string, datasetSearch: DatasetSearch, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).searchDatasets(organizationId, datasetSearch, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Dataset default security
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public setDatasetDefaultSecurity(organizationId: string, datasetId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).setDatasetDefaultSecurity(organizationId, datasetId, datasetRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a query on a graph instance and return the result as a zip file in async mode Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
     * @summary Run a query on a graph instance and return the result as a zip file in async mode
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Graph Identifier
     * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public twingraphBatchQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).twingraphBatchQuery(organizationId, datasetId, datasetTwinGraphQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Async batch update by loading a CSV file on a graph instance  Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
     * @summary Async batch update by loading a CSV file on a graph instance 
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {DatasetTwinGraphQuery} twinGraphQuery 
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public twingraphBatchUpdate(organizationId: string, datasetId: string, twinGraphQuery: DatasetTwinGraphQuery, body: File, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).twingraphBatchUpdate(organizationId, datasetId, twinGraphQuery, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a query on a graph instance and return the result as a json Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
     * @summary Return the result of a query made on the graph instance as a json
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {DatasetTwinGraphQuery} datasetTwinGraphQuery the query to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public twingraphQuery(organizationId: string, datasetId: string, datasetTwinGraphQuery: DatasetTwinGraphQuery, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).twingraphQuery(organizationId, datasetId, datasetTwinGraphQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} workspaceId workspace id to be linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public unlinkWorkspace(organizationId: string, datasetId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).unlinkWorkspace(organizationId, datasetId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {Dataset} dataset the new Dataset details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateDataset(organizationId, datasetId, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} identityId the User identifier
     * @param {DatasetRole} datasetRole The new Dataset Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateDatasetAccessControl(organizationId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateDatasetAccessControl(organizationId, datasetId, identityId, datasetRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update entities in a graph instance
     * @summary Update entities in a graph instance
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset Identifier
     * @param {UpdateTwingraphEntitiesTypeEnum} type the entity model type
     * @param {Array<GraphProperties>} graphProperties The entities to update Note: This endpoint is activated only if &#x60;csm.platform.twincache.useGraphModule&#x60; property is set to true 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateTwingraphEntities(organizationId: string, datasetId: string, type: UpdateTwingraphEntitiesTypeEnum, graphProperties: Array<GraphProperties>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateTwingraphEntities(organizationId, datasetId, type, graphProperties, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To create a new graph from flat files,  you need to create a Zip file. This Zip file must countain two folders named Edges and Nodes.  .zip hierarchy: *main_folder/Nodes *main_folder/Edges  In each folder you can place one or multiple csv files containing your Nodes or Edges data.  Your csv files must follow the following header (column name) requirements:  The Nodes CSVs requires at least one column (the 1st).Column name = \'id\'. It will represent the nodes ID Ids must be populated with string  The Edges CSVs require three columns named, in order, * source * target * id  those colomns represent * The source of the edge * The target of the edge * The id of the edge  All following columns content are up to you. Note: This endpoint is activated only if `csm.platform.twincache.useGraphModule` property is set to true 
     * @summary Upload data from zip file to dataset\'s twingraph
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {File} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public uploadTwingraph(organizationId: string, datasetId: string, body: File, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).uploadTwingraph(organizationId, datasetId, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CreateTwingraphEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type CreateTwingraphEntitiesTypeEnum = typeof CreateTwingraphEntitiesTypeEnum[keyof typeof CreateTwingraphEntitiesTypeEnum];
/**
 * @export
 */
export const DeleteTwingraphEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type DeleteTwingraphEntitiesTypeEnum = typeof DeleteTwingraphEntitiesTypeEnum[keyof typeof DeleteTwingraphEntitiesTypeEnum];
/**
 * @export
 */
export const GetTwingraphEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type GetTwingraphEntitiesTypeEnum = typeof GetTwingraphEntitiesTypeEnum[keyof typeof GetTwingraphEntitiesTypeEnum];
/**
 * @export
 */
export const UpdateTwingraphEntitiesTypeEnum = {
    Node: 'node',
    Relationship: 'relationship'
} as const;
export type UpdateTwingraphEntitiesTypeEnum = typeof UpdateTwingraphEntitiesTypeEnum[keyof typeof UpdateTwingraphEntitiesTypeEnum];


/**
 * MetaApi - axios parameter creator
 * @export
 */
export const MetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get various information about the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        about: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/about`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetaApi - functional programming interface
 * @export
 */
export const MetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get various information about the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async about(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AboutInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.about(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaApi.about']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetaApi - factory interface
 * @export
 */
export const MetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetaApiFp(configuration)
    return {
        /**
         * 
         * @summary Get various information about the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        about(options?: RawAxiosRequestConfig): AxiosPromise<AboutInfo> {
            return localVarFp.about(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetaApi - object-oriented interface
 * @export
 * @class MetaApi
 * @extends {BaseAPI}
 */
export class MetaApi extends BaseAPI {
    /**
     * 
     * @summary Get various information about the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public about(options?: RawAxiosRequestConfig) {
        return MetaApiFp(this.configuration).about(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new organization
         * @param {OrganizationCreateRequest} organizationCreateRequest the Organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (organizationCreateRequest: OrganizationCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationCreateRequest' is not null or undefined
            assertParamExists('createOrganization', 'organizationCreateRequest', organizationCreateRequest)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationAccessControl: async (organizationId: string, organizationAccessControl: OrganizationAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'organizationAccessControl' is not null or undefined
            assertParamExists('createOrganizationAccessControl', 'organizationAccessControl', organizationAccessControl)
            const localVarPath = `/organizations/{organization_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationAccessControl: async (organizationId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('deleteOrganizationAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAccessControl: async (organizationId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getOrganizationAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationPermissions: async (organizationId: string, role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationPermissions', 'organizationId', organizationId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getOrganizationPermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurity: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationSecurity', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationSecurityUsers: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationSecurityUsers', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationUpdateRequest} organizationUpdateRequest the new Organization details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (organizationId: string, organizationUpdateRequest: OrganizationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganization', 'organizationId', organizationId)
            // verify required parameter 'organizationUpdateRequest' is not null or undefined
            assertParamExists('updateOrganization', 'organizationUpdateRequest', organizationUpdateRequest)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationAccessControl: async (organizationId: string, identityId: string, organizationRole: OrganizationRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'identityId', identityId)
            // verify required parameter 'organizationRole' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'organizationRole', organizationRole)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the Organization default security
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationDefaultSecurity: async (organizationId: string, organizationRole: OrganizationRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'organizationRole' is not null or undefined
            assertParamExists('updateOrganizationDefaultSecurity', 'organizationRole', organizationRole)
            const localVarPath = `/organizations/{organization_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new organization
         * @param {OrganizationCreateRequest} organizationCreateRequest the Organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(organizationCreateRequest: OrganizationCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganization(organizationCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.createOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationAccessControl(organizationId, organizationAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.createOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganization(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.deleteOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationAccessControl(organizationId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.deleteOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationAccessControl(organizationId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationPermissions(organizationId: string, role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationPermissions(organizationId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationSecurity(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationSecurity(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationSecurityUsers(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationSecurityUsers(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.listOrganizationSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizations(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizations(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.listOrganizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ComponentRolePermissions>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.listPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationUpdateRequest} organizationUpdateRequest the new Organization details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(organizationId: string, organizationUpdateRequest: OrganizationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(organizationId, organizationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationAccessControl(organizationId, identityId, organizationRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the Organization default security
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationDefaultSecurity(organizationId, organizationRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateOrganizationDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new organization
         * @param {OrganizationCreateRequest} organizationCreateRequest the Organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organizationCreateRequest: OrganizationCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.createOrganization(organizationCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.createOrganizationAccessControl(organizationId, organizationAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOrganizationAccessControl(organizationId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.getOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.getOrganizationAccessControl(organizationId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationPermissions(organizationId: string, role: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getOrganizationPermissions(organizationId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurity(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationSecurity> {
            return localVarFp.getOrganizationSecurity(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationSecurityUsers(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listOrganizationSecurityUsers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Organization>> {
            return localVarFp.listOrganizations(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions(options?: RawAxiosRequestConfig): AxiosPromise<Array<ComponentRolePermissions>> {
            return localVarFp.listPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationUpdateRequest} organizationUpdateRequest the new Organization details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organizationId: string, organizationUpdateRequest: OrganizationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.updateOrganization(organizationId, organizationUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} identityId the User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.updateOrganizationAccessControl(organizationId, identityId, organizationRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the Organization default security
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationSecurity> {
            return localVarFp.updateOrganizationDefaultSecurity(organizationId, organizationRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * 
     * @summary Create a new organization
     * @param {OrganizationCreateRequest} organizationCreateRequest the Organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrganization(organizationCreateRequest: OrganizationCreateRequest, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).createOrganization(organizationCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a control access to the Organization
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationAccessControl} organizationAccessControl the new Organization security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).createOrganizationAccessControl(organizationId, organizationAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an organization
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteOrganization(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).deleteOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization
     * @param {string} organizationId the Organization identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).deleteOrganizationAccessControl(organizationId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an Organization
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganization(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Organization
     * @param {string} organizationId the Organization identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationAccessControl(organizationId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization permissions by given role
     * @param {string} organizationId the Organization identifier
     * @param {string} role the Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationPermissions(organizationId: string, role: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationPermissions(organizationId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization security information
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationSecurity(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationSecurity(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization security users list
     * @param {string} organizationId The Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public listOrganizationSecurityUsers(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).listOrganizationSecurityUsers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Organizations
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public listOrganizations(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).listOrganizations(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all permissions per components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public listPermissions(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).listPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an Organization
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationUpdateRequest} organizationUpdateRequest the new Organization details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganization(organizationId: string, organizationUpdateRequest: OrganizationUpdateRequest, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganization(organizationId, organizationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for an Organization
     * @param {string} organizationId the Organization identifier
     * @param {string} identityId the User identifier
     * @param {OrganizationRole} organizationRole The new Organization Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganizationAccessControl(organizationId, identityId, organizationRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the Organization default security
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganizationDefaultSecurity(organizationId, organizationRole, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RunApi - axios parameter creator
 * @export
 */
export const RunApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('deleteRun', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('deleteRun', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRun', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRun', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the logs for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogs: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunLogs', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunLogs', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunLogs', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRunLogs', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/logs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the status for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatus: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunStatus', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunStatus', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunStatus', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRunStatus', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/status`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the list of Runs for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns: async (organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listRuns', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listRuns', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('listRuns', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary query the run data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {RunDataQuery} runDataQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryRunData: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('queryRunData', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('queryRunData', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('queryRunData', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('queryRunData', 'runId', runId)
            // verify required parameter 'runDataQuery' is not null or undefined
            assertParamExists('queryRunData', 'runDataQuery', runDataQuery)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/data/query`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runDataQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send data associated to a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRunData: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('sendRunData', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('sendRunData', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('sendRunData', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('sendRunData', 'runId', runId)
            // verify required parameter 'sendRunDataRequest' is not null or undefined
            assertParamExists('sendRunData', 'sendRunDataRequest', sendRunDataRequest)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/data/send`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendRunDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunApi - functional programming interface
 * @export
 */
export const RunApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRun(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.deleteRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Run>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRun(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.getRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the logs for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunLogs(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunLogs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunLogs(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.getRunLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the status for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunStatus(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunStatus(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.getRunStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the list of Runs for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuns(organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Run>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuns(organizationId, workspaceId, runnerId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.listRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary query the run data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {RunDataQuery} runDataQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryRunData(organizationId, workspaceId, runnerId, runId, runDataQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.queryRunData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send data associated to a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendRunData(organizationId, workspaceId, runnerId, runId, sendRunDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.sendRunData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RunApi - factory interface
 * @export
 */
export const RunApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): AxiosPromise<Run> {
            return localVarFp.getRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the logs for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogs(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunLogs> {
            return localVarFp.getRunLogs(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the status for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatus(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunStatus> {
            return localVarFp.getRunStatus(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the list of Runs for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Run>> {
            return localVarFp.listRuns(organizationId, workspaceId, runnerId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary query the run data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {RunDataQuery} runDataQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options?: RawAxiosRequestConfig): AxiosPromise<QueryResult> {
            return localVarFp.queryRunData(organizationId, workspaceId, runnerId, runId, runDataQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send data associated to a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunData> {
            return localVarFp.sendRunData(organizationId, workspaceId, runnerId, runId, sendRunDataRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunApi - object-oriented interface
 * @export
 * @class RunApi
 * @extends {BaseAPI}
 */
export class RunApi extends BaseAPI {
    /**
     * 
     * @summary Delete a run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public deleteRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).deleteRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public getRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).getRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the logs for the Run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public getRunLogs(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).getRunLogs(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the status for the Run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public getRunStatus(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).getRunStatus(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the list of Runs for the Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public listRuns(organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).listRuns(organizationId, workspaceId, runnerId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary query the run data
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {RunDataQuery} runDataQuery the query to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public queryRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).queryRunData(organizationId, workspaceId, runnerId, runId, runDataQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send data associated to a run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public sendRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).sendRunData(organizationId, workspaceId, runnerId, runId, sendRunDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RunnerApi - axios parameter creator
 * @export
 */
export const RunnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a control access to the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('addRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'runnerAccessControl' is not null or undefined
            assertParamExists('addRunnerAccessControl', 'runnerAccessControl', runnerAccessControl)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Runner} runner the Runner to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunner: async (organizationId: string, workspaceId: string, runner: Runner, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runner' is not null or undefined
            assertParamExists('createRunner', 'runner', runner)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunner: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('deleteRunner', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunner: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunner', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Runner permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerPermissions: async (organizationId: string, workspaceId: string, runnerId: string, role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerPermissions', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunnerPermissions', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerPermissions', 'runnerId', runnerId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getRunnerPermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Runner security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerSecurity: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunnerSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerSecurity', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Runner security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerSecurityUsers: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunnerSecurityUsers', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerSecurityUsers', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Runners
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunners: async (organizationId: string, workspaceId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listRunners', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listRunners', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('removeRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('removeRunnerAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Runner default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRunnerDefaultSecurity: async (organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('setRunnerDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('setRunnerDefaultSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('setRunnerDefaultSecurity', 'runnerId', runnerId)
            // verify required parameter 'runnerRole' is not null or undefined
            assertParamExists('setRunnerDefaultSecurity', 'runnerRole', runnerRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a run with runner parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRun: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('startRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('startRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('startRun', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/start`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop the last run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('stopRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('stopRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('stopRun', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/stop`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {Runner} runner the new Runner details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunner: async (organizationId: string, workspaceId: string, runnerId: string, runner: Runner, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('updateRunner', 'runnerId', runnerId)
            // verify required parameter 'runner' is not null or undefined
            assertParamExists('updateRunner', 'runner', runner)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {RunnerRole} runnerRole The new Runner Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'identityId', identityId)
            // verify required parameter 'runnerRole' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'runnerRole', runnerRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunnerApi - functional programming interface
 * @export
 */
export const RunnerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunnerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRunnerAccessControl(organizationId, workspaceId, runnerId, runnerAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.addRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Runner} runner the Runner to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRunner(organizationId: string, workspaceId: string, runner: Runner, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Runner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRunner(organizationId, workspaceId, runner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.createRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRunner(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.deleteRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of an runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Runner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunner(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Runner permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerPermissions(organizationId: string, workspaceId: string, runnerId: string, role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerPermissions(organizationId, workspaceId, runnerId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunnerPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Runner security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerSecurity(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerSecurity(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunnerSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Runner security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerSecurityUsers(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerSecurityUsers(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunnerSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Runners
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRunners(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Runner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRunners(organizationId, workspaceId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.listRunners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.removeRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Runner default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setRunnerDefaultSecurity(organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setRunnerDefaultSecurity(organizationId, workspaceId, runnerId, runnerRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.setRunnerDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Start a run with runner parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRun(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.startRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stop the last run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopRun(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.stopRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {Runner} runner the new Runner details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRunner(organizationId: string, workspaceId: string, runnerId: string, runner: Runner, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Runner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRunner(organizationId, workspaceId, runnerId, runner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.updateRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {RunnerRole} runnerRole The new Runner Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, runnerRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.updateRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RunnerApi - factory interface
 * @export
 */
export const RunnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunnerApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a control access to the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<RunnerAccessControl> {
            return localVarFp.addRunnerAccessControl(organizationId, workspaceId, runnerId, runnerAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Runner} runner the Runner to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunner(organizationId: string, workspaceId: string, runner: Runner, options?: RawAxiosRequestConfig): AxiosPromise<Runner> {
            return localVarFp.createRunner(organizationId, workspaceId, runner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRunner(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<Runner> {
            return localVarFp.getRunner(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunnerAccessControl> {
            return localVarFp.getRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Runner permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerPermissions(organizationId: string, workspaceId: string, runnerId: string, role: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getRunnerPermissions(organizationId, workspaceId, runnerId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Runner security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerSecurity(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunnerSecurity> {
            return localVarFp.getRunnerSecurity(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Runner security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerSecurityUsers(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getRunnerSecurityUsers(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Runners
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunners(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Runner>> {
            return localVarFp.listRunners(organizationId, workspaceId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Runner default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRunnerDefaultSecurity(organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig): AxiosPromise<RunnerSecurity> {
            return localVarFp.setRunnerDefaultSecurity(organizationId, workspaceId, runnerId, runnerRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a run with runner parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatedRun> {
            return localVarFp.startRun(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop the last run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stopRun(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {Runner} runner the new Runner details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunner(organizationId: string, workspaceId: string, runnerId: string, runner: Runner, options?: RawAxiosRequestConfig): AxiosPromise<Runner> {
            return localVarFp.updateRunner(organizationId, workspaceId, runnerId, runner, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {RunnerRole} runnerRole The new Runner Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig): AxiosPromise<RunnerAccessControl> {
            return localVarFp.updateRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, runnerRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunnerApi - object-oriented interface
 * @export
 * @class RunnerApi
 * @extends {BaseAPI}
 */
export class RunnerApi extends BaseAPI {
    /**
     * 
     * @summary Add a control access to the Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public addRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).addRunnerAccessControl(organizationId, workspaceId, runnerId, runnerAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {Runner} runner the Runner to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public createRunner(organizationId: string, workspaceId: string, runner: Runner, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).createRunner(organizationId, workspaceId, runner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public deleteRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).deleteRunner(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunner(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Runner permission by given role
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} role the Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerPermissions(organizationId: string, workspaceId: string, runnerId: string, role: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerPermissions(organizationId, workspaceId, runnerId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Runner security information
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerSecurity(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerSecurity(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Runner security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerSecurityUsers(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerSecurityUsers(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Runners
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public listRunners(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).listRunners(organizationId, workspaceId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public removeRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).removeRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Runner default security
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public setRunnerDefaultSecurity(organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).setRunnerDefaultSecurity(organizationId, workspaceId, runnerId, runnerRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a run with runner parameters
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public startRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).startRun(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop the last run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public stopRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).stopRun(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {Runner} runner the new Runner details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public updateRunner(organizationId: string, workspaceId: string, runnerId: string, runner: Runner, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).updateRunner(organizationId, workspaceId, runnerId, runner, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} identityId the User identifier
     * @param {RunnerRole} runnerRole The new Runner Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public updateRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).updateRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, runnerRole, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SolutionApi - axios parameter creator
 * @export
 */
export const SolutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new solution
         * @param {string} organizationId the Organization identifier
         * @param {SolutionCreateRequest} solutionCreateRequest the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolution: async (organizationId: string, solutionCreateRequest: SolutionCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionCreateRequest' is not null or undefined
            assertParamExists('createSolution', 'solutionCreateRequest', solutionCreateRequest)
            const localVarPath = `/organizations/{organization_id}/solutions`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionAccessControl} solutionAccessControl Access control to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolutionAccessControl: async (organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('createSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'solutionAccessControl' is not null or undefined
            assertParamExists('createSolutionAccessControl', 'solutionAccessControl', solutionAccessControl)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolution: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolution', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionAccessControl: async (organizationId: string, solutionId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('deleteSolutionAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all parameter groups from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionParameterGroups: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolutionParameterGroups', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolutionParameterGroups', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all parameters from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionParameters: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolutionParameters', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolutionParameters', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionRunTemplate: async (organizationId: string, solutionId: string, runTemplateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'runTemplateId', runTemplateId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates/{run_template_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all run templates from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionRunTemplates: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplates', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplates', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolution: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getSolution', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionAccessControl: async (organizationId: string, solutionId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getSolutionAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get solution security information
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionSecurity: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getSolutionSecurity', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getSolutionSecurity', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List solution security users
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSolutionSecurityUsers: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listSolutionSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('listSolutionSecurityUsers', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] Page number to query (zero-based indexing)
         * @param {number} [size] Number of records per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSolutions: async (organizationId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listSolutions', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/solutions`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionUpdateRequest} solutionUpdateRequest the new Solution details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolution: async (organizationId: string, solutionId: string, solutionUpdateRequest: SolutionUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolution', 'solutionId', solutionId)
            // verify required parameter 'solutionUpdateRequest' is not null or undefined
            assertParamExists('updateSolution', 'solutionUpdateRequest', solutionUpdateRequest)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {SolutionRole} solutionRole Access control updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionAccessControl: async (organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'identityId', identityId)
            // verify required parameter 'solutionRole' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'solutionRole', solutionRole)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update solution default security
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionRole} solutionRole This changes the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionDefaultSecurity: async (organizationId: string, solutionId: string, solutionRole: SolutionRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionDefaultSecurity', 'solutionId', solutionId)
            // verify required parameter 'solutionRole' is not null or undefined
            assertParamExists('updateSolutionDefaultSecurity', 'solutionRole', solutionRole)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update solution parameter groups
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup Parameter groups to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionParameterGroups: async (organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionParameterGroups', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionParameterGroups', 'solutionId', solutionId)
            // verify required parameter 'runTemplateParameterGroup' is not null or undefined
            assertParamExists('updateSolutionParameterGroups', 'runTemplateParameterGroup', runTemplateParameterGroup)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateParameterGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update solution parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter Parameters to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionParameters: async (organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionParameters', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionParameters', 'solutionId', solutionId)
            // verify required parameter 'runTemplateParameter' is not null or undefined
            assertParamExists('updateSolutionParameters', 'runTemplateParameter', runTemplateParameter)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate Run template updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionRunTemplate: async (organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'runTemplateId', runTemplateId)
            // verify required parameter 'runTemplate' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'runTemplate', runTemplate)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates/{run_template_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update solution run templates
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate Run templates to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionRunTemplates: async (organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionRunTemplates', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionRunTemplates', 'solutionId', solutionId)
            // verify required parameter 'runTemplate' is not null or undefined
            assertParamExists('updateSolutionRunTemplates', 'runTemplate', runTemplate)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SolutionApi - functional programming interface
 * @export
 */
export const SolutionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SolutionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new solution
         * @param {string} organizationId the Organization identifier
         * @param {SolutionCreateRequest} solutionCreateRequest the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSolution(organizationId: string, solutionCreateRequest: SolutionCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSolution(organizationId, solutionCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.createSolution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionAccessControl} solutionAccessControl Access control to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSolutionAccessControl(organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSolutionAccessControl(organizationId, solutionId, solutionAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.createSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolution(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolutionAccessControl(organizationId, solutionId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete all parameter groups from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolutionParameterGroups(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolutionParameterGroups(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolutionParameterGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete all parameters from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolutionParameters(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolutionParameters(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolutionParameters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolutionRunTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete all run templates from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolutionRunTemplates(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolutionRunTemplates(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolutionRunTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolution(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getSolution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolutionAccessControl(organizationId, solutionId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get solution security information
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolutionSecurity(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolutionSecurity(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getSolutionSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List solution security users
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSolutionSecurityUsers(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSolutionSecurityUsers(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.listSolutionSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] Page number to query (zero-based indexing)
         * @param {number} [size] Number of records per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSolutions(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Solution>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSolutions(organizationId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.listSolutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionUpdateRequest} solutionUpdateRequest the new Solution details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolution(organizationId: string, solutionId: string, solutionUpdateRequest: SolutionUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolution(organizationId, solutionId, solutionUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {SolutionRole} solutionRole Access control updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionAccessControl(organizationId, solutionId, identityId, solutionRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update solution default security
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionRole} solutionRole This changes the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionDefaultSecurity(organizationId: string, solutionId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionDefaultSecurity(organizationId, solutionId, solutionRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update solution parameter groups
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup Parameter groups to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplateParameterGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionParameterGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update solution parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter Parameters to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplateParameter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionParameters(organizationId, solutionId, runTemplateParameter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionParameters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate Run template updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionRunTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update solution run templates
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate Run templates to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionRunTemplates(organizationId, solutionId, runTemplate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionRunTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SolutionApi - factory interface
 * @export
 */
export const SolutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SolutionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new solution
         * @param {string} organizationId the Organization identifier
         * @param {SolutionCreateRequest} solutionCreateRequest the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolution(organizationId: string, solutionCreateRequest: SolutionCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Solution> {
            return localVarFp.createSolution(organizationId, solutionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionAccessControl} solutionAccessControl Access control to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolutionAccessControl(organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<SolutionAccessControl> {
            return localVarFp.createSolutionAccessControl(organizationId, solutionId, solutionAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSolution(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all parameter groups from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionParameterGroups(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSolutionParameterGroups(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all parameters from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionParameters(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSolutionParameters(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all run templates from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionRunTemplates(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSolutionRunTemplates(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Solution> {
            return localVarFp.getSolution(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<SolutionAccessControl> {
            return localVarFp.getSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get solution security information
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionSecurity(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<SolutionSecurity> {
            return localVarFp.getSolutionSecurity(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List solution security users
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSolutionSecurityUsers(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listSolutionSecurityUsers(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] Page number to query (zero-based indexing)
         * @param {number} [size] Number of records per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSolutions(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Solution>> {
            return localVarFp.listSolutions(organizationId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionUpdateRequest} solutionUpdateRequest the new Solution details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolution(organizationId: string, solutionId: string, solutionUpdateRequest: SolutionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Solution> {
            return localVarFp.updateSolution(organizationId, solutionId, solutionUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId the User identifier
         * @param {SolutionRole} solutionRole Access control updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig): AxiosPromise<SolutionAccessControl> {
            return localVarFp.updateSolutionAccessControl(organizationId, solutionId, identityId, solutionRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update solution default security
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionRole} solutionRole This changes the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionDefaultSecurity(organizationId: string, solutionId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig): AxiosPromise<SolutionSecurity> {
            return localVarFp.updateSolutionDefaultSecurity(organizationId, solutionId, solutionRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update solution parameter groups
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup Parameter groups to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunTemplateParameterGroup>> {
            return localVarFp.updateSolutionParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update solution parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter Parameters to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunTemplateParameter>> {
            return localVarFp.updateSolutionParameters(organizationId, solutionId, runTemplateParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate Run template updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunTemplate>> {
            return localVarFp.updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update solution run templates
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate Run templates to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunTemplate>> {
            return localVarFp.updateSolutionRunTemplates(organizationId, solutionId, runTemplate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SolutionApi - object-oriented interface
 * @export
 * @class SolutionApi
 * @extends {BaseAPI}
 */
export class SolutionApi extends BaseAPI {
    /**
     * 
     * @summary Create a new solution
     * @param {string} organizationId the Organization identifier
     * @param {SolutionCreateRequest} solutionCreateRequest the Solution to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public createSolution(organizationId: string, solutionCreateRequest: SolutionCreateRequest, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).createSolution(organizationId, solutionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create solution access control
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {SolutionAccessControl} solutionAccessControl Access control to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public createSolutionAccessControl(organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).createSolutionAccessControl(organizationId, solutionId, solutionAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolution(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete solution access control
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all parameter groups from the solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolutionParameterGroups(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolutionParameterGroups(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all parameters from the solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolutionParameters(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolutionParameters(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific run template
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all run templates from the solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolutionRunTemplates(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolutionRunTemplates(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getSolution(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get solution access control
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get solution security information
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getSolutionSecurity(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getSolutionSecurity(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List solution security users
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public listSolutionSecurityUsers(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).listSolutionSecurityUsers(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Solutions
     * @param {string} organizationId the Organization identifier
     * @param {number} [page] Page number to query (zero-based indexing)
     * @param {number} [size] Number of records per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public listSolutions(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).listSolutions(organizationId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {SolutionUpdateRequest} solutionUpdateRequest the new Solution details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolution(organizationId: string, solutionId: string, solutionUpdateRequest: SolutionUpdateRequest, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolution(organizationId, solutionId, solutionUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update solution access control
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} identityId the User identifier
     * @param {SolutionRole} solutionRole Access control updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionAccessControl(organizationId, solutionId, identityId, solutionRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update solution default security
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {SolutionRole} solutionRole This changes the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionDefaultSecurity(organizationId: string, solutionId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionDefaultSecurity(organizationId, solutionId, solutionRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update solution parameter groups
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup Parameter groups to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update solution parameters
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplateParameter>} runTemplateParameter Parameters to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionParameters(organizationId, solutionId, runTemplateParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific run template
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {RunTemplate} runTemplate Run template updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update solution run templates
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplate>} runTemplate Run templates to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionRunTemplates(organizationId, solutionId, runTemplate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspaceApi - axios parameter creator
 * @export
 */
export const WorkspaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatasetLink: async (organizationId: string, workspaceId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createDatasetLink', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createDatasetLink', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('createDatasetLink', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/link`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (datasetId !== undefined) {
                localVarQueryParameter['datasetId'] = datasetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {WorkspaceCreateRequest} workspaceCreateRequest the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace: async (organizationId: string, workspaceCreateRequest: WorkspaceCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceCreateRequest' is not null or undefined
            assertParamExists('createWorkspace', 'workspaceCreateRequest', workspaceCreateRequest)
            const localVarPath = `/organizations/{organization_id}/workspaces`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceAccessControl: async (organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceAccessControl' is not null or undefined
            assertParamExists('createWorkspaceAccessControl', 'workspaceAccessControl', workspaceAccessControl)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {File} file The file to upload
         * @param {boolean} [overwrite] Whether to overwrite an existing file
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceFile: async (organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createWorkspaceFile', 'file', file)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


            if (overwrite !== undefined) { 
                localVarFormParams.append('overwrite', String(overwrite) as any);
            }
    
            if (destination !== undefined) { 
                localVarFormParams.append('destination', destination as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatasetLink: async (organizationId: string, workspaceId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteDatasetLink', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteDatasetLink', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteDatasetLink', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/link`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (datasetId !== undefined) {
                localVarQueryParameter['datasetId'] = datasetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('deleteWorkspaceAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFile: async (organizationId: string, workspaceId: string, fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'fileName', fileName)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files/delete`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFiles: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspaceFiles', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspaceFiles', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceFile: async (organizationId: string, workspaceId: string, fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getWorkspaceFile', 'fileName', fileName)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files/download`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurity: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceSecurity', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceFiles: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listWorkspaceFiles', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listWorkspaceFiles', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceRolePermissions: async (organizationId: string, workspaceId: string, role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listWorkspaceRolePermissions', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listWorkspaceRolePermissions', 'workspaceId', workspaceId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('listWorkspaceRolePermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceSecurityUsers: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listWorkspaceSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listWorkspaceSecurityUsers', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces: async (organizationId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listWorkspaces', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/workspaces`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest The new Workspace details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace: async (organizationId: string, workspaceId: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceUpdateRequest' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceUpdateRequest', workspaceUpdateRequest)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'identityId', identityId)
            // verify required parameter 'workspaceRole' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'workspaceRole', workspaceRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the Workspace default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceDefaultSecurity: async (organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateWorkspaceDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspaceDefaultSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceRole' is not null or undefined
            assertParamExists('updateWorkspaceDefaultSecurity', 'workspaceRole', workspaceRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspaceApi - functional programming interface
 * @export
 */
export const WorkspaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDatasetLink(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDatasetLink(organizationId, workspaceId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.createDatasetLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {WorkspaceCreateRequest} workspaceCreateRequest the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspace(organizationId: string, workspaceCreateRequest: WorkspaceCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspace(organizationId, workspaceCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.createWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.createWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {File} file The file to upload
         * @param {boolean} [overwrite] Whether to overwrite an existing file
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspaceFile(organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.createWorkspaceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDatasetLink(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDatasetLink(organizationId, workspaceId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteDatasetLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspace(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceAccessControl(organizationId, workspaceId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceFile(organizationId, workspaceId, fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteWorkspaceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceFiles(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteWorkspaceFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspace(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceAccessControl(organizationId, workspaceId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceFile(organizationId, workspaceId, fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspaceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceSecurity(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspaceSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaceFiles(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.listWorkspaceFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkspaceRolePermissions(organizationId: string, workspaceId: string, role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaceRolePermissions(organizationId, workspaceId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.listWorkspaceRolePermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaceSecurityUsers(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.listWorkspaceSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkspaces(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workspace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaces(organizationId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.listWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest The new Workspace details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspace(organizationId: string, workspaceId: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspace(organizationId, workspaceId, workspaceUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.updateWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.updateWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the Workspace default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.updateWorkspaceDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspaceApi - factory interface
 * @export
 */
export const WorkspaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspaceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatasetLink(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Workspace> {
            return localVarFp.createDatasetLink(organizationId, workspaceId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {WorkspaceCreateRequest} workspaceCreateRequest the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(organizationId: string, workspaceCreateRequest: WorkspaceCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Workspace> {
            return localVarFp.createWorkspace(organizationId, workspaceCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.createWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {File} file The file to upload
         * @param {boolean} [overwrite] Whether to overwrite an existing file
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceFile(organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceFile> {
            return localVarFp.createWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId dataset id to be linked to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatasetLink(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDatasetLink(organizationId, workspaceId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkspace(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Workspace> {
            return localVarFp.getWorkspace(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.getWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSecurity> {
            return localVarFp.getWorkspaceSecurity(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceFile>> {
            return localVarFp.listWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceRolePermissions(organizationId: string, workspaceId: string, role: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listWorkspaceRolePermissions(organizationId, workspaceId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listWorkspaceSecurityUsers(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Workspace>> {
            return localVarFp.listWorkspaces(organizationId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest The new Workspace details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(organizationId: string, workspaceId: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Workspace> {
            return localVarFp.updateWorkspace(organizationId, workspaceId, workspaceUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} identityId the User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the Workspace default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSecurity> {
            return localVarFp.updateWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspaceApi - object-oriented interface
 * @export
 * @class WorkspaceApi
 * @extends {BaseAPI}
 */
export class WorkspaceApi extends BaseAPI {
    /**
     * 
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId dataset id to be linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createDatasetLink(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createDatasetLink(organizationId, workspaceId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new workspace
     * @param {string} organizationId the Organization identifier
     * @param {WorkspaceCreateRequest} workspaceCreateRequest the Workspace to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createWorkspace(organizationId: string, workspaceCreateRequest: WorkspaceCreateRequest, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createWorkspace(organizationId, workspaceCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a control access to the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {WorkspaceAccessControl} workspaceAccessControl the new Workspace security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a file for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {File} file The file to upload
     * @param {boolean} [overwrite] Whether to overwrite an existing file
     * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createWorkspaceFile(organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId dataset id to be linked to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteDatasetLink(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteDatasetLink(organizationId, workspaceId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspace(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace file
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} fileName the file name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all Workspace files
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspace(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download the Workspace File specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} fileName the file name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace security information
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceSecurity(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Workspace files
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public listWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).listWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace permission by given role
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} role the Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public listWorkspaceRolePermissions(organizationId: string, workspaceId: string, role: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).listWorkspaceRolePermissions(organizationId, workspaceId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public listWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).listWorkspaceSecurityUsers(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Workspaces
     * @param {string} organizationId the Organization identifier
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public listWorkspaces(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).listWorkspaces(organizationId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {WorkspaceUpdateRequest} workspaceUpdateRequest The new Workspace details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspace(organizationId: string, workspaceId: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspace(organizationId, workspaceId, workspaceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} identityId the User identifier
     * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the Workspace default security
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options).then((request) => request(this.axios, this.basePath));
    }
}



