/* tslint:disable */
/* eslint-disable */
/**
 * Cosmo Tech Plaform API
 * Cosmo Tech Platform API
 *
 * The version of the OpenAPI document: 1.1.3-SNAPSHOT
 * Contact: platform@cosmotech.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * a version of a Connector
 * @export
 * @interface Connector
 */
export interface Connector {
    /**
     * the Connector version unique identifier
     * @type {string}
     * @memberof Connector
     */
    'id'?: string;
    /**
     * the Connector key which group Connector versions
     * @type {string}
     * @memberof Connector
     */
    'key': string;
    /**
     * the Connector name
     * @type {string}
     * @memberof Connector
     */
    'name': string;
    /**
     * the Connector description
     * @type {string}
     * @memberof Connector
     */
    'description'?: string;
    /**
     * the registry repository containing the image
     * @type {string}
     * @memberof Connector
     */
    'repository': string;
    /**
     * the Connector version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof Connector
     */
    'version': string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Connector
     */
    'tags'?: Array<string>;
    /**
     * the user id which own this connector version
     * @type {string}
     * @memberof Connector
     */
    'ownerId'?: string;
    /**
     * an optional URL link to connector page
     * @type {string}
     * @memberof Connector
     */
    'url'?: string;
    /**
     * whether or not the connector uses Azure Managed Identity
     * @type {boolean}
     * @memberof Connector
     */
    'azureManagedIdentity'?: boolean;
    /**
     * whether to authenticate against Azure using the app registration credentials provided by the customer
     * @type {boolean}
     * @memberof Connector
     */
    'azureAuthenticationWithCustomerAppRegistration'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Connector
     */
    'ioTypes': Array<ConnectorIoTypesEnum>;
    /**
     * the list of connector parameters groups
     * @type {Array<ConnectorParameterGroup>}
     * @memberof Connector
     */
    'parameterGroups'?: Array<ConnectorParameterGroup>;
}

export const ConnectorIoTypesEnum = {
    Read: 'read',
    Write: 'write'
} as const;

export type ConnectorIoTypesEnum = typeof ConnectorIoTypesEnum[keyof typeof ConnectorIoTypesEnum];

/**
 * a connector parameter
 * @export
 * @interface ConnectorParameter
 */
export interface ConnectorParameter {
    /**
     * the connector parameter id
     * @type {string}
     * @memberof ConnectorParameter
     */
    'id': string;
    /**
     * the list of translated parameter group labels
     * @type {string}
     * @memberof ConnectorParameter
     */
    'label': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof ConnectorParameter
     */
    'valueType'?: string;
    /**
     * the list of available and valid values for the parameter
     * @type {Array<string>}
     * @memberof ConnectorParameter
     */
    'options'?: Array<string>;
    /**
     * the default value
     * @type {string}
     * @memberof ConnectorParameter
     */
    'default'?: string;
    /**
     * associated environment variable in connector image
     * @type {string}
     * @memberof ConnectorParameter
     */
    'envVar'?: string;
}
/**
 * a connector parameters group
 * @export
 * @interface ConnectorParameterGroup
 */
export interface ConnectorParameterGroup {
    /**
     * the connector parameter group id
     * @type {string}
     * @memberof ConnectorParameterGroup
     */
    'id': string;
    /**
     * the list of translated parameter group labels
     * @type {string}
     * @memberof ConnectorParameterGroup
     */
    'label': string;
    /**
     * the list of parameters
     * @type {Array<ConnectorParameter>}
     * @memberof ConnectorParameterGroup
     */
    'parameters': Array<ConnectorParameter>;
}
/**
 * a Dataset
 * @export
 * @interface Dataset
 */
export interface Dataset {
    /**
     * the Dataset unique identifier
     * @type {string}
     * @memberof Dataset
     */
    'id'?: string;
    /**
     * the Dataset name
     * @type {string}
     * @memberof Dataset
     */
    'name'?: string;
    /**
     * the Dataset description
     * @type {string}
     * @memberof Dataset
     */
    'description'?: string;
    /**
     * the User id which own this Dataset
     * @type {string}
     * @memberof Dataset
     */
    'ownerId'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Dataset
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {DatasetConnector}
     * @memberof Dataset
     */
    'connector'?: DatasetConnector;
    /**
     * the list of other Datasets ids to compose as fragments
     * @type {Array<string>}
     * @memberof Dataset
     */
    'fragmentsIds'?: Array<string>;
    /**
     * the validator id
     * @type {string}
     * @memberof Dataset
     */
    'validatorId'?: string;
    /**
     * the list of compatible Solutions versions
     * @type {Array<DatasetCompatibility>}
     * @memberof Dataset
     */
    'compatibility'?: Array<DatasetCompatibility>;
}
/**
 * a Dataset compatibility constraint to a Solution version open range
 * @export
 * @interface DatasetCompatibility
 */
export interface DatasetCompatibility {
    /**
     * the Solution key which group Solution versions
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'solutionKey': string;
    /**
     * the Solution minimum version compatibility (version included)
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'minimumVersion'?: string;
    /**
     * the Solution maximum version compatibility (version included)
     * @type {string}
     * @memberof DatasetCompatibility
     */
    'maximumVersion'?: string;
}
/**
 * a Connector setup
 * @export
 * @interface DatasetConnector
 */
export interface DatasetConnector {
    /**
     * the Connector id
     * @type {string}
     * @memberof DatasetConnector
     */
    'id'?: string;
    /**
     * the Connector name
     * @type {string}
     * @memberof DatasetConnector
     */
    'name'?: string;
    /**
     * the Connector version
     * @type {string}
     * @memberof DatasetConnector
     */
    'version'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DatasetConnector
     */
    'parametersValues'?: { [key: string]: string; };
}
/**
 * the Dataset Copy Parameters
 * @export
 * @interface DatasetCopyParameters
 */
export interface DatasetCopyParameters {
    /**
     * the source Dataset id
     * @type {string}
     * @memberof DatasetCopyParameters
     */
    'sourceId'?: string;
    /**
     * the target Dataset id
     * @type {string}
     * @memberof DatasetCopyParameters
     */
    'targetId'?: string;
    /**
     * freeform options to path to connectors
     * @type {{ [key: string]: object; }}
     * @memberof DatasetCopyParameters
     */
    'options'?: { [key: string]: object; };
}
/**
 * the search options
 * @export
 * @interface DatasetSearch
 */
export interface DatasetSearch {
    /**
     * the dataset tag list to search
     * @type {Array<string>}
     * @memberof DatasetSearch
     */
    'datasetTags': Array<string>;
}
/**
 * Configuration of scenario runs deletion automatic mecanism
 * @export
 * @interface DeleteHistoricalData
 */
export interface DeleteHistoricalData {
    /**
     * Activate or Deactivate historical data deletion
     * @type {boolean}
     * @memberof DeleteHistoricalData
     */
    'enable': boolean;
    /**
     * define the polling frequency of scenario run status (in millis)
     * @type {number}
     * @memberof DeleteHistoricalData
     */
    'pollFrequency'?: number;
    /**
     * define the polling timeout
     * @type {number}
     * @memberof DeleteHistoricalData
     */
    'timeOut'?: number;
}
/**
 * an Organization
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * the Organization unique identifier
     * @type {string}
     * @memberof Organization
     */
    'id'?: string;
    /**
     * the Organization name
     * @type {string}
     * @memberof Organization
     */
    'name'?: string;
    /**
     * the Owner User Id
     * @type {string}
     * @memberof Organization
     */
    'ownerId'?: string;
    /**
     * 
     * @type {Array<OrganizationUser>}
     * @memberof Organization
     */
    'users'?: Array<OrganizationUser>;
    /**
     * 
     * @type {OrganizationServices}
     * @memberof Organization
     */
    'services'?: OrganizationServices;
}
/**
 * a cloud service resource
 * @export
 * @interface OrganizationService
 */
export interface OrganizationService {
    /**
     * the cloud service name
     * @type {string}
     * @memberof OrganizationService
     */
    'cloudService'?: string;
    /**
     * the platform base uri for this service
     * @type {string}
     * @memberof OrganizationService
     */
    'baseUri'?: string;
    /**
     * the Platform service associated to the resource
     * @type {string}
     * @memberof OrganizationService
     */
    'platformService'?: string;
    /**
     * the Organization specific uri for this service resource
     * @type {string}
     * @memberof OrganizationService
     */
    'resourceUri'?: string;
    /**
     * a freeform credentials object. Structure depends on service
     * @type {{ [key: string]: object; }}
     * @memberof OrganizationService
     */
    'credentials'?: { [key: string]: object; };
}
/**
 * the cloud service resources of the Organization
 * @export
 * @interface OrganizationServices
 */
export interface OrganizationServices {
    /**
     * a freeform credentials object for the Organization tenant. Structure depends on cloud provider
     * @type {{ [key: string]: object; }}
     * @memberof OrganizationServices
     */
    'tenantCredentials'?: { [key: string]: object; };
    /**
     * 
     * @type {OrganizationService}
     * @memberof OrganizationServices
     */
    'storage'?: OrganizationService;
    /**
     * 
     * @type {OrganizationService}
     * @memberof OrganizationServices
     */
    'solutionsContainerRegistry'?: OrganizationService;
}
/**
 * a User
 * @export
 * @interface OrganizationUser
 */
export interface OrganizationUser {
    /**
     * the User unique identifier, in response
     * @type {string}
     * @memberof OrganizationUser
     */
    'id'?: string;
    /**
     * the User name
     * @type {string}
     * @memberof OrganizationUser
     */
    'name'?: string;
    /**
     * the User\'s roles for the Organization
     * @type {Array<string>}
     * @memberof OrganizationUser
     */
    'roles': Array<OrganizationUserRolesEnum>;
}

export const OrganizationUserRolesEnum = {
    Admin: 'Admin',
    User: 'User',
    Viewer: 'Viewer',
    Developer: 'Developer'
} as const;

export type OrganizationUserRolesEnum = typeof OrganizationUserRolesEnum[keyof typeof OrganizationUserRolesEnum];

/**
 * a Solution Run Template
 * @export
 * @interface RunTemplate
 */
export interface RunTemplate {
    /**
     * the Solution Run Template id
     * @type {string}
     * @memberof RunTemplate
     */
    'id': string;
    /**
     * the Run Template name
     * @type {string}
     * @memberof RunTemplate
     */
    'name'?: string;
    /**
     * the Run Template description
     * @type {string}
     * @memberof RunTemplate
     */
    'description'?: string;
    /**
     * the Cosmo Tech simulation name. This information is send to the Engine. Mandatory information if no Engine is defined
     * @type {string}
     * @memberof RunTemplate
     */
    'csmSimulation'?: string;
    /**
     * the list of Run Template tags
     * @type {Array<string>}
     * @memberof RunTemplate
     */
    'tags'?: Array<string>;
    /**
     * the compute size needed for this Run Template. Standard sizes are basic and highcpu. Default is basic
     * @type {string}
     * @memberof RunTemplate
     */
    'computeSize'?: string;
    /**
     * set to true if the run template does not want to check data ingestion state (no probes or not control plane)
     * @type {boolean}
     * @memberof RunTemplate
     */
    'noDataIngestionState'?: boolean;
    /**
     * whether or not the fetch dataset step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'fetchDatasets'?: boolean;
    /**
     * whether or not the scenario data download transform step step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'scenarioDataDownloadTransform'?: boolean;
    /**
     * whether or not the fetch parameters step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'fetchScenarioParameters'?: boolean;
    /**
     * whether or not the apply parameter step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'applyParameters'?: boolean;
    /**
     * whether or not the validate step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'validateData'?: boolean;
    /**
     * whether or not the Datasets values are send to the DataWarehouse prior to Simulation Run. If not set follow the Workspace setting
     * @type {boolean}
     * @memberof RunTemplate
     */
    'sendDatasetsToDataWarehouse'?: boolean;
    /**
     * whether or not the input parameters values are send to the DataWarehouse prior to Simulation Run. If not set follow the Workspace setting
     * @type {boolean}
     * @memberof RunTemplate
     */
    'sendInputParametersToDataWarehouse'?: boolean;
    /**
     * whether or not the pre-run step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'preRun'?: boolean;
    /**
     * whether or not the run step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'run'?: boolean;
    /**
     * whether or not the post-run step is done
     * @type {boolean}
     * @memberof RunTemplate
     */
    'postRun'?: boolean;
    /**
     * whether or not to store the scenario parameters in json instead of csv
     * @type {boolean}
     * @memberof RunTemplate
     */
    'parametersJson'?: boolean;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'parametersHandlerSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'datasetValidatorSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'preRunSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'runSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'postRunSource'?: RunTemplateStepSource;
    /**
     * 
     * @type {RunTemplateStepSource}
     * @memberof RunTemplate
     */
    'scenariodataTransformSource'?: RunTemplateStepSource;
    /**
     * the ordered list of parameters groups for the Run Template
     * @type {Array<string>}
     * @memberof RunTemplate
     */
    'parameterGroups'?: Array<string>;
    /**
     * whether or not to stack adjacent scenario run steps in one container run which will chain steps
     * @type {boolean}
     * @memberof RunTemplate
     */
    'stackSteps'?: boolean;
    /**
     * an optional URL to the git repository
     * @type {string}
     * @memberof RunTemplate
     */
    'gitRepositoryUrl'?: string;
    /**
     * an optional git branch name
     * @type {string}
     * @memberof RunTemplate
     */
    'gitBranchName'?: string;
    /**
     * an optional directory where to find the run template source
     * @type {string}
     * @memberof RunTemplate
     */
    'runTemplateSourceDir'?: string;
    /**
     * an optional duration in seconds in which a workflow is allowed to run
     * @type {number}
     * @memberof RunTemplate
     */
    'executionTimeout'?: number;
    /**
     * 
     * @type {DeleteHistoricalData}
     * @memberof RunTemplate
     */
    'deleteHistoricalData'?: DeleteHistoricalData;
}
/**
 * the Run Template step handler identifier
 * @export
 * @enum {string}
 */

export const RunTemplateHandlerId = {
    ParametersHandler: 'parameters_handler',
    Validator: 'validator',
    Prerun: 'prerun',
    Engine: 'engine',
    Postrun: 'postrun',
    ScenariodataTransform: 'scenariodata_transform'
} as const;

export type RunTemplateHandlerId = typeof RunTemplateHandlerId[keyof typeof RunTemplateHandlerId];


/**
 * a Run Template Parameter
 * @export
 * @interface RunTemplateParameter
 */
export interface RunTemplateParameter {
    /**
     * the Parameter id
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'id': string;
    /**
     * a translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameter
     */
    'labels'?: { [key: string]: string; };
    /**
     * the variable type for the parameter. Basic types or special type %DATASETID%
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'varType'?: string;
    /**
     * the default value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'defaultValue'?: string;
    /**
     * the minimum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'minValue'?: string;
    /**
     * the maximum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'maxValue'?: string;
    /**
     * a regex to validate the value
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'regexValidation'?: string;
    /**
     * freeform options
     * @type {{ [key: string]: object; }}
     * @memberof RunTemplateParameter
     */
    'options'?: { [key: string]: object; };
}
/**
 * a Parameter Group for a Run Template
 * @export
 * @interface RunTemplateParameterGroup
 */
export interface RunTemplateParameterGroup {
    /**
     * the Parameter Group id
     * @type {string}
     * @memberof RunTemplateParameterGroup
     */
    'id': string;
    /**
     * a translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameterGroup
     */
    'labels'?: { [key: string]: string; };
    /**
     * does the group define a table
     * @type {boolean}
     * @memberof RunTemplateParameterGroup
     */
    'isTable'?: boolean;
    /**
     * freeform options
     * @type {{ [key: string]: object; }}
     * @memberof RunTemplateParameterGroup
     */
    'options'?: { [key: string]: object; };
    /**
     * the Run Template Group parent Id
     * @type {string}
     * @memberof RunTemplateParameterGroup
     */
    'parentId'?: string;
    /**
     * an ordered list of Run Template Parameters
     * @type {Array<string>}
     * @memberof RunTemplateParameterGroup
     */
    'parameters'?: Array<string>;
}
/**
 * the value of Analysis parameter for a Scenario for this ScenarioRun
 * @export
 * @interface RunTemplateParameterValue
 */
export interface RunTemplateParameterValue {
    /**
     * the parameter Id
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'parameterId': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'value': string;
}
/**
 * the source local, cloud or git repository
 * @export
 * @enum {string}
 */

export const RunTemplateStepSource = {
    Cloud: 'cloud',
    Git: 'git',
    Local: 'local',
    Platform: 'platform'
} as const;

export type RunTemplateStepSource = typeof RunTemplateStepSource[keyof typeof RunTemplateStepSource];


/**
 * a Scenario with base information
 * @export
 * @interface Scenario
 */
export interface Scenario {
    /**
     * the Scenario unique identifier
     * @type {string}
     * @memberof Scenario
     */
    'id'?: string;
    /**
     * the Scenario name
     * @type {string}
     * @memberof Scenario
     */
    'name'?: string;
    /**
     * the Scenario description
     * @type {string}
     * @memberof Scenario
     */
    'description'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Scenario
     */
    'tags'?: Array<string>;
    /**
     * the Scenario parent id
     * @type {string}
     * @memberof Scenario
     */
    'parentId'?: string;
    /**
     * the user id which own this Scenario
     * @type {string}
     * @memberof Scenario
     */
    'ownerId'?: string;
    /**
     * the scenario root id
     * @type {string}
     * @memberof Scenario
     */
    'rootId'?: string;
    /**
     * the Solution Id associated with this Scenario
     * @type {string}
     * @memberof Scenario
     */
    'solutionId'?: string;
    /**
     * the Solution Run Template Id associated with this Scenario
     * @type {string}
     * @memberof Scenario
     */
    'runTemplateId'?: string;
    /**
     * the associated Workspace Id
     * @type {string}
     * @memberof Scenario
     */
    'workspaceId'?: string;
    /**
     * the list of users Id with their role
     * @type {Array<ScenarioUser>}
     * @memberof Scenario
     */
    'users'?: Array<ScenarioUser>;
    /**
     * 
     * @type {ScenarioJobState}
     * @memberof Scenario
     */
    'state'?: ScenarioJobState;
    /**
     * the Scenario creation date
     * @type {string}
     * @memberof Scenario
     */
    'creationDate'?: string;
    /**
     * the last time a Scenario was updated
     * @type {string}
     * @memberof Scenario
     */
    'lastUpdate'?: string;
    /**
     * the name of the owner
     * @type {string}
     * @memberof Scenario
     */
    'ownerName'?: string;
    /**
     * the Solution name
     * @type {string}
     * @memberof Scenario
     */
    'solutionName'?: string;
    /**
     * the Solution Run Template name associated with this Scenario
     * @type {string}
     * @memberof Scenario
     */
    'runTemplateName'?: string;
    /**
     * the list of Dataset Id associated to this Scenario Run Template
     * @type {Array<string>}
     * @memberof Scenario
     */
    'datasetList'?: Array<string>;
    /**
     * the list of Solution Run Template parameters values
     * @type {Array<ScenarioRunTemplateParameterValue>}
     * @memberof Scenario
     */
    'parametersValues'?: Array<ScenarioRunTemplateParameterValue>;
    /**
     * 
     * @type {ScenarioLastRun & object}
     * @memberof Scenario
     */
    'lastRun'?: ScenarioLastRun & object;
    /**
     * 
     * @type {ScenarioLastRun & object}
     * @memberof Scenario
     */
    'parentLastRun'?: ScenarioLastRun & object;
    /**
     * 
     * @type {ScenarioLastRun & object}
     * @memberof Scenario
     */
    'rootLastRun'?: ScenarioLastRun & object;
    /**
     * 
     * @type {ScenarioValidationStatus}
     * @memberof Scenario
     */
    'validationStatus'?: ScenarioValidationStatus;
}
/**
 * the difference between the values of a parameter
 * @export
 * @interface ScenarioChangedParameterValue
 */
export interface ScenarioChangedParameterValue {
    /**
     * the parameter id the values refer to
     * @type {string}
     * @memberof ScenarioChangedParameterValue
     */
    'parameterId'?: string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof ScenarioChangedParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value for the reference Scenario
     * @type {string}
     * @memberof ScenarioChangedParameterValue
     */
    'value'?: string;
    /**
     * the parameter value for the compared Scenario
     * @type {string}
     * @memberof ScenarioChangedParameterValue
     */
    'comparedValue'?: string;
}
/**
 * the result of the comparison of two scenarios
 * @export
 * @interface ScenarioComparisonResult
 */
export interface ScenarioComparisonResult {
    /**
     * the Scenario Id which is the reference for the comparison
     * @type {string}
     * @memberof ScenarioComparisonResult
     */
    'scenarioId'?: string;
    /**
     * the Scenario Id the reference Scenario is compared to
     * @type {string}
     * @memberof ScenarioComparisonResult
     */
    'comparedScenarioId'?: string;
    /**
     * the list of changed values for parameters
     * @type {Array<ScenarioChangedParameterValue>}
     * @memberof ScenarioComparisonResult
     */
    'changedValues'?: Array<ScenarioChangedParameterValue>;
}
/**
 * Scenario data download job info
 * @export
 * @interface ScenarioDataDownloadInfo
 */
export interface ScenarioDataDownloadInfo {
    /**
     * the Scenario Data Download URL
     * @type {string}
     * @memberof ScenarioDataDownloadInfo
     */
    'url'?: string;
    /**
     * 
     * @type {ScenarioJobState}
     * @memberof ScenarioDataDownloadInfo
     */
    'state'?: ScenarioJobState;
}
/**
 * Scenario data download job
 * @export
 * @interface ScenarioDataDownloadJob
 */
export interface ScenarioDataDownloadJob {
    /**
     * the Scenario Data Download job identifier
     * @type {string}
     * @memberof ScenarioDataDownloadJob
     */
    'id'?: string;
}
/**
 * the Scenario job state
 * @export
 * @enum {string}
 */

export const ScenarioJobState = {
    Created: 'Created',
    Running: 'Running',
    Successful: 'Successful',
    Failed: 'Failed',
    Unknown: 'Unknown',
    DataIngestionInProgress: 'DataIngestionInProgress'
} as const;

export type ScenarioJobState = typeof ScenarioJobState[keyof typeof ScenarioJobState];


/**
 * 
 * @export
 * @interface ScenarioLastRun
 */
export interface ScenarioLastRun {
    /**
     * the last Scenario Run id
     * @type {string}
     * @memberof ScenarioLastRun
     */
    'scenarioRunId'?: string;
    /**
     * the last Cosmo Tech Simulation Run id
     * @type {string}
     * @memberof ScenarioLastRun
     */
    'csmSimulationRun'?: string;
    /**
     * the last Workflow Id
     * @type {string}
     * @memberof ScenarioLastRun
     */
    'workflowId'?: string;
    /**
     * the last Workflow name
     * @type {string}
     * @memberof ScenarioLastRun
     */
    'workflowName'?: string;
}
/**
 * a ScenarioRun with only base properties
 * @export
 * @interface ScenarioRun
 */
export interface ScenarioRun {
    /**
     * the ScenarioRun
     * @type {string}
     * @memberof ScenarioRun
     */
    'id'?: string;
    /**
     * 
     * @type {ScenarioRunState}
     * @memberof ScenarioRun
     */
    'state'?: ScenarioRunState;
    /**
     * the Organization id
     * @type {string}
     * @memberof ScenarioRun
     */
    'organizationId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof ScenarioRun
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech Simulation Run Id
     * @type {string}
     * @memberof ScenarioRun
     */
    'csmSimulationRun'?: string;
    /**
     * the base name for workflow name generation
     * @type {string}
     * @memberof ScenarioRun
     */
    'generateName'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof ScenarioRun
     */
    'workflowName'?: string;
    /**
     * the user id which own this scenariorun
     * @type {string}
     * @memberof ScenarioRun
     */
    'ownerId'?: string;
    /**
     * the Workspace Id
     * @type {string}
     * @memberof ScenarioRun
     */
    'workspaceId'?: string;
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof ScenarioRun
     */
    'workspaceKey'?: string;
    /**
     * the Scenario Id
     * @type {string}
     * @memberof ScenarioRun
     */
    'scenarioId'?: string;
    /**
     * the Solution Id
     * @type {string}
     * @memberof ScenarioRun
     */
    'solutionId'?: string;
    /**
     * the Solution Run Template id
     * @type {string}
     * @memberof ScenarioRun
     */
    'runTemplateId'?: string;
    /**
     * the compute size needed for this Analysis. Standard sizes are basic and highcpu. Default is basic
     * @type {string}
     * @memberof ScenarioRun
     */
    'computeSize'?: string;
    /**
     * the MAJOR.MINOR version used to build the solution solution
     * @type {string}
     * @memberof ScenarioRun
     */
    'sdkVersion'?: string;
    /**
     * set to true if the run template does not use any Datawarehouse consumers (AMQP consumers for Azure)
     * @type {boolean}
     * @memberof ScenarioRun
     */
    'noDataIngestionState'?: boolean;
    /**
     * the list of Dataset Id associated to this Analysis
     * @type {Array<string>}
     * @memberof ScenarioRun
     */
    'datasetList'?: Array<string>;
    /**
     * the list of Run Template parameters values
     * @type {Array<RunTemplateParameterValue>}
     * @memberof ScenarioRun
     */
    'parametersValues'?: Array<RunTemplateParameterValue>;
    /**
     * whether or not the Datasets values are send to the DataWarehouse prior to Simulation Run. If not set follow the Workspace setting
     * @type {boolean}
     * @memberof ScenarioRun
     */
    'sendDatasetsToDataWarehouse'?: boolean;
    /**
     * whether or not the input parameters values are send to the DataWarehouse prior to Simulation Run. If not set follow the Workspace setting
     * @type {boolean}
     * @memberof ScenarioRun
     */
    'sendInputParametersToDataWarehouse'?: boolean;
    /**
     * the node label request
     * @type {string}
     * @memberof ScenarioRun
     */
    'nodeLabel'?: string;
    /**
     * the containers list. This information is not returned by the API.
     * @type {Array<ScenarioRunContainer>}
     * @memberof ScenarioRun
     */
    'containers'?: Array<ScenarioRunContainer>;
}
/**
 * a ScenarioRun container description
 * @export
 * @interface ScenarioRunContainer
 */
export interface ScenarioRunContainer {
    /**
     * the container Id
     * @type {string}
     * @memberof ScenarioRunContainer
     */
    'id'?: string;
    /**
     * the container name
     * @type {string}
     * @memberof ScenarioRunContainer
     */
    'name': string;
    /**
     * the metadata labels
     * @type {{ [key: string]: string; }}
     * @memberof ScenarioRunContainer
     */
    'labels'?: { [key: string]: string; };
    /**
     * environment variable map
     * @type {{ [key: string]: string; }}
     * @memberof ScenarioRunContainer
     */
    'envVars'?: { [key: string]: string; };
    /**
     * the container image URI
     * @type {string}
     * @memberof ScenarioRunContainer
     */
    'image': string;
    /**
     * the container entry point
     * @type {string}
     * @memberof ScenarioRunContainer
     */
    'entrypoint'?: string;
    /**
     * the list of run arguments for the container
     * @type {Array<string>}
     * @memberof ScenarioRunContainer
     */
    'runArgs'?: Array<string>;
    /**
     * the list of dependencies container name to run this container
     * @type {Array<string>}
     * @memberof ScenarioRunContainer
     */
    'dependencies'?: Array<string>;
    /**
     * whether or not this container is a Cosmo Tech solution container
     * @type {boolean}
     * @memberof ScenarioRunContainer
     */
    'solutionContainer'?: boolean;
    /**
     * the list of artifacts
     * @type {Array<ScenarioRunContainerArtifact>}
     * @memberof ScenarioRunContainer
     */
    'artifacts'?: Array<ScenarioRunContainerArtifact>;
}
/**
 * a scenario run container artifact
 * @export
 * @interface ScenarioRunContainerArtifact
 */
export interface ScenarioRunContainerArtifact {
    /**
     * the artifact name
     * @type {string}
     * @memberof ScenarioRunContainerArtifact
     */
    'name'?: string;
    /**
     * the artifact path (relative to /var/csmoutput)
     * @type {string}
     * @memberof ScenarioRunContainerArtifact
     */
    'path'?: string;
}
/**
 * logs for a given container
 * @export
 * @interface ScenarioRunContainerLogs
 */
export interface ScenarioRunContainerLogs {
    /**
     * the node Id which has executed this log
     * @type {string}
     * @memberof ScenarioRunContainerLogs
     */
    'nodeId'?: string;
    /**
     * the container name
     * @type {string}
     * @memberof ScenarioRunContainerLogs
     */
    'containerName'?: string;
    /**
     * the list of children node id
     * @type {Array<string>}
     * @memberof ScenarioRunContainerLogs
     */
    'children'?: Array<string>;
    /**
     * the node logs in plain text
     * @type {string}
     * @memberof ScenarioRunContainerLogs
     */
    'logs'?: string;
}
/**
 * the scenariorun logs returned by all containers
 * @export
 * @interface ScenarioRunLogs
 */
export interface ScenarioRunLogs {
    /**
     * the ScenarioRun Id
     * @type {string}
     * @memberof ScenarioRunLogs
     */
    'scenariorunId'?: string;
    /**
     * the container map of logs
     * @type {{ [key: string]: ScenarioRunContainerLogs; }}
     * @memberof ScenarioRunLogs
     */
    'containers'?: { [key: string]: ScenarioRunContainerLogs; };
}
/**
 * the search options
 * @export
 * @interface ScenarioRunSearch
 */
export interface ScenarioRunSearch {
    /**
     * the Solution Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'solutionId'?: string;
    /**
     * the Solution Analysis Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'runTemplateId'?: string;
    /**
     * the Workspace Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'workspaceId'?: string;
    /**
     * the Scenario Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'scenarioId'?: string;
    /**
     * the state to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'state'?: ScenarioRunSearchStateEnum;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'workflowName'?: string;
    /**
     * the owner Id to search
     * @type {string}
     * @memberof ScenarioRunSearch
     */
    'ownerId'?: string;
}

export const ScenarioRunSearchStateEnum = {
    FetchingDatasets: 'FetchingDatasets',
    FetchingScenarioParameters: 'FetchingScenarioParameters',
    ApplyingScenarioParameters: 'ApplyingScenarioParameters',
    ValidatingScenarioData: 'ValidatingScenarioData',
    SendingScenarioDataToDataWarehouse: 'SendingScenarioDataToDataWarehouse',
    PreRun: 'PreRun',
    Running: 'Running',
    PostRun: 'PostRun',
    Success: 'Success',
    Failed: 'Failed'
} as const;

export type ScenarioRunSearchStateEnum = typeof ScenarioRunSearchStateEnum[keyof typeof ScenarioRunSearchStateEnum];

/**
 * the parameters to run directly containers
 * @export
 * @interface ScenarioRunStartContainers
 */
export interface ScenarioRunStartContainers {
    /**
     * the base name for workflow name generation
     * @type {string}
     * @memberof ScenarioRunStartContainers
     */
    'generateName'?: string;
    /**
     * Cosmo Tech Simulation Run Id
     * @type {string}
     * @memberof ScenarioRunStartContainers
     */
    'csmSimulationId': string;
    /**
     * the node label request
     * @type {string}
     * @memberof ScenarioRunStartContainers
     */
    'nodeLabel'?: string;
    /**
     * the workflow labels
     * @type {{ [key: string]: string; }}
     * @memberof ScenarioRunStartContainers
     */
    'labels'?: { [key: string]: string; };
    /**
     * the containerslist
     * @type {Array<ScenarioRunContainer>}
     * @memberof ScenarioRunStartContainers
     */
    'containers': Array<ScenarioRunContainer>;
}
/**
 * the ScenarioRun end-to-end state
 * @export
 * @enum {string}
 */

export const ScenarioRunState = {
    Running: 'Running',
    Successful: 'Successful',
    Failed: 'Failed',
    Unknown: 'Unknown',
    DataIngestionInProgress: 'DataIngestionInProgress',
    DataIngestionFailure: 'DataIngestionFailure'
} as const;

export type ScenarioRunState = typeof ScenarioRunState[keyof typeof ScenarioRunState];


/**
 * a ScenarioRun status
 * @export
 * @interface ScenarioRunStatus
 */
export interface ScenarioRunStatus {
    /**
     * the ScenarioRun id
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'id'?: string;
    /**
     * the ScenarioRun id
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'organizationId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'workflowName'?: string;
    /**
     * the ScenarioRun start Date Time
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'startTime'?: string;
    /**
     * the ScenarioRun end Date Time
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'endTime'?: string;
    /**
     * high-level summary of where the workflow is in its lifecycle
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'phase'?: string;
    /**
     * progress to completion
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'progress'?: string;
    /**
     * a  human readable message indicating details about why the workflow is in this condition
     * @type {string}
     * @memberof ScenarioRunStatus
     */
    'message'?: string;
    /**
     * estimatedDuration in seconds
     * @type {number}
     * @memberof ScenarioRunStatus
     */
    'estimatedDuration'?: number;
    /**
     * status of ScenarioRun nodes
     * @type {Array<ScenarioRunStatusNode>}
     * @memberof ScenarioRunStatus
     */
    'nodes'?: Array<ScenarioRunStatusNode>;
    /**
     * 
     * @type {ScenarioRunState}
     * @memberof ScenarioRunStatus
     */
    'state'?: ScenarioRunState;
}
/**
 * status of a ScenarioRun Node
 * @export
 * @interface ScenarioRunStatusNode
 */
export interface ScenarioRunStatusNode {
    /**
     * the node id
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'id'?: string;
    /**
     * the node unique name
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'name'?: string;
    /**
     * the ScenarioRun container name
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'containerName'?: string;
    /**
     * estimatedDuration in seconds
     * @type {number}
     * @memberof ScenarioRunStatusNode
     */
    'estimatedDuration'?: number;
    /**
     * HostNodeName name of the Kubernetes node on which the Pod is running, if applicable
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'hostNodeName'?: string;
    /**
     * a human readable message indicating details about why the node is in this condition
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'message'?: string;
    /**
     * high-level summary of where the node is in its lifecycle
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'phase'?: string;
    /**
     * progress to completion
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'progress'?: string;
    /**
     * the node start time
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'startTime'?: string;
    /**
     * the node end time
     * @type {string}
     * @memberof ScenarioRunStatusNode
     */
    'endTime'?: string;
}
/**
 * the value of a Solution Run Template parameter for a Scenario
 * @export
 * @interface ScenarioRunTemplateParameterValue
 */
export interface ScenarioRunTemplateParameterValue {
    /**
     * the parameter Id
     * @type {string}
     * @memberof ScenarioRunTemplateParameterValue
     */
    'parameterId': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof ScenarioRunTemplateParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value
     * @type {string}
     * @memberof ScenarioRunTemplateParameterValue
     */
    'value': string;
    /**
     * whether or not the value is inherited from parent or has been changed
     * @type {boolean}
     * @memberof ScenarioRunTemplateParameterValue
     */
    'isInherited'?: boolean;
}
/**
 * a Scenario user with roles
 * @export
 * @interface ScenarioUser
 */
export interface ScenarioUser {
    /**
     * the User id
     * @type {string}
     * @memberof ScenarioUser
     */
    'id': string;
    /**
     * the User name
     * @type {string}
     * @memberof ScenarioUser
     */
    'name'?: string;
    /**
     * the User role
     * @type {Array<string>}
     * @memberof ScenarioUser
     */
    'roles': Array<ScenarioUserRolesEnum>;
}

export const ScenarioUserRolesEnum = {
    Viewer: 'Viewer',
    Editor: 'Editor'
} as const;

export type ScenarioUserRolesEnum = typeof ScenarioUserRolesEnum[keyof typeof ScenarioUserRolesEnum];

/**
 * the validation status of the scenario
 * @export
 * @enum {string}
 */

export const ScenarioValidationStatus = {
    Draft: 'Draft',
    Rejected: 'Rejected',
    Unknown: 'Unknown',
    Validated: 'Validated'
} as const;

export type ScenarioValidationStatus = typeof ScenarioValidationStatus[keyof typeof ScenarioValidationStatus];


/**
 * a version of a Solution
 * @export
 * @interface Solution
 */
export interface Solution {
    /**
     * the Solution version unique identifier
     * @type {string}
     * @memberof Solution
     */
    'id'?: string;
    /**
     * the Solution key which group Solution versions
     * @type {string}
     * @memberof Solution
     */
    'key'?: string;
    /**
     * the Solution name
     * @type {string}
     * @memberof Solution
     */
    'name'?: string;
    /**
     * the Solution description
     * @type {string}
     * @memberof Solution
     */
    'description'?: string;
    /**
     * the registry repository containing the image
     * @type {string}
     * @memberof Solution
     */
    'repository'?: string;
    /**
     * the main Cosmo Tech simulator name used in standard Run Template
     * @type {string}
     * @memberof Solution
     */
    'csmSimulator'?: string;
    /**
     * the Solution version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof Solution
     */
    'version'?: string;
    /**
     * the User id which own this Solution
     * @type {string}
     * @memberof Solution
     */
    'ownerId'?: string;
    /**
     * the MAJOR.MINOR version used to build this solution
     * @type {string}
     * @memberof Solution
     */
    'sdkVersion'?: string;
    /**
     * an optional URL link to solution page
     * @type {string}
     * @memberof Solution
     */
    'url'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Solution
     */
    'tags'?: Array<string>;
    /**
     * the list of Run Template Parameters
     * @type {Array<RunTemplateParameter>}
     * @memberof Solution
     */
    'parameters'?: Array<RunTemplateParameter>;
    /**
     * the list of parameters groups for the Run Templates
     * @type {Array<RunTemplateParameterGroup>}
     * @memberof Solution
     */
    'parameterGroups'?: Array<RunTemplateParameterGroup>;
    /**
     * list of Run Template
     * @type {Array<RunTemplate>}
     * @memberof Solution
     */
    'runTemplates'?: Array<RunTemplate>;
}
/**
 * a User
 * @export
 * @interface User
 */
export interface User {
    /**
     * the User unique identifier
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * the User name
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * the list of Platform roles
     * @type {Array<string>}
     * @memberof User
     */
    'platformRoles'?: Array<UserPlatformRolesEnum>;
    /**
     * 
     * @type {Array<UserOrganization>}
     * @memberof User
     */
    'organizations'?: Array<UserOrganization>;
}

export const UserPlatformRolesEnum = {
    Admin: 'Admin',
    User: 'User',
    ConnectorDeveloper: 'ConnectorDeveloper'
} as const;

export type UserPlatformRolesEnum = typeof UserPlatformRolesEnum[keyof typeof UserPlatformRolesEnum];

/**
 * The organization of the user
 * @export
 * @interface UserOrganization
 */
export interface UserOrganization {
    /**
     * the Organization id
     * @type {string}
     * @memberof UserOrganization
     */
    'id'?: string;
    /**
     * the Organization name
     * @type {string}
     * @memberof UserOrganization
     */
    'name'?: string;
    /**
     * the roles of the User in the Organization
     * @type {Array<string>}
     * @memberof UserOrganization
     */
    'roles'?: Array<string>;
    /**
     * the list of Workspaces roles
     * @type {Array<UserWorkspace>}
     * @memberof UserOrganization
     */
    'workspaces'?: Array<UserWorkspace>;
}
/**
 * the list of User roles for a Workspace
 * @export
 * @interface UserWorkspace
 */
export interface UserWorkspace {
    /**
     * the Workspace Id
     * @type {string}
     * @memberof UserWorkspace
     */
    'id'?: string;
    /**
     * the Workspace name
     * @type {string}
     * @memberof UserWorkspace
     */
    'name'?: string;
    /**
     * the roles of the User in the Workspace
     * @type {Array<string>}
     * @memberof UserWorkspace
     */
    'roles'?: Array<string>;
}
/**
 * a Validator to validate a Dataset
 * @export
 * @interface Validator
 */
export interface Validator {
    /**
     * the Validator id
     * @type {string}
     * @memberof Validator
     */
    'id': string;
    /**
     * the Validator name
     * @type {string}
     * @memberof Validator
     */
    'name': string;
    /**
     * the Validator description
     * @type {string}
     * @memberof Validator
     */
    'description'?: string;
    /**
     * the registry repository containing the Validator image
     * @type {string}
     * @memberof Validator
     */
    'repository': string;
    /**
     * the Validator version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof Validator
     */
    'version': string;
    /**
     * the User id which own this Validator
     * @type {string}
     * @memberof Validator
     */
    'ownerId'?: string;
    /**
     * an optional URL link to Validator page
     * @type {string}
     * @memberof Validator
     */
    'url'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Validator
     */
    'tags'?: Array<string>;
}
/**
 * a Validator Run
 * @export
 * @interface ValidatorRun
 */
export interface ValidatorRun {
    /**
     * the Validator Run id
     * @type {string}
     * @memberof ValidatorRun
     */
    'id'?: string;
    /**
     * the Validator id
     * @type {string}
     * @memberof ValidatorRun
     */
    'validatorId'?: string;
    /**
     * the validator name
     * @type {string}
     * @memberof ValidatorRun
     */
    'validatorName'?: string;
    /**
     * the Dataset id to run the validator on
     * @type {string}
     * @memberof ValidatorRun
     */
    'datasetId': string;
    /**
     * the Dataset name
     * @type {string}
     * @memberof ValidatorRun
     */
    'datasetName'?: string;
    /**
     * the Validator Run state
     * @type {string}
     * @memberof ValidatorRun
     */
    'state'?: ValidatorRunStateEnum;
    /**
     * the Validator Run container id
     * @type {string}
     * @memberof ValidatorRun
     */
    'containerId'?: string;
    /**
     * the Validator Run logs
     * @type {string}
     * @memberof ValidatorRun
     */
    'logs'?: string;
}

export const ValidatorRunStateEnum = {
    Running: 'Running',
    Finished: 'Finished',
    OnError: 'OnError'
} as const;

export type ValidatorRunStateEnum = typeof ValidatorRunStateEnum[keyof typeof ValidatorRunStateEnum];

/**
 * a Workspace
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * the Workspace version unique identifier
     * @type {string}
     * @memberof Workspace
     */
    'id'?: string;
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof Workspace
     */
    'key': string;
    /**
     * the Workspace name
     * @type {string}
     * @memberof Workspace
     */
    'name': string;
    /**
     * the Workspace description
     * @type {string}
     * @memberof Workspace
     */
    'description'?: string;
    /**
     * the Workspace version MAJOR.MINOR.PATCH.
     * @type {string}
     * @memberof Workspace
     */
    'version'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Workspace
     */
    'tags'?: Array<string>;
    /**
     * the user id which own this workspace
     * @type {string}
     * @memberof Workspace
     */
    'ownerId'?: string;
    /**
     * 
     * @type {WorkspaceSolution}
     * @memberof Workspace
     */
    'solution': WorkspaceSolution;
    /**
     * the list of users Id with their role
     * @type {Array<WorkspaceUser>}
     * @memberof Workspace
     */
    'users'?: Array<WorkspaceUser>;
    /**
     * 
     * @type {WorkspaceWebApp}
     * @memberof Workspace
     */
    'webApp'?: WorkspaceWebApp;
    /**
     * default setting for all Scenarios and Run Templates to set whether or not the Dataset values and the input parameters values are send to the DataWarehouse prior to the ScenarioRun
     * @type {boolean}
     * @memberof Workspace
     */
    'sendInputToDataWarehouse'?: boolean;
    /**
     * Set this property to true to use a dedicated Azure Event Hub Namespace for this Workspace. The Event Hub Namespace must be named \\\'<organization_id\\>-<workspace_id\\>\\\' (in lower case). This Namespace must also contain two Event Hubs named \\\'probesmeasures\\\' and \\\'scenariorun\\\'.
     * @type {boolean}
     * @memberof Workspace
     */
    'useDedicatedEventHubNamespace'?: boolean;
    /**
     * the Dedicated Event Hub SAS key name, default to RootManageSharedAccessKey. Use the /secret endpoint to set the key value
     * @type {string}
     * @memberof Workspace
     */
    'dedicatedEventHubSasKeyName'?: string;
    /**
     * the Event Hub authentication strategy, SHARED_ACCESS_POLICY or TENANT_CLIENT_CREDENTIALS. Default to the one defined for the tenant.
     * @type {string}
     * @memberof Workspace
     */
    'dedicatedEventHubAuthenticationStrategy'?: string;
    /**
     * default setting for all Scenarios and Run Templates to set whether or not the ScenarioRun is send to the Event Hub
     * @type {boolean}
     * @memberof Workspace
     */
    'sendScenarioRunToEventHub'?: boolean;
    /**
     * Set this property to false to not send scenario metada to Azure Event Hub Namespace for this Workspace. The Event Hub Namespace must be named \\\'<organization_id\\>-<workspace_id\\>\\\' (in lower case). This Namespace must also contain two Event Hubs named \\\'scenariometadata\\\' and \\\'scenariorunmetadata\\\'.
     * @type {boolean}
     * @memberof Workspace
     */
    'sendScenarioMetadataToEventHub'?: boolean;
}
/**
 * a Workspace File resource
 * @export
 * @interface WorkspaceFile
 */
export interface WorkspaceFile {
    /**
     * the Workspace File name
     * @type {string}
     * @memberof WorkspaceFile
     */
    'fileName'?: string;
}
/**
 * the secret definition
 * @export
 * @interface WorkspaceSecret
 */
export interface WorkspaceSecret {
    /**
     * the dedicated event hub shared access key
     * @type {string}
     * @memberof WorkspaceSecret
     */
    'dedicatedEventHubKey'?: string;
}
/**
 * the Workspace Solution configuration
 * @export
 * @interface WorkspaceSolution
 */
export interface WorkspaceSolution {
    /**
     * the Solution Id attached to this workspace
     * @type {string}
     * @memberof WorkspaceSolution
     */
    'solutionId'?: string;
    /**
     * the list of Solution Run Template Id to filter
     * @type {Array<string>}
     * @memberof WorkspaceSolution
     */
    'runTemplateFilter'?: Array<string>;
    /**
     * a map of RunTemplateId/DatasetId to set a default dataset for a Run Template
     * @type {{ [key: string]: object; }}
     * @memberof WorkspaceSolution
     */
    'defaultRunTemplateDataset'?: { [key: string]: object; };
}
/**
 * a Workspace user with roles
 * @export
 * @interface WorkspaceUser
 */
export interface WorkspaceUser {
    /**
     * the User id
     * @type {string}
     * @memberof WorkspaceUser
     */
    'id': string;
    /**
     * the User name
     * @type {string}
     * @memberof WorkspaceUser
     */
    'name'?: string;
    /**
     * the User roles
     * @type {Array<string>}
     * @memberof WorkspaceUser
     */
    'roles': Array<WorkspaceUserRolesEnum>;
}

export const WorkspaceUserRolesEnum = {
    Admin: 'Admin',
    User: 'User',
    Viewer: 'Viewer'
} as const;

export type WorkspaceUserRolesEnum = typeof WorkspaceUserRolesEnum[keyof typeof WorkspaceUserRolesEnum];

/**
 * a Workspace Web Application
 * @export
 * @interface WorkspaceWebApp
 */
export interface WorkspaceWebApp {
    /**
     * the Workspace Web Application URL
     * @type {string}
     * @memberof WorkspaceWebApp
     */
    'url': string;
    /**
     * a map of iframeKey/iframeURL
     * @type {{ [key: string]: object; }}
     * @memberof WorkspaceWebApp
     */
    'iframes'?: { [key: string]: object; };
    /**
     * free form options for Web Application
     * @type {{ [key: string]: object; }}
     * @memberof WorkspaceWebApp
     */
    'options'?: { [key: string]: object; };
}

/**
 * ConnectorApi - axios parameter creator
 * @export
 */
export const ConnectorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllConnectors: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findConnectorById: async (connectorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('findConnectorById', 'connectorId', connectorId)
            const localVarPath = `/connectors/{connector_id}`
                .replace(`{${"connector_id"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerConnector: async (connector: Connector, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connector' is not null or undefined
            assertParamExists('registerConnector', 'connector', connector)
            const localVarPath = `/connectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connector, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterConnector: async (connectorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorId' is not null or undefined
            assertParamExists('unregisterConnector', 'connectorId', connectorId)
            const localVarPath = `/connectors/{connector_id}`
                .replace(`{${"connector_id"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectorApi - functional programming interface
 * @export
 */
export const ConnectorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllConnectors(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Connector>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllConnectors(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findConnectorById(connectorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findConnectorById(connectorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerConnector(connector: Connector, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connector>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerConnector(connector, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unregisterConnector(connectorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unregisterConnector(connectorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ConnectorApi - factory interface
 * @export
 */
export const ConnectorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectorApiFp(configuration)
    return {
        /**
         * 
         * @summary List all Connectors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllConnectors(options?: any): AxiosPromise<Array<Connector>> {
            return localVarFp.findAllConnectors(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findConnectorById(connectorId: string, options?: any): AxiosPromise<Connector> {
            return localVarFp.findConnectorById(connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new connector
         * @param {Connector} connector the Connector to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerConnector(connector: Connector, options?: any): AxiosPromise<Connector> {
            return localVarFp.registerConnector(connector, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unregister a connector
         * @param {string} connectorId the Connector identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterConnector(connectorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unregisterConnector(connectorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConnectorApi - object-oriented interface
 * @export
 * @class ConnectorApi
 * @extends {BaseAPI}
 */
export class ConnectorApi extends BaseAPI {
    /**
     * 
     * @summary List all Connectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public findAllConnectors(options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).findAllConnectors(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a connector
     * @param {string} connectorId the Connector identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public findConnectorById(connectorId: string, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).findConnectorById(connectorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new connector
     * @param {Connector} connector the Connector to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public registerConnector(connector: Connector, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).registerConnector(connector, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unregister a connector
     * @param {string} connectorId the Connector identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorApi
     */
    public unregisterConnector(connectorId: string, options?: AxiosRequestConfig) {
        return ConnectorApiFp(this.configuration).unregisterConnector(connectorId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatasetApi - axios parameter creator
 * @export
 */
export const DatasetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceDatasetCompatibilityElements: async (organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'datasetId', datasetId)
            // verify required parameter 'datasetCompatibility' is not null or undefined
            assertParamExists('addOrReplaceDatasetCompatibilityElements', 'datasetCompatibility', datasetCompatibility)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/compatibility`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetCompatibility, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copy a Dataset to another Dataset. Source must have a read capable connector and Target a write capable connector.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyDataset: async (organizationId: string, datasetCopyParameters: DatasetCopyParameters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('copyDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetCopyParameters' is not null or undefined
            assertParamExists('copyDataset', 'datasetCopyParameters', datasetCopyParameters)
            const localVarPath = `/organizations/{organization_id}/datasets/copy`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetCopyParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset: async (organizationId: string, dataset: Dataset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createDataset', 'organizationId', organizationId)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('createDataset', 'dataset', dataset)
            const localVarPath = `/organizations/{organization_id}/datasets`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset: async (organizationId: string, datasetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteDataset', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDatasets: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllDatasets', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/datasets`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDatasetById: async (organizationId: string, datasetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findDatasetById', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('findDatasetById', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllDatasetCompatibilityElements: async (organizationId: string, datasetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllDatasetCompatibilityElements', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('removeAllDatasetCompatibilityElements', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}/compatibility`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Datasets
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDatasets: async (organizationId: string, datasetSearch: DatasetSearch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('searchDatasets', 'organizationId', organizationId)
            // verify required parameter 'datasetSearch' is not null or undefined
            assertParamExists('searchDatasets', 'datasetSearch', datasetSearch)
            const localVarPath = `/organizations/{organization_id}/datasets/search`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset: async (organizationId: string, datasetId: string, dataset: Dataset, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateDataset', 'organizationId', organizationId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateDataset', 'datasetId', datasetId)
            // verify required parameter 'dataset' is not null or undefined
            assertParamExists('updateDataset', 'dataset', dataset)
            const localVarPath = `/organizations/{organization_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetApi - functional programming interface
 * @export
 */
export const DatasetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DatasetCompatibility>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Copy a Dataset to another Dataset. Source must have a read capable connector and Target a write capable connector.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetCopyParameters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyDataset(organizationId, datasetCopyParameters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataset(organizationId: string, dataset: Dataset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataset(organizationId, dataset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataset(organizationId: string, datasetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataset(organizationId, datasetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllDatasets(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllDatasets(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDatasetById(organizationId: string, datasetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDatasetById(organizationId, datasetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllDatasetCompatibilityElements(organizationId, datasetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search Datasets
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDatasets(organizationId: string, datasetSearch: DatasetSearch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDatasets(organizationId, datasetSearch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataset(organizationId, datasetId, dataset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatasetApi - factory interface
 * @export
 */
export const DatasetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Dataset Compatibility elements.
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: any): AxiosPromise<Array<DatasetCompatibility>> {
            return localVarFp.addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Copy a Dataset to another Dataset. Source must have a read capable connector and Target a write capable connector.
         * @param {string} organizationId the Organization identifier
         * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: any): AxiosPromise<DatasetCopyParameters> {
            return localVarFp.copyDataset(organizationId, datasetCopyParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Dataset
         * @param {string} organizationId the Organization identifier
         * @param {Dataset} dataset the Dataset to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset(organizationId: string, dataset: Dataset, options?: any): AxiosPromise<Dataset> {
            return localVarFp.createDataset(organizationId, dataset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset(organizationId: string, datasetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDataset(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Datasets
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDatasets(organizationId: string, options?: any): AxiosPromise<Array<Dataset>> {
            return localVarFp.findAllDatasets(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDatasetById(organizationId: string, datasetId: string, options?: any): AxiosPromise<Dataset> {
            return localVarFp.findDatasetById(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Dataset Compatibility elements from the Dataset specified
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllDatasetCompatibilityElements(organizationId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Datasets
         * @param {string} organizationId the Organization identifier
         * @param {DatasetSearch} datasetSearch the Dataset search parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDatasets(organizationId: string, datasetSearch: DatasetSearch, options?: any): AxiosPromise<Array<Dataset>> {
            return localVarFp.searchDatasets(organizationId, datasetSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Dataset} dataset the new Dataset details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: any): AxiosPromise<Dataset> {
            return localVarFp.updateDataset(organizationId, datasetId, dataset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetApi - object-oriented interface
 * @export
 * @class DatasetApi
 * @extends {BaseAPI}
 */
export class DatasetApi extends BaseAPI {
    /**
     * 
     * @summary Add Dataset Compatibility elements.
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {Array<DatasetCompatibility>} datasetCompatibility the Dataset Compatibility elements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public addOrReplaceDatasetCompatibilityElements(organizationId: string, datasetId: string, datasetCompatibility: Array<DatasetCompatibility>, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).addOrReplaceDatasetCompatibilityElements(organizationId, datasetId, datasetCompatibility, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Copy a Dataset to another Dataset. Source must have a read capable connector and Target a write capable connector.
     * @param {string} organizationId the Organization identifier
     * @param {DatasetCopyParameters} datasetCopyParameters the Dataset copy parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public copyDataset(organizationId: string, datasetCopyParameters: DatasetCopyParameters, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).copyDataset(organizationId, datasetCopyParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Dataset
     * @param {string} organizationId the Organization identifier
     * @param {Dataset} dataset the Dataset to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createDataset(organizationId: string, dataset: Dataset, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createDataset(organizationId, dataset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteDataset(organizationId: string, datasetId: string, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteDataset(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Datasets
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public findAllDatasets(organizationId: string, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).findAllDatasets(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public findDatasetById(organizationId: string, datasetId: string, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).findDatasetById(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Dataset Compatibility elements from the Dataset specified
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public removeAllDatasetCompatibilityElements(organizationId: string, datasetId: string, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).removeAllDatasetCompatibilityElements(organizationId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Datasets
     * @param {string} organizationId the Organization identifier
     * @param {DatasetSearch} datasetSearch the Dataset search parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public searchDatasets(organizationId: string, datasetSearch: DatasetSearch, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).searchDatasets(organizationId, datasetSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} datasetId the Dataset identifier
     * @param {Dataset} dataset the new Dataset details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateDataset(organizationId: string, datasetId: string, dataset: Dataset, options?: AxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateDataset(organizationId, datasetId, dataset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add (or replace) users in the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {Array<OrganizationUser>} organizationUser the Users to add. Any User with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceUsersInOrganization: async (organizationId: string, organizationUser: Array<OrganizationUser>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceUsersInOrganization', 'organizationId', organizationId)
            // verify required parameter 'organizationUser' is not null or undefined
            assertParamExists('addOrReplaceUsersInOrganization', 'organizationUser', organizationUser)
            const localVarPath = `/organizations/{organization_id}/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrganizations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganizationById: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findOrganizationById', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new organization
         * @param {Organization} organization the Organization to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOrganization: async (organization: Organization, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('registerOrganization', 'organization', organization)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all users from the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllUsersInOrganization: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllUsersInOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified user from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromOrganization: async (organizationId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeUserFromOrganization', 'organizationId', organizationId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFromOrganization', 'userId', userId)
            const localVarPath = `/organizations/{organization_id}/users/{user_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unregister an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterOrganization: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('unregisterOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {Organization} organization the new Organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (organizationId: string, organization: Organization, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganization', 'organizationId', organizationId)
            // verify required parameter 'organization' is not null or undefined
            assertParamExists('updateOrganization', 'organization', organization)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organization, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the solutions container registry configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new solutions container registry configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionsContainerRegistryByOrganizationId: async (organizationId: string, organizationService: OrganizationService, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionsContainerRegistryByOrganizationId', 'organizationId', organizationId)
            // verify required parameter 'organizationService' is not null or undefined
            assertParamExists('updateSolutionsContainerRegistryByOrganizationId', 'organizationService', organizationService)
            const localVarPath = `/organizations/{organization_id}/services/solutionsContainerRegistry`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationService, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update storage configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new Storage configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorageByOrganizationId: async (organizationId: string, organizationService: OrganizationService, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateStorageByOrganizationId', 'organizationId', organizationId)
            // verify required parameter 'organizationService' is not null or undefined
            assertParamExists('updateStorageByOrganizationId', 'organizationService', organizationService)
            const localVarPath = `/organizations/{organization_id}/services/storage`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationService, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update tenant credentials for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {{ [key: string]: object; }} requestBody the new Tenant Credentials to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenantCredentialsByOrganizationId: async (organizationId: string, requestBody: { [key: string]: object; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateTenantCredentialsByOrganizationId', 'organizationId', organizationId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateTenantCredentialsByOrganizationId', 'requestBody', requestBody)
            const localVarPath = `/organizations/{organization_id}/services/tenantCredentials`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add (or replace) users in the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {Array<OrganizationUser>} organizationUser the Users to add. Any User with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceUsersInOrganization(organizationId: string, organizationUser: Array<OrganizationUser>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrganizationUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceUsersInOrganization(organizationId, organizationUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllOrganizations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllOrganizations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOrganizationById(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOrganizationById(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new organization
         * @param {Organization} organization the Organization to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerOrganization(organization: Organization, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerOrganization(organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all users from the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllUsersInOrganization(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllUsersInOrganization(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the specified user from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromOrganization(organizationId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFromOrganization(organizationId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unregister an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unregisterOrganization(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unregisterOrganization(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {Organization} organization the new Organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(organizationId: string, organization: Organization, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(organizationId, organization, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the solutions container registry configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new solutions container registry configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionsContainerRegistryByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionsContainerRegistryByOrganizationId(organizationId, organizationService, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update storage configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new Storage configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStorageByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStorageByOrganizationId(organizationId, organizationService, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update tenant credentials for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {{ [key: string]: object; }} requestBody the new Tenant Credentials to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTenantCredentialsByOrganizationId(organizationId: string, requestBody: { [key: string]: object; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTenantCredentialsByOrganizationId(organizationId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * 
         * @summary Add (or replace) users in the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {Array<OrganizationUser>} organizationUser the Users to add. Any User with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceUsersInOrganization(organizationId: string, organizationUser: Array<OrganizationUser>, options?: any): AxiosPromise<Array<OrganizationUser>> {
            return localVarFp.addOrReplaceUsersInOrganization(organizationId, organizationUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrganizations(options?: any): AxiosPromise<Array<Organization>> {
            return localVarFp.findAllOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrganizationById(organizationId: string, options?: any): AxiosPromise<Organization> {
            return localVarFp.findOrganizationById(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new organization
         * @param {Organization} organization the Organization to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerOrganization(organization: Organization, options?: any): AxiosPromise<Organization> {
            return localVarFp.registerOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all users from the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllUsersInOrganization(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllUsersInOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified user from the given Organization
         * @param {string} organizationId the Organization identifier
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromOrganization(organizationId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeUserFromOrganization(organizationId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unregister an organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterOrganization(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unregisterOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId the Organization identifier
         * @param {Organization} organization the new Organization details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organizationId: string, organization: Organization, options?: any): AxiosPromise<Organization> {
            return localVarFp.updateOrganization(organizationId, organization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the solutions container registry configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new solutions container registry configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionsContainerRegistryByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: any): AxiosPromise<OrganizationService> {
            return localVarFp.updateSolutionsContainerRegistryByOrganizationId(organizationId, organizationService, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update storage configuration for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {OrganizationService} organizationService the new Storage configuration to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorageByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: any): AxiosPromise<OrganizationService> {
            return localVarFp.updateStorageByOrganizationId(organizationId, organizationService, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update tenant credentials for the Organization specified
         * @param {string} organizationId the Organization identifier
         * @param {{ [key: string]: object; }} requestBody the new Tenant Credentials to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenantCredentialsByOrganizationId(organizationId: string, requestBody: { [key: string]: object; }, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.updateTenantCredentialsByOrganizationId(organizationId, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * 
     * @summary Add (or replace) users in the Organization specified
     * @param {string} organizationId the Organization identifier
     * @param {Array<OrganizationUser>} organizationUser the Users to add. Any User with the same ID is overwritten
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public addOrReplaceUsersInOrganization(organizationId: string, organizationUser: Array<OrganizationUser>, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).addOrReplaceUsersInOrganization(organizationId, organizationUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public findAllOrganizations(options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).findAllOrganizations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an Organization
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public findOrganizationById(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).findOrganizationById(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new organization
     * @param {Organization} organization the Organization to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public registerOrganization(organization: Organization, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).registerOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all users from the Organization specified
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public removeAllUsersInOrganization(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).removeAllUsersInOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified user from the given Organization
     * @param {string} organizationId the Organization identifier
     * @param {string} userId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public removeUserFromOrganization(organizationId: string, userId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).removeUserFromOrganization(organizationId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unregister an organization
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public unregisterOrganization(organizationId: string, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).unregisterOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an Organization
     * @param {string} organizationId the Organization identifier
     * @param {Organization} organization the new Organization details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganization(organizationId: string, organization: Organization, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganization(organizationId, organization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the solutions container registry configuration for the Organization specified
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationService} organizationService the new solutions container registry configuration to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateSolutionsContainerRegistryByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateSolutionsContainerRegistryByOrganizationId(organizationId, organizationService, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update storage configuration for the Organization specified
     * @param {string} organizationId the Organization identifier
     * @param {OrganizationService} organizationService the new Storage configuration to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateStorageByOrganizationId(organizationId: string, organizationService: OrganizationService, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateStorageByOrganizationId(organizationId, organizationService, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update tenant credentials for the Organization specified
     * @param {string} organizationId the Organization identifier
     * @param {{ [key: string]: object; }} requestBody the new Tenant Credentials to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateTenantCredentialsByOrganizationId(organizationId: string, requestBody: { [key: string]: object; }, options?: AxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateTenantCredentialsByOrganizationId(organizationId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScenarioApi - axios parameter creator
 * @export
 */
export const ScenarioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add (or replace) Parameter Values for the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Array<ScenarioRunTemplateParameterValue>} scenarioRunTemplateParameterValue the Parameter Value to add. Any Parameter Value with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceScenarioParameterValues: async (organizationId: string, workspaceId: string, scenarioId: string, scenarioRunTemplateParameterValue: Array<ScenarioRunTemplateParameterValue>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceScenarioParameterValues', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addOrReplaceScenarioParameterValues', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('addOrReplaceScenarioParameterValues', 'scenarioId', scenarioId)
            // verify required parameter 'scenarioRunTemplateParameterValue' is not null or undefined
            assertParamExists('addOrReplaceScenarioParameterValues', 'scenarioRunTemplateParameterValue', scenarioRunTemplateParameterValue)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/parameterValues`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioRunTemplateParameterValue, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add (or replace) users in the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Array<ScenarioUser>} scenarioUser the Users to add. Any User with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceUsersInScenario: async (organizationId: string, workspaceId: string, scenarioId: string, scenarioUser: Array<ScenarioUser>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceUsersInScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addOrReplaceUsersInScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('addOrReplaceUsersInScenario', 'scenarioId', scenarioId)
            // verify required parameter 'scenarioUser' is not null or undefined
            assertParamExists('addOrReplaceUsersInScenario', 'scenarioUser', scenarioUser)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Compare the Scenario with another one and returns the difference for parameters values
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} comparedScenarioId the Scenario identifier to compare to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareScenarios: async (organizationId: string, workspaceId: string, scenarioId: string, comparedScenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('compareScenarios', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('compareScenarios', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('compareScenarios', 'scenarioId', scenarioId)
            // verify required parameter 'comparedScenarioId' is not null or undefined
            assertParamExists('compareScenarios', 'comparedScenarioId', comparedScenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/compare/{compared_scenario_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"compared_scenario_id"}}`, encodeURIComponent(String(comparedScenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Scenario} scenario the Scenario to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenario: async (organizationId: string, workspaceId: string, scenario: Scenario, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenario' is not null or undefined
            assertParamExists('createScenario', 'scenario', scenario)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenario, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all Scenarios of the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllScenarios: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteAllScenarios', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteAllScenarios', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [waitRelationshipPropagation] whether to wait until child scenarios are effectively updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenario: async (organizationId: string, workspaceId: string, scenarioId: string, waitRelationshipPropagation?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deleteScenario', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (waitRelationshipPropagation !== undefined) {
                localVarQueryParameter['wait_relationship_propagation'] = waitRelationshipPropagation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download Scenario data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadScenarioData: async (organizationId: string, workspaceId: string, scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadScenarioData', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('downloadScenarioData', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('downloadScenarioData', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/downloads`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Scenarios
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllScenarios: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllScenarios', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findAllScenarios', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Scenarios by validation status
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {ScenarioValidationStatus} validationStatus the Scenario Validation Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllScenariosByValidationStatus: async (organizationId: string, workspaceId: string, validationStatus: ScenarioValidationStatus, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllScenariosByValidationStatus', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findAllScenariosByValidationStatus', 'workspaceId', workspaceId)
            // verify required parameter 'validationStatus' is not null or undefined
            assertParamExists('findAllScenariosByValidationStatus', 'validationStatus', validationStatus)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/{validationStatus}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"validationStatus"}}`, encodeURIComponent(String(validationStatus)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findScenarioById: async (organizationId: string, workspaceId: string, scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findScenarioById', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findScenarioById', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('findScenarioById', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Scenario data download URL
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} downloadId the Scenario Download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioDataDownloadJobInfo: async (organizationId: string, workspaceId: string, scenarioId: string, downloadId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioDataDownloadJobInfo', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioDataDownloadJobInfo', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioDataDownloadJobInfo', 'scenarioId', scenarioId)
            // verify required parameter 'downloadId' is not null or undefined
            assertParamExists('getScenarioDataDownloadJobInfo', 'downloadId', downloadId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/downloads/{download_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"download_id"}}`, encodeURIComponent(String(downloadId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the validation status of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioValidationStatusById: async (organizationId: string, workspaceId: string, scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioValidationStatusById', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioValidationStatusById', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioValidationStatusById', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/ValidationStatus`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Scenarios Tree
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenariosTree: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenariosTree', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenariosTree', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/tree`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Parameter Values from the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllScenarioParameterValues: async (organizationId: string, workspaceId: string, scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllScenarioParameterValues', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeAllScenarioParameterValues', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('removeAllScenarioParameterValues', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/parameterValues`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all users from the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllUsersOfScenario: async (organizationId: string, workspaceId: string, scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllUsersOfScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeAllUsersOfScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('removeAllUsersOfScenario', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified user from the given Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromScenario: async (organizationId: string, workspaceId: string, scenarioId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeUserFromScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeUserFromScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('removeUserFromScenario', 'scenarioId', scenarioId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFromScenario', 'userId', userId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/users/{user_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Scenario} scenario the new Scenario details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenario: async (organizationId: string, workspaceId: string, scenarioId: string, scenario: Scenario, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('updateScenario', 'scenarioId', scenarioId)
            // verify required parameter 'scenario' is not null or undefined
            assertParamExists('updateScenario', 'scenario', scenario)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenario, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScenarioApi - functional programming interface
 * @export
 */
export const ScenarioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScenarioApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add (or replace) Parameter Values for the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Array<ScenarioRunTemplateParameterValue>} scenarioRunTemplateParameterValue the Parameter Value to add. Any Parameter Value with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, scenarioRunTemplateParameterValue: Array<ScenarioRunTemplateParameterValue>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioRunTemplateParameterValue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceScenarioParameterValues(organizationId, workspaceId, scenarioId, scenarioRunTemplateParameterValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add (or replace) users in the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Array<ScenarioUser>} scenarioUser the Users to add. Any User with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceUsersInScenario(organizationId: string, workspaceId: string, scenarioId: string, scenarioUser: Array<ScenarioUser>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceUsersInScenario(organizationId, workspaceId, scenarioId, scenarioUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Compare the Scenario with another one and returns the difference for parameters values
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} comparedScenarioId the Scenario identifier to compare to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async compareScenarios(organizationId: string, workspaceId: string, scenarioId: string, comparedScenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioComparisonResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.compareScenarios(organizationId, workspaceId, scenarioId, comparedScenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Scenario} scenario the Scenario to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScenario(organizationId: string, workspaceId: string, scenario: Scenario, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScenario(organizationId, workspaceId, scenario, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete all Scenarios of the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllScenarios(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllScenarios(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [waitRelationshipPropagation] whether to wait until child scenarios are effectively updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScenario(organizationId: string, workspaceId: string, scenarioId: string, waitRelationshipPropagation?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScenario(organizationId, workspaceId, scenarioId, waitRelationshipPropagation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download Scenario data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadScenarioData(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioDataDownloadJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadScenarioData(organizationId, workspaceId, scenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Scenarios
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllScenarios(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Scenario>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllScenarios(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Scenarios by validation status
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {ScenarioValidationStatus} validationStatus the Scenario Validation Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllScenariosByValidationStatus(organizationId: string, workspaceId: string, validationStatus: ScenarioValidationStatus, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Scenario>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllScenariosByValidationStatus(organizationId, workspaceId, validationStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findScenarioById(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findScenarioById(organizationId, workspaceId, scenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Scenario data download URL
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} downloadId the Scenario Download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioDataDownloadJobInfo(organizationId: string, workspaceId: string, scenarioId: string, downloadId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioDataDownloadInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioDataDownloadJobInfo(organizationId, workspaceId, scenarioId, downloadId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the validation status of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioValidationStatusById(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioValidationStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioValidationStatusById(organizationId, workspaceId, scenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the Scenarios Tree
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenariosTree(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Scenario>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenariosTree(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all Parameter Values from the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllScenarioParameterValues(organizationId, workspaceId, scenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all users from the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllUsersOfScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllUsersOfScenario(organizationId, workspaceId, scenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the specified user from the given Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromScenario(organizationId: string, workspaceId: string, scenarioId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFromScenario(organizationId, workspaceId, scenarioId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Scenario} scenario the new Scenario details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScenario(organizationId: string, workspaceId: string, scenarioId: string, scenario: Scenario, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScenario(organizationId, workspaceId, scenarioId, scenario, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScenarioApi - factory interface
 * @export
 */
export const ScenarioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScenarioApiFp(configuration)
    return {
        /**
         * 
         * @summary Add (or replace) Parameter Values for the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Array<ScenarioRunTemplateParameterValue>} scenarioRunTemplateParameterValue the Parameter Value to add. Any Parameter Value with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, scenarioRunTemplateParameterValue: Array<ScenarioRunTemplateParameterValue>, options?: any): AxiosPromise<Array<ScenarioRunTemplateParameterValue>> {
            return localVarFp.addOrReplaceScenarioParameterValues(organizationId, workspaceId, scenarioId, scenarioRunTemplateParameterValue, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add (or replace) users in the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Array<ScenarioUser>} scenarioUser the Users to add. Any User with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceUsersInScenario(organizationId: string, workspaceId: string, scenarioId: string, scenarioUser: Array<ScenarioUser>, options?: any): AxiosPromise<Array<ScenarioUser>> {
            return localVarFp.addOrReplaceUsersInScenario(organizationId, workspaceId, scenarioId, scenarioUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Compare the Scenario with another one and returns the difference for parameters values
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} comparedScenarioId the Scenario identifier to compare to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        compareScenarios(organizationId: string, workspaceId: string, scenarioId: string, comparedScenarioId: string, options?: any): AxiosPromise<ScenarioComparisonResult> {
            return localVarFp.compareScenarios(organizationId, workspaceId, scenarioId, comparedScenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Scenario} scenario the Scenario to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScenario(organizationId: string, workspaceId: string, scenario: Scenario, options?: any): AxiosPromise<Scenario> {
            return localVarFp.createScenario(organizationId, workspaceId, scenario, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all Scenarios of the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllScenarios(organizationId: string, workspaceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllScenarios(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [waitRelationshipPropagation] whether to wait until child scenarios are effectively updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenario(organizationId: string, workspaceId: string, scenarioId: string, waitRelationshipPropagation?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteScenario(organizationId, workspaceId, scenarioId, waitRelationshipPropagation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download Scenario data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadScenarioData(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<ScenarioDataDownloadJob> {
            return localVarFp.downloadScenarioData(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Scenarios
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllScenarios(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Array<Scenario>> {
            return localVarFp.findAllScenarios(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Scenarios by validation status
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {ScenarioValidationStatus} validationStatus the Scenario Validation Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllScenariosByValidationStatus(organizationId: string, workspaceId: string, validationStatus: ScenarioValidationStatus, options?: any): AxiosPromise<Array<Scenario>> {
            return localVarFp.findAllScenariosByValidationStatus(organizationId, workspaceId, validationStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findScenarioById(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<Scenario> {
            return localVarFp.findScenarioById(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Scenario data download URL
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} downloadId the Scenario Download identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioDataDownloadJobInfo(organizationId: string, workspaceId: string, scenarioId: string, downloadId: string, options?: any): AxiosPromise<ScenarioDataDownloadInfo> {
            return localVarFp.getScenarioDataDownloadJobInfo(organizationId, workspaceId, scenarioId, downloadId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the validation status of an scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioValidationStatusById(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<ScenarioValidationStatus> {
            return localVarFp.getScenarioValidationStatusById(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Scenarios Tree
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenariosTree(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Array<Scenario>> {
            return localVarFp.getScenariosTree(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Parameter Values from the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllScenarioParameterValues(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all users from the Scenario specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllUsersOfScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllUsersOfScenario(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified user from the given Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromScenario(organizationId: string, workspaceId: string, scenarioId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeUserFromScenario(organizationId, workspaceId, scenarioId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {Scenario} scenario the new Scenario details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScenario(organizationId: string, workspaceId: string, scenarioId: string, scenario: Scenario, options?: any): AxiosPromise<Scenario> {
            return localVarFp.updateScenario(organizationId, workspaceId, scenarioId, scenario, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScenarioApi - object-oriented interface
 * @export
 * @class ScenarioApi
 * @extends {BaseAPI}
 */
export class ScenarioApi extends BaseAPI {
    /**
     * 
     * @summary Add (or replace) Parameter Values for the Scenario specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {Array<ScenarioRunTemplateParameterValue>} scenarioRunTemplateParameterValue the Parameter Value to add. Any Parameter Value with the same ID is overwritten
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public addOrReplaceScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, scenarioRunTemplateParameterValue: Array<ScenarioRunTemplateParameterValue>, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).addOrReplaceScenarioParameterValues(organizationId, workspaceId, scenarioId, scenarioRunTemplateParameterValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add (or replace) users in the Scenario specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {Array<ScenarioUser>} scenarioUser the Users to add. Any User with the same ID is overwritten
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public addOrReplaceUsersInScenario(organizationId: string, workspaceId: string, scenarioId: string, scenarioUser: Array<ScenarioUser>, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).addOrReplaceUsersInScenario(organizationId, workspaceId, scenarioId, scenarioUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Compare the Scenario with another one and returns the difference for parameters values
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {string} comparedScenarioId the Scenario identifier to compare to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public compareScenarios(organizationId: string, workspaceId: string, scenarioId: string, comparedScenarioId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).compareScenarios(organizationId, workspaceId, scenarioId, comparedScenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {Scenario} scenario the Scenario to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public createScenario(organizationId: string, workspaceId: string, scenario: Scenario, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).createScenario(organizationId, workspaceId, scenario, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all Scenarios of the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public deleteAllScenarios(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).deleteAllScenarios(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {boolean} [waitRelationshipPropagation] whether to wait until child scenarios are effectively updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public deleteScenario(organizationId: string, workspaceId: string, scenarioId: string, waitRelationshipPropagation?: boolean, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).deleteScenario(organizationId, workspaceId, scenarioId, waitRelationshipPropagation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download Scenario data
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public downloadScenarioData(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).downloadScenarioData(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Scenarios
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public findAllScenarios(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).findAllScenarios(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Scenarios by validation status
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {ScenarioValidationStatus} validationStatus the Scenario Validation Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public findAllScenariosByValidationStatus(organizationId: string, workspaceId: string, validationStatus: ScenarioValidationStatus, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).findAllScenariosByValidationStatus(organizationId, workspaceId, validationStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public findScenarioById(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).findScenarioById(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Scenario data download URL
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {string} downloadId the Scenario Download identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenarioDataDownloadJobInfo(organizationId: string, workspaceId: string, scenarioId: string, downloadId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenarioDataDownloadJobInfo(organizationId, workspaceId, scenarioId, downloadId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the validation status of an scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenarioValidationStatusById(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenarioValidationStatusById(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Scenarios Tree
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public getScenariosTree(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).getScenariosTree(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Parameter Values from the Scenario specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public removeAllScenarioParameterValues(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).removeAllScenarioParameterValues(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all users from the Scenario specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public removeAllUsersOfScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).removeAllUsersOfScenario(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified user from the given Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {string} userId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public removeUserFromScenario(organizationId: string, workspaceId: string, scenarioId: string, userId: string, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).removeUserFromScenario(organizationId, workspaceId, scenarioId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {Scenario} scenario the new Scenario details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenarioApi
     */
    public updateScenario(organizationId: string, workspaceId: string, scenarioId: string, scenario: Scenario, options?: AxiosRequestConfig) {
        return ScenarioApiFp(this.configuration).updateScenario(organizationId, workspaceId, scenarioId, scenario, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScenariorunApi - axios parameter creator
 * @export
 */
export const ScenariorunApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Organization
         * @param {string} organizationId the Organization identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHistoricalDataOrganization: async (organizationId: string, deleteUnknown?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteHistoricalDataOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/historicaldata`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (deleteUnknown !== undefined) {
                localVarQueryParameter['deleteUnknown'] = deleteUnknown;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHistoricalDataScenario: async (organizationId: string, workspaceId: string, scenarioId: string, deleteUnknown?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteHistoricalDataScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteHistoricalDataScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deleteHistoricalDataScenario', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/scenarioruns/historicaldata`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (deleteUnknown !== undefined) {
                localVarQueryParameter['deleteUnknown'] = deleteUnknown;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHistoricalDataWorkspace: async (organizationId: string, workspaceId: string, deleteUnknown?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteHistoricalDataWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteHistoricalDataWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarioruns/historicaldata`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (deleteUnknown !== undefined) {
                localVarQueryParameter['deleteUnknown'] = deleteUnknown;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioRun: async (organizationId: string, scenariorunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteScenarioRun', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('deleteScenarioRun', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findScenarioRunById: async (organizationId: string, scenariorunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findScenarioRunById', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('findScenarioRunById', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the cumulated logs of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRunCumulatedLogs: async (organizationId: string, scenariorunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioRunCumulatedLogs', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('getScenarioRunCumulatedLogs', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}/cumulatedlogs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the logs for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRunLogs: async (organizationId: string, scenariorunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioRunLogs', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('getScenarioRunLogs', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}/logs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the status for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRunStatus: async (organizationId: string, scenariorunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioRunStatus', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('getScenarioRunStatus', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}/status`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRuns: async (organizationId: string, workspaceId: string, scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getScenarioRuns', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getScenarioRuns', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('getScenarioRuns', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/scenarioruns`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceScenarioRuns: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceScenarioRuns', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceScenarioRuns', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarioruns`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary run a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runScenario: async (organizationId: string, workspaceId: string, scenarioId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('runScenario', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('runScenario', 'workspaceId', workspaceId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('runScenario', 'scenarioId', scenarioId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/scenarios/{scenario_id}/run`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"scenario_id"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search ScenarioRuns
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunSearch} scenarioRunSearch the ScenarioRun search parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenarioRuns: async (organizationId: string, scenarioRunSearch: ScenarioRunSearch, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('searchScenarioRuns', 'organizationId', organizationId)
            // verify required parameter 'scenarioRunSearch' is not null or undefined
            assertParamExists('searchScenarioRuns', 'scenarioRunSearch', scenarioRunSearch)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/search`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioRunSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a new scenariorun with raw containers definition
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunStartContainers} scenarioRunStartContainers the raw containers definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startScenarioRunContainers: async (organizationId: string, scenarioRunStartContainers: ScenarioRunStartContainers, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('startScenarioRunContainers', 'organizationId', organizationId)
            // verify required parameter 'scenarioRunStartContainers' is not null or undefined
            assertParamExists('startScenarioRunContainers', 'scenarioRunStartContainers', scenarioRunStartContainers)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/startcontainers`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioRunStartContainers, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary stop a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the scenariorun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopScenarioRun: async (organizationId: string, scenariorunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('stopScenarioRun', 'organizationId', organizationId)
            // verify required parameter 'scenariorunId' is not null or undefined
            assertParamExists('stopScenarioRun', 'scenariorunId', scenariorunId)
            const localVarPath = `/organizations/{organization_id}/scenarioruns/{scenariorun_id}/stop`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"scenariorun_id"}}`, encodeURIComponent(String(scenariorunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScenariorunApi - functional programming interface
 * @export
 */
export const ScenariorunApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScenariorunApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Organization
         * @param {string} organizationId the Organization identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHistoricalDataOrganization(organizationId: string, deleteUnknown?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHistoricalDataOrganization(organizationId, deleteUnknown, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHistoricalDataScenario(organizationId: string, workspaceId: string, scenarioId: string, deleteUnknown?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHistoricalDataScenario(organizationId, workspaceId, scenarioId, deleteUnknown, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHistoricalDataWorkspace(organizationId: string, workspaceId: string, deleteUnknown?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteHistoricalDataWorkspace(organizationId, workspaceId, deleteUnknown, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScenarioRun(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScenarioRun(organizationId, scenariorunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findScenarioRunById(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findScenarioRunById(organizationId, scenariorunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the cumulated logs of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioRunCumulatedLogs(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioRunCumulatedLogs(organizationId, scenariorunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get the logs for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioRunLogs(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRunLogs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioRunLogs(organizationId, scenariorunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get the status for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioRunStatus(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRunStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioRunStatus(organizationId, scenariorunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScenarioRuns(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScenarioRuns(organizationId, workspaceId, scenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceScenarioRuns(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceScenarioRuns(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary run a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runScenario(organizationId, workspaceId, scenarioId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search ScenarioRuns
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunSearch} scenarioRunSearch the ScenarioRun search parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchScenarioRuns(organizationId: string, scenarioRunSearch: ScenarioRunSearch, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ScenarioRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchScenarioRuns(organizationId, scenarioRunSearch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start a new scenariorun with raw containers definition
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunStartContainers} scenarioRunStartContainers the raw containers definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startScenarioRunContainers(organizationId: string, scenarioRunStartContainers: ScenarioRunStartContainers, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startScenarioRunContainers(organizationId, scenarioRunStartContainers, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary stop a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the scenariorun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopScenarioRun(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioRunStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopScenarioRun(organizationId, scenariorunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScenariorunApi - factory interface
 * @export
 */
export const ScenariorunApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScenariorunApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Organization
         * @param {string} organizationId the Organization identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHistoricalDataOrganization(organizationId: string, deleteUnknown?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHistoricalDataOrganization(organizationId, deleteUnknown, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHistoricalDataScenario(organizationId: string, workspaceId: string, scenarioId: string, deleteUnknown?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHistoricalDataScenario(organizationId, workspaceId, scenarioId, deleteUnknown, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all historical ScenarioRuns in the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHistoricalDataWorkspace(organizationId: string, workspaceId: string, deleteUnknown?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteHistoricalDataWorkspace(organizationId, workspaceId, deleteUnknown, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScenarioRun(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteScenarioRun(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findScenarioRunById(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<ScenarioRun> {
            return localVarFp.findScenarioRunById(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the cumulated logs of a scenariorun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRunCumulatedLogs(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<string> {
            return localVarFp.getScenarioRunCumulatedLogs(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the logs for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRunLogs(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<ScenarioRunLogs> {
            return localVarFp.getScenarioRunLogs(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the status for the ScenarioRun
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the ScenarioRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRunStatus(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<ScenarioRunStatus> {
            return localVarFp.getScenarioRunStatus(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScenarioRuns(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<Array<ScenarioRun>> {
            return localVarFp.getScenarioRuns(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the list of ScenarioRuns for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceScenarioRuns(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Array<ScenarioRun>> {
            return localVarFp.getWorkspaceScenarioRuns(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary run a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} scenarioId the Scenario identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: any): AxiosPromise<ScenarioRun> {
            return localVarFp.runScenario(organizationId, workspaceId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search ScenarioRuns
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunSearch} scenarioRunSearch the ScenarioRun search parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchScenarioRuns(organizationId: string, scenarioRunSearch: ScenarioRunSearch, options?: any): AxiosPromise<Array<ScenarioRun>> {
            return localVarFp.searchScenarioRuns(organizationId, scenarioRunSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a new scenariorun with raw containers definition
         * @param {string} organizationId the Organization identifier
         * @param {ScenarioRunStartContainers} scenarioRunStartContainers the raw containers definition
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startScenarioRunContainers(organizationId: string, scenarioRunStartContainers: ScenarioRunStartContainers, options?: any): AxiosPromise<ScenarioRun> {
            return localVarFp.startScenarioRunContainers(organizationId, scenarioRunStartContainers, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary stop a ScenarioRun for the Scenario
         * @param {string} organizationId the Organization identifier
         * @param {string} scenariorunId the scenariorun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopScenarioRun(organizationId: string, scenariorunId: string, options?: any): AxiosPromise<ScenarioRunStatus> {
            return localVarFp.stopScenarioRun(organizationId, scenariorunId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScenariorunApi - object-oriented interface
 * @export
 * @class ScenariorunApi
 * @extends {BaseAPI}
 */
export class ScenariorunApi extends BaseAPI {
    /**
     * 
     * @summary Delete all historical ScenarioRuns in the Organization
     * @param {string} organizationId the Organization identifier
     * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public deleteHistoricalDataOrganization(organizationId: string, deleteUnknown?: boolean, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).deleteHistoricalDataOrganization(organizationId, deleteUnknown, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all historical ScenarioRuns in the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public deleteHistoricalDataScenario(organizationId: string, workspaceId: string, scenarioId: string, deleteUnknown?: boolean, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).deleteHistoricalDataScenario(organizationId, workspaceId, scenarioId, deleteUnknown, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all historical ScenarioRuns in the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {boolean} [deleteUnknown] condition to delete runs with an Unknown status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public deleteHistoricalDataWorkspace(organizationId: string, workspaceId: string, deleteUnknown?: boolean, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).deleteHistoricalDataWorkspace(organizationId, workspaceId, deleteUnknown, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scenariorun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public deleteScenarioRun(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).deleteScenarioRun(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a scenariorun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public findScenarioRunById(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).findScenarioRunById(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the cumulated logs of a scenariorun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getScenarioRunCumulatedLogs(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getScenarioRunCumulatedLogs(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the logs for the ScenarioRun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getScenarioRunLogs(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getScenarioRunLogs(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the status for the ScenarioRun
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the ScenarioRun identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getScenarioRunStatus(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getScenarioRunStatus(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the list of ScenarioRuns for the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getScenarioRuns(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getScenarioRuns(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the list of ScenarioRuns for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public getWorkspaceScenarioRuns(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).getWorkspaceScenarioRuns(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary run a ScenarioRun for the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} scenarioId the Scenario identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public runScenario(organizationId: string, workspaceId: string, scenarioId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).runScenario(organizationId, workspaceId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search ScenarioRuns
     * @param {string} organizationId the Organization identifier
     * @param {ScenarioRunSearch} scenarioRunSearch the ScenarioRun search parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public searchScenarioRuns(organizationId: string, scenarioRunSearch: ScenarioRunSearch, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).searchScenarioRuns(organizationId, scenarioRunSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a new scenariorun with raw containers definition
     * @param {string} organizationId the Organization identifier
     * @param {ScenarioRunStartContainers} scenarioRunStartContainers the raw containers definition
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public startScenarioRunContainers(organizationId: string, scenarioRunStartContainers: ScenarioRunStartContainers, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).startScenarioRunContainers(organizationId, scenarioRunStartContainers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary stop a ScenarioRun for the Scenario
     * @param {string} organizationId the Organization identifier
     * @param {string} scenariorunId the scenariorun identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScenariorunApi
     */
    public stopScenarioRun(organizationId: string, scenariorunId: string, options?: AxiosRequestConfig) {
        return ScenariorunApiFp(this.configuration).stopScenarioRun(organizationId, scenariorunId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SolutionApi - axios parameter creator
 * @export
 */
export const SolutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add Parameter Groups. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameterGroups: async (organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceParameterGroups', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('addOrReplaceParameterGroups', 'solutionId', solutionId)
            // verify required parameter 'runTemplateParameterGroup' is not null or undefined
            assertParamExists('addOrReplaceParameterGroups', 'runTemplateParameterGroup', runTemplateParameterGroup)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateParameterGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Parameters. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameters: async (organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceParameters', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('addOrReplaceParameters', 'solutionId', solutionId)
            // verify required parameter 'runTemplateParameter' is not null or undefined
            assertParamExists('addOrReplaceParameters', 'runTemplateParameter', runTemplateParameter)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add Run Templates. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceRunTemplates: async (organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceRunTemplates', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('addOrReplaceRunTemplates', 'solutionId', solutionId)
            // verify required parameter 'runTemplate' is not null or undefined
            assertParamExists('addOrReplaceRunTemplates', 'runTemplate', runTemplate)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolution: async (organizationId: string, solution: Solution, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSolution', 'organizationId', organizationId)
            // verify required parameter 'solution' is not null or undefined
            assertParamExists('createSolution', 'solution', solution)
            const localVarPath = `/organizations/{organization_id}/solutions`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolution: async (organizationId: string, solutionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolution', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionRunTemplate: async (organizationId: string, solutionId: string, runTemplateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'runTemplateId', runTemplateId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates/{run_template_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRunTemplateHandler: async (organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadRunTemplateHandler', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('downloadRunTemplateHandler', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('downloadRunTemplateHandler', 'runTemplateId', runTemplateId)
            // verify required parameter 'handlerId' is not null or undefined
            assertParamExists('downloadRunTemplateHandler', 'handlerId', handlerId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runtemplates/{run_template_id}/handlers/{handler_id}/download`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)))
                .replace(`{${"handler_id"}}`, encodeURIComponent(String(handlerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllSolutions: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllSolutions', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/solutions`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSolutionById: async (organizationId: string, solutionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findSolutionById', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('findSolutionById', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Run Templates from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllRunTemplates: async (organizationId: string, solutionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllRunTemplates', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('removeAllRunTemplates', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Parameter Groups from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameterGroups: async (organizationId: string, solutionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllSolutionParameterGroups', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('removeAllSolutionParameterGroups', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all Parameters from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameters: async (organizationId: string, solutionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllSolutionParameters', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('removeAllSolutionParameters', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Solution} solution the new Solution details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolution: async (organizationId: string, solutionId: string, solution: Solution, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolution', 'solutionId', solutionId)
            // verify required parameter 'solution' is not null or undefined
            assertParamExists('updateSolution', 'solution', solution)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solution, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionRunTemplate: async (organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'runTemplateId', runTemplateId)
            // verify required parameter 'runTemplate' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'runTemplate', runTemplate)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates/{run_template_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {any} body 
         * @param {boolean} [overwrite] whether to overwrite any existing handler resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunTemplateHandler: async (organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, body: any, overwrite?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'runTemplateId', runTemplateId)
            // verify required parameter 'handlerId' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'handlerId', handlerId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadRunTemplateHandler', 'body', body)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runtemplates/{run_template_id}/handlers/{handler_id}/upload`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)))
                .replace(`{${"handler_id"}}`, encodeURIComponent(String(handlerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (overwrite !== undefined) {
                localVarQueryParameter['overwrite'] = overwrite;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SolutionApi - functional programming interface
 * @export
 */
export const SolutionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SolutionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add Parameter Groups. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplateParameterGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add Parameters. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplateParameter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceParameters(organizationId, solutionId, runTemplateParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add Run Templates. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceRunTemplates(organizationId, solutionId, runTemplate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSolution(organizationId: string, solution: Solution, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSolution(organizationId, solution, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolution(organizationId: string, solutionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolution(organizationId, solutionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllSolutions(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Solution>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllSolutions(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSolutionById(organizationId: string, solutionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSolutionById(organizationId, solutionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all Run Templates from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllRunTemplates(organizationId: string, solutionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllRunTemplates(organizationId, solutionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all Parameter Groups from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllSolutionParameterGroups(organizationId: string, solutionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllSolutionParameterGroups(organizationId, solutionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all Parameters from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllSolutionParameters(organizationId: string, solutionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllSolutionParameters(organizationId, solutionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Solution} solution the new Solution details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolution(organizationId: string, solutionId: string, solution: Solution, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolution(organizationId, solutionId, solution, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {any} body 
         * @param {boolean} [overwrite] whether to overwrite any existing handler resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, body: any, overwrite?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, body, overwrite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SolutionApi - factory interface
 * @export
 */
export const SolutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SolutionApiFp(configuration)
    return {
        /**
         * 
         * @summary Add Parameter Groups. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: any): AxiosPromise<Array<RunTemplateParameterGroup>> {
            return localVarFp.addOrReplaceParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Parameters. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: any): AxiosPromise<Array<RunTemplateParameter>> {
            return localVarFp.addOrReplaceParameters(organizationId, solutionId, runTemplateParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add Run Templates. Any item with the same ID will be overwritten
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Array<RunTemplate>} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: any): AxiosPromise<Array<RunTemplate>> {
            return localVarFp.addOrReplaceRunTemplates(organizationId, solutionId, runTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new solution
         * @param {string} organizationId the Organization identifier
         * @param {Solution} solution the Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolution(organizationId: string, solution: Solution, options?: any): AxiosPromise<Solution> {
            return localVarFp.createSolution(organizationId, solution, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolution(organizationId: string, solutionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSolution(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, options?: any): AxiosPromise<any> {
            return localVarFp.downloadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllSolutions(organizationId: string, options?: any): AxiosPromise<Array<Solution>> {
            return localVarFp.findAllSolutions(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSolutionById(organizationId: string, solutionId: string, options?: any): AxiosPromise<Solution> {
            return localVarFp.findSolutionById(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Run Templates from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllRunTemplates(organizationId: string, solutionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllRunTemplates(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Parameter Groups from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameterGroups(organizationId: string, solutionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllSolutionParameterGroups(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all Parameters from the Solution specified
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllSolutionParameters(organizationId: string, solutionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllSolutionParameters(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {Solution} solution the new Solution details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolution(organizationId: string, solutionId: string, solution: Solution, options?: any): AxiosPromise<Solution> {
            return localVarFp.updateSolution(organizationId, solutionId, solution, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified Solution Run Template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplate} runTemplate the Run Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: any): AxiosPromise<Array<RunTemplate>> {
            return localVarFp.updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a Run Template step handler zip file
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId the Run Template identifier
         * @param {RunTemplateHandlerId} handlerId the Handler identifier
         * @param {any} body 
         * @param {boolean} [overwrite] whether to overwrite any existing handler resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, body: any, overwrite?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.uploadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, body, overwrite, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SolutionApi - object-oriented interface
 * @export
 * @class SolutionApi
 * @extends {BaseAPI}
 */
export class SolutionApi extends BaseAPI {
    /**
     * 
     * @summary Add Parameter Groups. Any item with the same ID will be overwritten
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplateParameterGroup>} runTemplateParameterGroup the Parameter Groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public addOrReplaceParameterGroups(organizationId: string, solutionId: string, runTemplateParameterGroup: Array<RunTemplateParameterGroup>, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).addOrReplaceParameterGroups(organizationId, solutionId, runTemplateParameterGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Parameters. Any item with the same ID will be overwritten
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplateParameter>} runTemplateParameter the Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public addOrReplaceParameters(organizationId: string, solutionId: string, runTemplateParameter: Array<RunTemplateParameter>, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).addOrReplaceParameters(organizationId, solutionId, runTemplateParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add Run Templates. Any item with the same ID will be overwritten
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Array<RunTemplate>} runTemplate the Run Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public addOrReplaceRunTemplates(organizationId: string, solutionId: string, runTemplate: Array<RunTemplate>, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).addOrReplaceRunTemplates(organizationId, solutionId, runTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new solution
     * @param {string} organizationId the Organization identifier
     * @param {Solution} solution the Solution to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public createSolution(organizationId: string, solution: Solution, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).createSolution(organizationId, solution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolution(organizationId: string, solutionId: string, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolution(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified Solution Run Template
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a Run Template step handler zip file
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {RunTemplateHandlerId} handlerId the Handler identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public downloadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).downloadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Solutions
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public findAllSolutions(organizationId: string, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).findAllSolutions(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public findSolutionById(organizationId: string, solutionId: string, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).findSolutionById(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Run Templates from the Solution specified
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public removeAllRunTemplates(organizationId: string, solutionId: string, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).removeAllRunTemplates(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Parameter Groups from the Solution specified
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public removeAllSolutionParameterGroups(organizationId: string, solutionId: string, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).removeAllSolutionParameterGroups(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all Parameters from the Solution specified
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public removeAllSolutionParameters(organizationId: string, solutionId: string, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).removeAllSolutionParameters(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {Solution} solution the new Solution details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolution(organizationId: string, solutionId: string, solution: Solution, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolution(organizationId, solutionId, solution, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified Solution Run Template
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {RunTemplate} runTemplate the Run Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplate: RunTemplate, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a Run Template step handler zip file
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId the Run Template identifier
     * @param {RunTemplateHandlerId} handlerId the Handler identifier
     * @param {any} body 
     * @param {boolean} [overwrite] whether to overwrite any existing handler resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public uploadRunTemplateHandler(organizationId: string, solutionId: string, runTemplateId: string, handlerId: RunTemplateHandlerId, body: any, overwrite?: boolean, options?: AxiosRequestConfig) {
        return SolutionApiFp(this.configuration).uploadRunTemplateHandler(organizationId, solutionId, runTemplateId, handlerId, body, overwrite, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authorize an User with OAuth2. Delegated to configured OAuth2 service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth2/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an user
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserById: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('findUserById', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of the logged-in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a logged-in User with roles for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCurrentUser: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationCurrentUser', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/me`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of the logged-in user with roles for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceCurrentUser: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceCurrentUser', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceCurrentUser', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/me`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user
         * @param {User} user the User to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('registerUser', 'user', user)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary test platform API call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPlatform: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unregister an user
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterUser: async (userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('unregisterUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a User
         * @param {string} userId the User identifier
         * @param {User} user the new User details. Organization membership is handled via the /organizations endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: string, user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUser', 'userId', userId)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Authorize an User with OAuth2. Delegated to configured OAuth2 service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorizeUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorizeUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllUsers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of an user
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserById(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserById(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of the logged-in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of a logged-in User with roles for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationCurrentUser(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationCurrentUser(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of the logged-in user with roles for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceCurrentUser(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceCurrentUser(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new user
         * @param {User} user the User to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary test platform API call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testPlatform(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testPlatform(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unregister an user
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unregisterUser(userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unregisterUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a User
         * @param {string} userId the User identifier
         * @param {User} user the new User details. Organization membership is handled via the /organizations endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: string, user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userId, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Authorize an User with OAuth2. Delegated to configured OAuth2 service
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorizeUser(options?: any): AxiosPromise<void> {
            return localVarFp.authorizeUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllUsers(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.findAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an user
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserById(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.findUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of the logged-in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a logged-in User with roles for an Organization
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationCurrentUser(organizationId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getOrganizationCurrentUser(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of the logged-in user with roles for a Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceCurrentUser(organizationId: string, workspaceId: string, options?: any): AxiosPromise<User> {
            return localVarFp.getWorkspaceCurrentUser(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user
         * @param {User} user the User to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.registerUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary test platform API call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPlatform(options?: any): AxiosPromise<string> {
            return localVarFp.testPlatform(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unregister an user
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unregisterUser(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unregisterUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a User
         * @param {string} userId the User identifier
         * @param {User} user the new User details. Organization membership is handled via the /organizations endpoint.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: string, user: User, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(userId, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Authorize an User with OAuth2. Delegated to configured OAuth2 service
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public authorizeUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).authorizeUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public findAllUsers(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).findAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an user
     * @param {string} userId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public findUserById(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).findUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of the logged-in User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCurrentUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a logged-in User with roles for an Organization
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getOrganizationCurrentUser(organizationId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getOrganizationCurrentUser(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of the logged-in user with roles for a Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getWorkspaceCurrentUser(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getWorkspaceCurrentUser(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user
     * @param {User} user the User to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public registerUser(user: User, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).registerUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary test platform API call
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public testPlatform(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).testPlatform(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unregister an user
     * @param {string} userId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public unregisterUser(userId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).unregisterUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a User
     * @param {string} userId the User identifier
     * @param {User} user the new User details. Organization membership is handled via the /organizations endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(userId: string, user: User, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(userId, user, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValidatorApi - axios parameter creator
 * @export
 */
export const ValidatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register a new validator
         * @param {string} organizationId the Organization identifier
         * @param {Validator} validator the Validator to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createValidator: async (organizationId: string, validator: Validator, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createValidator', 'organizationId', organizationId)
            // verify required parameter 'validator' is not null or undefined
            assertParamExists('createValidator', 'validator', validator)
            const localVarPath = `/organizations/{organization_id}/datasets/validators`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validator, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {ValidatorRun} validatorRun the Validator Run to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createValidatorRun: async (organizationId: string, validatorId: string, validatorRun: ValidatorRun, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createValidatorRun', 'organizationId', organizationId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('createValidatorRun', 'validatorId', validatorId)
            // verify required parameter 'validatorRun' is not null or undefined
            assertParamExists('createValidatorRun', 'validatorRun', validatorRun)
            const localVarPath = `/organizations/{organization_id}/datasets/validators/{validator_id}/history`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatorRun, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteValidator: async (organizationId: string, validatorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteValidator', 'organizationId', organizationId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('deleteValidator', 'validatorId', validatorId)
            const localVarPath = `/organizations/{organization_id}/datasets/validators/{validator_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {string} validatorrunId the Validator Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteValidatorRun: async (organizationId: string, validatorId: string, validatorrunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteValidatorRun', 'organizationId', organizationId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('deleteValidatorRun', 'validatorId', validatorId)
            // verify required parameter 'validatorrunId' is not null or undefined
            assertParamExists('deleteValidatorRun', 'validatorrunId', validatorrunId)
            const localVarPath = `/organizations/{organization_id}/datasets/validators/{validator_id}/history/{validatorrun_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)))
                .replace(`{${"validatorrun_id"}}`, encodeURIComponent(String(validatorrunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Validator Runs
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllValidatorRuns: async (organizationId: string, validatorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllValidatorRuns', 'organizationId', organizationId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('findAllValidatorRuns', 'validatorId', validatorId)
            const localVarPath = `/organizations/{organization_id}/datasets/validators/{validator_id}/history`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Validators
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllValidators: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllValidators', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/datasets/validators`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findValidatorById: async (organizationId: string, validatorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findValidatorById', 'organizationId', organizationId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('findValidatorById', 'validatorId', validatorId)
            const localVarPath = `/organizations/{organization_id}/datasets/validators/{validator_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {string} validatorrunId the Validator Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findValidatorRunById: async (organizationId: string, validatorId: string, validatorrunId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findValidatorRunById', 'organizationId', organizationId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('findValidatorRunById', 'validatorId', validatorId)
            // verify required parameter 'validatorrunId' is not null or undefined
            assertParamExists('findValidatorRunById', 'validatorrunId', validatorrunId)
            const localVarPath = `/organizations/{organization_id}/datasets/validators/{validator_id}/history/{validatorrun_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)))
                .replace(`{${"validatorrun_id"}}`, encodeURIComponent(String(validatorrunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Run a Validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {ValidatorRun} validatorRun the Validator to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runValidator: async (organizationId: string, validatorId: string, validatorRun: ValidatorRun, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('runValidator', 'organizationId', organizationId)
            // verify required parameter 'validatorId' is not null or undefined
            assertParamExists('runValidator', 'validatorId', validatorId)
            // verify required parameter 'validatorRun' is not null or undefined
            assertParamExists('runValidator', 'validatorRun', validatorRun)
            const localVarPath = `/organizations/{organization_id}/datasets/validators/{validator_id}/run`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"validator_id"}}`, encodeURIComponent(String(validatorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatorRun, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValidatorApi - functional programming interface
 * @export
 */
export const ValidatorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValidatorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register a new validator
         * @param {string} organizationId the Organization identifier
         * @param {Validator} validator the Validator to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createValidator(organizationId: string, validator: Validator, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Validator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createValidator(organizationId, validator, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {ValidatorRun} validatorRun the Validator Run to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createValidatorRun(organizationId: string, validatorId: string, validatorRun: ValidatorRun, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createValidatorRun(organizationId, validatorId, validatorRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteValidator(organizationId: string, validatorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteValidator(organizationId, validatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {string} validatorrunId the Validator Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteValidatorRun(organizationId: string, validatorId: string, validatorrunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteValidatorRun(organizationId, validatorId, validatorrunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Validator Runs
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllValidatorRuns(organizationId: string, validatorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ValidatorRun>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllValidatorRuns(organizationId, validatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Validators
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllValidators(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Validator>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllValidators(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of a validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findValidatorById(organizationId: string, validatorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Validator>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findValidatorById(organizationId, validatorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of a validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {string} validatorrunId the Validator Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findValidatorRunById(organizationId: string, validatorId: string, validatorrunId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findValidatorRunById(organizationId, validatorId, validatorrunId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Run a Validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {ValidatorRun} validatorRun the Validator to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runValidator(organizationId: string, validatorId: string, validatorRun: ValidatorRun, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runValidator(organizationId, validatorId, validatorRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValidatorApi - factory interface
 * @export
 */
export const ValidatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValidatorApiFp(configuration)
    return {
        /**
         * 
         * @summary Register a new validator
         * @param {string} organizationId the Organization identifier
         * @param {Validator} validator the Validator to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createValidator(organizationId: string, validator: Validator, options?: any): AxiosPromise<Validator> {
            return localVarFp.createValidator(organizationId, validator, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {ValidatorRun} validatorRun the Validator Run to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createValidatorRun(organizationId: string, validatorId: string, validatorRun: ValidatorRun, options?: any): AxiosPromise<ValidatorRun> {
            return localVarFp.createValidatorRun(organizationId, validatorId, validatorRun, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteValidator(organizationId: string, validatorId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteValidator(organizationId, validatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {string} validatorrunId the Validator Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteValidatorRun(organizationId: string, validatorId: string, validatorrunId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteValidatorRun(organizationId, validatorId, validatorrunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Validator Runs
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllValidatorRuns(organizationId: string, validatorId: string, options?: any): AxiosPromise<Array<ValidatorRun>> {
            return localVarFp.findAllValidatorRuns(organizationId, validatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Validators
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllValidators(organizationId: string, options?: any): AxiosPromise<Array<Validator>> {
            return localVarFp.findAllValidators(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findValidatorById(organizationId: string, validatorId: string, options?: any): AxiosPromise<Validator> {
            return localVarFp.findValidatorById(organizationId, validatorId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a validator run
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the Validator identifier
         * @param {string} validatorrunId the Validator Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findValidatorRunById(organizationId: string, validatorId: string, validatorrunId: string, options?: any): AxiosPromise<ValidatorRun> {
            return localVarFp.findValidatorRunById(organizationId, validatorId, validatorrunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Run a Validator
         * @param {string} organizationId the Organization identifier
         * @param {string} validatorId the ValidatorRun identifier
         * @param {ValidatorRun} validatorRun the Validator to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runValidator(organizationId: string, validatorId: string, validatorRun: ValidatorRun, options?: any): AxiosPromise<ValidatorRun> {
            return localVarFp.runValidator(organizationId, validatorId, validatorRun, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ValidatorApi - object-oriented interface
 * @export
 * @class ValidatorApi
 * @extends {BaseAPI}
 */
export class ValidatorApi extends BaseAPI {
    /**
     * 
     * @summary Register a new validator
     * @param {string} organizationId the Organization identifier
     * @param {Validator} validator the Validator to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public createValidator(organizationId: string, validator: Validator, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).createValidator(organizationId, validator, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new validator run
     * @param {string} organizationId the Organization identifier
     * @param {string} validatorId the ValidatorRun identifier
     * @param {ValidatorRun} validatorRun the Validator Run to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public createValidatorRun(organizationId: string, validatorId: string, validatorRun: ValidatorRun, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).createValidatorRun(organizationId, validatorId, validatorRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a validator
     * @param {string} organizationId the Organization identifier
     * @param {string} validatorId the Validator identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public deleteValidator(organizationId: string, validatorId: string, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).deleteValidator(organizationId, validatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a validator run
     * @param {string} organizationId the Organization identifier
     * @param {string} validatorId the Validator identifier
     * @param {string} validatorrunId the Validator Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public deleteValidatorRun(organizationId: string, validatorId: string, validatorrunId: string, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).deleteValidatorRun(organizationId, validatorId, validatorrunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Validator Runs
     * @param {string} organizationId the Organization identifier
     * @param {string} validatorId the ValidatorRun identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public findAllValidatorRuns(organizationId: string, validatorId: string, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).findAllValidatorRuns(organizationId, validatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Validators
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public findAllValidators(organizationId: string, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).findAllValidators(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a validator
     * @param {string} organizationId the Organization identifier
     * @param {string} validatorId the Validator identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public findValidatorById(organizationId: string, validatorId: string, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).findValidatorById(organizationId, validatorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a validator run
     * @param {string} organizationId the Organization identifier
     * @param {string} validatorId the Validator identifier
     * @param {string} validatorrunId the Validator Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public findValidatorRunById(organizationId: string, validatorId: string, validatorrunId: string, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).findValidatorRunById(organizationId, validatorId, validatorrunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Run a Validator
     * @param {string} organizationId the Organization identifier
     * @param {string} validatorId the ValidatorRun identifier
     * @param {ValidatorRun} validatorRun the Validator to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorApi
     */
    public runValidator(organizationId: string, validatorId: string, validatorRun: ValidatorRun, options?: AxiosRequestConfig) {
        return ValidatorApiFp(this.configuration).runValidator(organizationId, validatorId, validatorRun, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WorkspaceApi - axios parameter creator
 * @export
 */
export const WorkspaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add (or replace) users to the Workspace specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Array<WorkspaceUser>} workspaceUser the Users to add. Any User with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceUsersInOrganizationWorkspace: async (organizationId: string, workspaceId: string, workspaceUser: Array<WorkspaceUser>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('addOrReplaceUsersInOrganizationWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addOrReplaceUsersInOrganizationWorkspace', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceUser' is not null or undefined
            assertParamExists('addOrReplaceUsersInOrganizationWorkspace', 'workspaceUser', workspaceUser)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a secret for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceSecret} workspaceSecret the definition of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret: async (organizationId: string, workspaceId: string, workspaceSecret: WorkspaceSecret, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSecret', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createSecret', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceSecret' is not null or undefined
            assertParamExists('createSecret', 'workspaceSecret', workspaceSecret)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/secret`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceSecret, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace: async (organizationId: string, workspace: Workspace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('createWorkspace', 'workspace', workspace)
            const localVarPath = `/organizations/{organization_id}/workspaces`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllWorkspaceFiles: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteAllWorkspaceFiles', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteAllWorkspaceFiles', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFile: async (organizationId: string, workspaceId: string, fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'fileName', fileName)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files/delete`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadWorkspaceFile: async (organizationId: string, workspaceId: string, fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('downloadWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('downloadWorkspaceFile', 'fileName', fileName)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files/download`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaceFiles: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllWorkspaceFiles', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findAllWorkspaceFiles', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaces: async (organizationId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findAllWorkspaces', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/workspaces`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkspaceById: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('findWorkspaceById', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findWorkspaceById', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all users from the Workspace specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllUsersOfWorkspace: async (organizationId: string, workspaceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeAllUsersOfWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeAllUsersOfWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified user from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromOrganizationWorkspace: async (organizationId: string, workspaceId: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('removeUserFromOrganizationWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('removeUserFromOrganizationWorkspace', 'workspaceId', workspaceId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFromOrganizationWorkspace', 'userId', userId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/users/{user_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Workspace} workspace the new Workspace details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace: async (organizationId: string, workspaceId: string, workspace: Workspace, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceId', workspaceId)
            // verify required parameter 'workspace' is not null or undefined
            assertParamExists('updateWorkspace', 'workspace', workspace)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {any} file 
         * @param {boolean} [overwrite] 
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadWorkspaceFile: async (organizationId: string, workspaceId: string, file: any, overwrite?: boolean, destination?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('uploadWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('uploadWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadWorkspaceFile', 'file', file)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


            if (overwrite !== undefined) { 
                localVarFormParams.append('overwrite', overwrite as any);
            }
    
            if (destination !== undefined) { 
                localVarFormParams.append('destination', destination as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspaceApi - functional programming interface
 * @export
 */
export const WorkspaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add (or replace) users to the Workspace specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Array<WorkspaceUser>} workspaceUser the Users to add. Any User with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrReplaceUsersInOrganizationWorkspace(organizationId: string, workspaceId: string, workspaceUser: Array<WorkspaceUser>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrReplaceUsersInOrganizationWorkspace(organizationId, workspaceId, workspaceUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a secret for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceSecret} workspaceSecret the definition of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSecret(organizationId: string, workspaceId: string, workspaceSecret: WorkspaceSecret, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSecret(organizationId, workspaceId, workspaceSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspace(organizationId: string, workspace: Workspace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspace(organizationId, workspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllWorkspaceFiles(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspace(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspace(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceFile(organizationId, workspaceId, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadWorkspaceFile(organizationId, workspaceId, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllWorkspaceFiles(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllWorkspaces(organizationId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workspace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllWorkspaces(organizationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findWorkspaceById(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findWorkspaceById(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all users from the Workspace specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAllUsersOfWorkspace(organizationId: string, workspaceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAllUsersOfWorkspace(organizationId, workspaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove the specified user from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFromOrganizationWorkspace(organizationId: string, workspaceId: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFromOrganizationWorkspace(organizationId, workspaceId, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Workspace} workspace the new Workspace details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspace(organizationId: string, workspaceId: string, workspace: Workspace, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspace(organizationId, workspaceId, workspace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {any} file 
         * @param {boolean} [overwrite] 
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadWorkspaceFile(organizationId: string, workspaceId: string, file: any, overwrite?: boolean, destination?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WorkspaceApi - factory interface
 * @export
 */
export const WorkspaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspaceApiFp(configuration)
    return {
        /**
         * 
         * @summary Add (or replace) users to the Workspace specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Array<WorkspaceUser>} workspaceUser the Users to add. Any User with the same ID is overwritten
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrReplaceUsersInOrganizationWorkspace(organizationId: string, workspaceId: string, workspaceUser: Array<WorkspaceUser>, options?: any): AxiosPromise<Array<WorkspaceUser>> {
            return localVarFp.addOrReplaceUsersInOrganizationWorkspace(organizationId, workspaceId, workspaceUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a secret for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {WorkspaceSecret} workspaceSecret the definition of the secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret(organizationId: string, workspaceId: string, workspaceSecret: WorkspaceSecret, options?: any): AxiosPromise<void> {
            return localVarFp.createSecret(organizationId, workspaceId, workspaceSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId the Organization identifier
         * @param {Workspace} workspace the Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(organizationId: string, workspace: Workspace, options?: any): AxiosPromise<Workspace> {
            return localVarFp.createWorkspace(organizationId, workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Workspace> {
            return localVarFp.deleteWorkspace(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} fileName the file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: any): AxiosPromise<any> {
            return localVarFp.downloadWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Array<WorkspaceFile>> {
            return localVarFp.findAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId the Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllWorkspaces(organizationId: string, options?: any): AxiosPromise<Array<Workspace>> {
            return localVarFp.findAllWorkspaces(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findWorkspaceById(organizationId: string, workspaceId: string, options?: any): AxiosPromise<Workspace> {
            return localVarFp.findWorkspaceById(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all users from the Workspace specified
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAllUsersOfWorkspace(organizationId: string, workspaceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeAllUsersOfWorkspace(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified user from the given Organization Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} userId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFromOrganizationWorkspace(organizationId: string, workspaceId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeUserFromOrganizationWorkspace(organizationId, workspaceId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Workspace} workspace the new Workspace details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(organizationId: string, workspaceId: string, workspace: Workspace, options?: any): AxiosPromise<Workspace> {
            return localVarFp.updateWorkspace(organizationId, workspaceId, workspace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {any} file 
         * @param {boolean} [overwrite] 
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadWorkspaceFile(organizationId: string, workspaceId: string, file: any, overwrite?: boolean, destination?: string, options?: any): AxiosPromise<WorkspaceFile> {
            return localVarFp.uploadWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspaceApi - object-oriented interface
 * @export
 * @class WorkspaceApi
 * @extends {BaseAPI}
 */
export class WorkspaceApi extends BaseAPI {
    /**
     * 
     * @summary Add (or replace) users to the Workspace specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {Array<WorkspaceUser>} workspaceUser the Users to add. Any User with the same ID is overwritten
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public addOrReplaceUsersInOrganizationWorkspace(organizationId: string, workspaceId: string, workspaceUser: Array<WorkspaceUser>, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).addOrReplaceUsersInOrganizationWorkspace(organizationId, workspaceId, workspaceUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a secret for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {WorkspaceSecret} workspaceSecret the definition of the secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createSecret(organizationId: string, workspaceId: string, workspaceSecret: WorkspaceSecret, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createSecret(organizationId, workspaceId, workspaceSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new workspace
     * @param {string} organizationId the Organization identifier
     * @param {Workspace} workspace the Workspace to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createWorkspace(organizationId: string, workspace: Workspace, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createWorkspace(organizationId, workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all Workspace files
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspace(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspace(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace file
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} fileName the file name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download the Workspace File specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} fileName the file name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public downloadWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).downloadWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Workspace files
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public findAllWorkspaceFiles(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).findAllWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Workspaces
     * @param {string} organizationId the Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public findAllWorkspaces(organizationId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).findAllWorkspaces(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public findWorkspaceById(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).findWorkspaceById(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all users from the Workspace specified
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public removeAllUsersOfWorkspace(organizationId: string, workspaceId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).removeAllUsersOfWorkspace(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified user from the given Organization Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} userId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public removeUserFromOrganizationWorkspace(organizationId: string, workspaceId: string, userId: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).removeUserFromOrganizationWorkspace(organizationId, workspaceId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {Workspace} workspace the new Workspace details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspace(organizationId: string, workspaceId: string, workspace: Workspace, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspace(organizationId, workspaceId, workspace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a file for the Workspace
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {any} file 
     * @param {boolean} [overwrite] 
     * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public uploadWorkspaceFile(organizationId: string, workspaceId: string, file: any, overwrite?: boolean, destination?: string, options?: AxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).uploadWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options).then((request) => request(this.axios, this.basePath));
    }
}


