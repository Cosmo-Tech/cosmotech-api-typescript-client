/* tslint:disable */
/* eslint-disable */
/**
 * Cosmo Tech Platform API
 * Cosmo Tech Platform API
 *
 * The version of the OpenAPI document: 5.0.0-beta5
 * Contact: platform@cosmotech.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Misc information about the api
 * @export
 * @interface AboutInfo
 */
export interface AboutInfo {
    /**
     * 
     * @type {AboutInfoVersion}
     * @memberof AboutInfo
     */
    'version': AboutInfoVersion;
}
/**
 * API version details
 * @export
 * @interface AboutInfoVersion
 */
export interface AboutInfoVersion {
    /**
     * Full version representation
     * @type {string}
     * @memberof AboutInfoVersion
     */
    'full': string;
    /**
     * Release main version representation
     * @type {string}
     * @memberof AboutInfoVersion
     */
    'release': string;
    /**
     * Major version number
     * @type {number}
     * @memberof AboutInfoVersion
     */
    'major': number;
    /**
     * Minor version number
     * @type {number}
     * @memberof AboutInfoVersion
     */
    'minor': number;
    /**
     * Patch version number
     * @type {number}
     * @memberof AboutInfoVersion
     */
    'patch': number;
    /**
     * Label version, may be empty
     * @type {string}
     * @memberof AboutInfoVersion
     */
    'label': string;
    /**
     * Build VCS id
     * @type {string}
     * @memberof AboutInfoVersion
     */
    'build': string;
}
/**
 * A RBAC by component
 * @export
 * @interface ComponentRolePermissions
 */
export interface ComponentRolePermissions {
    /**
     * 
     * @type {string}
     * @memberof ComponentRolePermissions
     */
    'component': string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ComponentRolePermissions
     */
    'roles': { [key: string]: Array<string>; };
}
/**
 * define cpus and memory needs
 * @export
 * @interface ContainerResourceSizeInfo
 */
export interface ContainerResourceSizeInfo {
    /**
     * define cpu needs
     * @type {string}
     * @memberof ContainerResourceSizeInfo
     */
    'cpu': string;
    /**
     * define memory needs
     * @type {string}
     * @memberof ContainerResourceSizeInfo
     */
    'memory': string;
}
/**
 * a description object for resource requests and limits (default same configuration as basic sizing)
 * @export
 * @interface ContainerResourceSizing
 */
export interface ContainerResourceSizing {
    /**
     * 
     * @type {ContainerResourceSizeInfo}
     * @memberof ContainerResourceSizing
     */
    'requests': ContainerResourceSizeInfo;
    /**
     * 
     * @type {ContainerResourceSizeInfo}
     * @memberof ContainerResourceSizing
     */
    'limits': ContainerResourceSizeInfo;
}
/**
 * 
 * @export
 * @interface CreateInfo
 */
export interface CreateInfo {
    /**
     * The timestamp of the creation in millisecond
     * @type {number}
     * @memberof CreateInfo
     */
    'timestamp': number;
    /**
     * The id of the user who did the creation
     * @type {string}
     * @memberof CreateInfo
     */
    'userId': string;
    /**
     * The runner id which has created the dataset (nullable)
     * @type {string}
     * @memberof CreateInfo
     */
    'runnerId'?: string;
}
/**
 * Newly created Run info
 * @export
 * @interface CreatedRun
 */
export interface CreatedRun {
    /**
     * Run id
     * @type {string}
     * @memberof CreatedRun
     */
    'id': string;
}
/**
 * Dataset object
 * @export
 * @interface Dataset
 */
export interface Dataset {
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Dataset
     */
    'description'?: string;
    /**
     * the associated Organization Id
     * @type {string}
     * @memberof Dataset
     */
    'organizationId': string;
    /**
     * the associated Workspace Id
     * @type {string}
     * @memberof Dataset
     */
    'workspaceId': string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Dataset
     */
    'tags': Array<string>;
    /**
     * 
     * @type {Array<DatasetPart>}
     * @memberof Dataset
     */
    'parts': Array<DatasetPart>;
    /**
     * The details of the Dataset creation
     * @type {CreateInfo}
     * @memberof Dataset
     */
    'createInfo': CreateInfo;
    /**
     * The details of the Dataset last update
     * @type {EditInfo}
     * @memberof Dataset
     */
    'updateInfo': EditInfo;
    /**
     * 
     * @type {DatasetSecurity}
     * @memberof Dataset
     */
    'security': DatasetSecurity;
}
/**
 * a Dataset access control item
 * @export
 * @interface DatasetAccessControl
 */
export interface DatasetAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof DatasetAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof DatasetAccessControl
     */
    'role': string;
}
/**
 * Dataset creation request
 * @export
 * @interface DatasetCreateRequest
 */
export interface DatasetCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof DatasetCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DatasetCreateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DatasetCreateRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<DatasetPartCreateRequest>}
     * @memberof DatasetCreateRequest
     */
    'parts'?: Array<DatasetPartCreateRequest>;
    /**
     * 
     * @type {DatasetSecurity}
     * @memberof DatasetCreateRequest
     */
    'security'?: DatasetSecurity;
    /**
     * 
     * @type {string}
     * @memberof DatasetCreateRequest
     */
    'runnerId'?: string;
}
/**
 * Dataset part object
 * @export
 * @interface DatasetPart
 */
export interface DatasetPart {
    /**
     * 
     * @type {string}
     * @memberof DatasetPart
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DatasetPart
     */
    'name': string;
    /**
     * the source data name (e.g. filename associated to the dataset part)
     * @type {string}
     * @memberof DatasetPart
     */
    'sourceName': string;
    /**
     * 
     * @type {string}
     * @memberof DatasetPart
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DatasetPart
     */
    'tags': Array<string>;
    /**
     * 
     * @type {DatasetPartTypeEnum}
     * @memberof DatasetPart
     */
    'type': DatasetPartTypeEnum;
    /**
     * the associated Organization Id
     * @type {string}
     * @memberof DatasetPart
     */
    'organizationId': string;
    /**
     * the associated Workspace Id
     * @type {string}
     * @memberof DatasetPart
     */
    'workspaceId': string;
    /**
     * the associated Dataset Id
     * @type {string}
     * @memberof DatasetPart
     */
    'datasetId': string;
    /**
     * The details of the Dataset creation
     * @type {EditInfo}
     * @memberof DatasetPart
     */
    'createInfo': EditInfo;
    /**
     * The details of the Dataset last update
     * @type {EditInfo}
     * @memberof DatasetPart
     */
    'updateInfo': EditInfo;
}


/**
 * Dataset part create request object
 * @export
 * @interface DatasetPartCreateRequest
 */
export interface DatasetPartCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof DatasetPartCreateRequest
     */
    'name': string;
    /**
     * the source data name (e.g. filename associated to the dataset part)
     * @type {string}
     * @memberof DatasetPartCreateRequest
     */
    'sourceName': string;
    /**
     * 
     * @type {string}
     * @memberof DatasetPartCreateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DatasetPartCreateRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {DatasetPartTypeEnum}
     * @memberof DatasetPartCreateRequest
     */
    'type'?: DatasetPartTypeEnum;
}


/**
 * The dataset part Type
 * @export
 * @enum {string}
 */

export const DatasetPartTypeEnum = {
    File: 'File',
    Db: 'DB'
} as const;

export type DatasetPartTypeEnum = typeof DatasetPartTypeEnum[keyof typeof DatasetPartTypeEnum];


/**
 * Dataset part update request object
 * @export
 * @interface DatasetPartUpdateRequest
 */
export interface DatasetPartUpdateRequest {
    /**
     * the source data name (e.g. filename associated to the dataset part)
     * @type {string}
     * @memberof DatasetPartUpdateRequest
     */
    'sourceName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetPartUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DatasetPartUpdateRequest
     */
    'tags'?: Array<string>;
}
/**
 * the Dataset Role
 * @export
 * @interface DatasetRole
 */
export interface DatasetRole {
    /**
     * the Dataset Role
     * @type {string}
     * @memberof DatasetRole
     */
    'role': string;
}
/**
 * the dataset security information
 * @export
 * @interface DatasetSecurity
 */
export interface DatasetSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof DatasetSecurity
     */
    'default': string;
    /**
     * the list which can access this Dataset with detailed access control information
     * @type {Array<DatasetAccessControl>}
     * @memberof DatasetSecurity
     */
    'accessControlList': Array<DatasetAccessControl>;
}
/**
 * Dataset creation request
 * @export
 * @interface DatasetUpdateRequest
 */
export interface DatasetUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof DatasetUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DatasetUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DatasetUpdateRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {Array<DatasetPartCreateRequest>}
     * @memberof DatasetUpdateRequest
     */
    'parts'?: Array<DatasetPartCreateRequest>;
    /**
     * 
     * @type {DatasetSecurity}
     * @memberof DatasetUpdateRequest
     */
    'security'?: DatasetSecurity;
}
/**
 * 
 * @export
 * @interface EditInfo
 */
export interface EditInfo {
    /**
     * The timestamp of the modification in millisecond
     * @type {number}
     * @memberof EditInfo
     */
    'timestamp': number;
    /**
     * The id of the user who did the modification
     * @type {string}
     * @memberof EditInfo
     */
    'userId': string;
}
/**
 * last run info from current runner
 * @export
 * @interface LastRunInfo
 */
export interface LastRunInfo {
    /**
     * last run id from current runner
     * @type {string}
     * @memberof LastRunInfo
     */
    'lastRunId'?: string;
    /**
     * last run status from current runner
     * @type {string}
     * @memberof LastRunInfo
     */
    'lastRunStatus'?: LastRunInfoLastRunStatusEnum;
}

export const LastRunInfoLastRunStatusEnum = {
    NotStarted: 'NotStarted',
    Running: 'Running',
    Successful: 'Successful',
    Failed: 'Failed',
    Unknown: 'Unknown'
} as const;

export type LastRunInfoLastRunStatusEnum = typeof LastRunInfoLastRunStatusEnum[keyof typeof LastRunInfoLastRunStatusEnum];

/**
 * An Organization
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * The Organization unique identifier
     * @type {string}
     * @memberof Organization
     */
    'id': string;
    /**
     * The Organization name
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * The details of the Organization creation
     * @type {OrganizationEditInfo}
     * @memberof Organization
     */
    'createInfo': OrganizationEditInfo;
    /**
     * The details of the Organization last update
     * @type {OrganizationEditInfo}
     * @memberof Organization
     */
    'updateInfo': OrganizationEditInfo;
    /**
     * 
     * @type {OrganizationSecurity}
     * @memberof Organization
     */
    'security': OrganizationSecurity;
}
/**
 * Response object for organization access control
 * @export
 * @interface OrganizationAccessControl
 */
export interface OrganizationAccessControl {
    /**
     * The identity id
     * @type {string}
     * @memberof OrganizationAccessControl
     */
    'id': string;
    /**
     * A role
     * @type {string}
     * @memberof OrganizationAccessControl
     */
    'role': string;
}
/**
 * Request object for creating a new organization
 * @export
 * @interface OrganizationCreateRequest
 */
export interface OrganizationCreateRequest {
    /**
     * The Organization name
     * @type {string}
     * @memberof OrganizationCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {OrganizationSecurity}
     * @memberof OrganizationCreateRequest
     */
    'security'?: OrganizationSecurity;
}
/**
 * 
 * @export
 * @interface OrganizationEditInfo
 */
export interface OrganizationEditInfo {
    /**
     * The timestamp of the modification in millisecond
     * @type {number}
     * @memberof OrganizationEditInfo
     */
    'timestamp': number;
    /**
     * The id of the user who did the modification
     * @type {string}
     * @memberof OrganizationEditInfo
     */
    'userId': string;
}
/**
 * The Organization Role
 * @export
 * @interface OrganizationRole
 */
export interface OrganizationRole {
    /**
     * The Organization Role
     * @type {string}
     * @memberof OrganizationRole
     */
    'role': string;
}
/**
 * Response object for organization security information
 * @export
 * @interface OrganizationSecurity
 */
export interface OrganizationSecurity {
    /**
     * The role by default
     * @type {string}
     * @memberof OrganizationSecurity
     */
    'default': string;
    /**
     * The list which can access this Organization with detailed access control information
     * @type {Array<OrganizationAccessControl>}
     * @memberof OrganizationSecurity
     */
    'accessControlList': Array<OrganizationAccessControl>;
}
/**
 * Request object for updating an organization
 * @export
 * @interface OrganizationUpdateRequest
 */
export interface OrganizationUpdateRequest {
    /**
     * The Organization name
     * @type {string}
     * @memberof OrganizationUpdateRequest
     */
    'name'?: string;
}
/**
 * the result of a SQL Query
 * @export
 * @interface QueryResult
 */
export interface QueryResult {
    /**
     * the list of results
     * @type {Array<{ [key: string]: any; }>}
     * @memberof QueryResult
     */
    'result'?: Array<{ [key: string]: any; }>;
}
/**
 * define cpus and memory needs
 * @export
 * @interface ResourceSizeInfo
 */
export interface ResourceSizeInfo {
    /**
     * define cpu needs
     * @type {string}
     * @memberof ResourceSizeInfo
     */
    'cpu': string;
    /**
     * define memory needs
     * @type {string}
     * @memberof ResourceSizeInfo
     */
    'memory': string;
}
/**
 * a Run with only base properties
 * @export
 * @interface Run
 */
export interface Run {
    /**
     * the Run
     * @type {string}
     * @memberof Run
     */
    'id'?: string;
    /**
     * 
     * @type {RunState}
     * @memberof Run
     */
    'state'?: RunState;
    /**
     * the Organization id
     * @type {string}
     * @memberof Run
     */
    'organizationId'?: string;
    /**
     * The details of the Run creation
     * @type {RunEditInfo}
     * @memberof Run
     */
    'createInfo': RunEditInfo;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof Run
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech Simulation Run Id
     * @type {string}
     * @memberof Run
     */
    'csmSimulationRun'?: string;
    /**
     * the base name for workflow name generation
     * @type {string}
     * @memberof Run
     */
    'generateName'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof Run
     */
    'workflowName'?: string;
    /**
     * the Workspace Id
     * @type {string}
     * @memberof Run
     */
    'workspaceId'?: string;
    /**
     * technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof Run
     */
    'workspaceKey'?: string;
    /**
     * the Runner Id
     * @type {string}
     * @memberof Run
     */
    'runnerId'?: string;
    /**
     * the Solution Id
     * @type {string}
     * @memberof Run
     */
    'solutionId'?: string;
    /**
     * the Solution Run Template id
     * @type {string}
     * @memberof Run
     */
    'runTemplateId'?: string;
    /**
     * the compute size needed for this Analysis. Standard sizes are basic and highcpu. Default is basic
     * @type {string}
     * @memberof Run
     */
    'computeSize'?: string;
    /**
     * the list of Dataset Id associated to this Run
     * @type {Array<string>}
     * @memberof Run
     */
    'datasetList'?: Array<string>;
    /**
     * the list of Run Template parameters values
     * @type {Array<RunTemplateParameterValue>}
     * @memberof Run
     */
    'parametersValues'?: Array<RunTemplateParameterValue>;
    /**
     * the node label request
     * @type {string}
     * @memberof Run
     */
    'nodeLabel'?: string;
    /**
     * the containers list. This information is not returned by the API.
     * @type {Array<RunContainer>}
     * @memberof Run
     */
    'containers'?: Array<RunContainer>;
}


/**
 * a Run container description
 * @export
 * @interface RunContainer
 */
export interface RunContainer {
    /**
     * the container Id
     * @type {string}
     * @memberof RunContainer
     */
    'id'?: string;
    /**
     * the container name
     * @type {string}
     * @memberof RunContainer
     */
    'name': string;
    /**
     * the metadata labels
     * @type {{ [key: string]: string; }}
     * @memberof RunContainer
     */
    'labels'?: { [key: string]: string; };
    /**
     * environment variable map
     * @type {{ [key: string]: string; }}
     * @memberof RunContainer
     */
    'envVars'?: { [key: string]: string; };
    /**
     * the container image URI
     * @type {string}
     * @memberof RunContainer
     */
    'image': string;
    /**
     * the container entry point
     * @type {string}
     * @memberof RunContainer
     */
    'entrypoint'?: string;
    /**
     * the list of run arguments for the container
     * @type {Array<string>}
     * @memberof RunContainer
     */
    'runArgs'?: Array<string>;
    /**
     * the list of dependencies container name to run this container
     * @type {Array<string>}
     * @memberof RunContainer
     */
    'dependencies'?: Array<string>;
    /**
     * whether or not this container is a Cosmo Tech solution container
     * @type {boolean}
     * @memberof RunContainer
     */
    'solutionContainer'?: boolean;
    /**
     * the node label request
     * @type {string}
     * @memberof RunContainer
     */
    'nodeLabel'?: string;
    /**
     * 
     * @type {ContainerResourceSizing}
     * @memberof RunContainer
     */
    'runSizing'?: ContainerResourceSizing;
}
/**
 * Run Data stored
 * @export
 * @interface RunData
 */
export interface RunData {
    /**
     * Database name
     * @type {string}
     * @memberof RunData
     */
    'database_name'?: string;
    /**
     * Table name
     * @type {string}
     * @memberof RunData
     */
    'table_name'?: string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof RunData
     */
    'data'?: Array<{ [key: string]: any; }>;
}
/**
 * a data result query in SQL
 * @export
 * @interface RunDataQuery
 */
export interface RunDataQuery {
    /**
     * the query in SQL
     * @type {string}
     * @memberof RunDataQuery
     */
    'query': string;
}
/**
 * 
 * @export
 * @interface RunEditInfo
 */
export interface RunEditInfo {
    /**
     * The timestamp of the modification in millisecond
     * @type {number}
     * @memberof RunEditInfo
     */
    'timestamp': number;
    /**
     * The id of the user who did the modification
     * @type {string}
     * @memberof RunEditInfo
     */
    'userId': string;
}
/**
 * the memory and CPU requested by the pod
 * @export
 * @interface RunResourceRequested
 */
export interface RunResourceRequested {
    /**
     * the cpu requested
     * @type {number}
     * @memberof RunResourceRequested
     */
    'cpu'?: number;
    /**
     * the memory requested
     * @type {number}
     * @memberof RunResourceRequested
     */
    'memory'?: number;
}
/**
 * the Run end-to-end state
 * @export
 * @enum {string}
 */

export const RunState = {
    Running: 'Running',
    Successful: 'Successful',
    Failed: 'Failed',
    Unknown: 'Unknown',
    NotStarted: 'NotStarted'
} as const;

export type RunState = typeof RunState[keyof typeof RunState];


/**
 * a Run status
 * @export
 * @interface RunStatus
 */
export interface RunStatus {
    /**
     * the Run id
     * @type {string}
     * @memberof RunStatus
     */
    'id'?: string;
    /**
     * the Organization id
     * @type {string}
     * @memberof RunStatus
     */
    'organizationId'?: string;
    /**
     * the Workspace id
     * @type {string}
     * @memberof RunStatus
     */
    'workspaceId'?: string;
    /**
     * the Runner id
     * @type {string}
     * @memberof RunStatus
     */
    'runnerId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Id to search
     * @type {string}
     * @memberof RunStatus
     */
    'workflowId'?: string;
    /**
     * the Cosmo Tech compute cluster Argo Workflow Name
     * @type {string}
     * @memberof RunStatus
     */
    'workflowName'?: string;
    /**
     * The timestamp of the Run creation in milliseconds
     * @type {RunEditInfo}
     * @memberof RunStatus
     */
    'createInfo'?: RunEditInfo;
    /**
     * the Run start Date Time
     * @type {string}
     * @memberof RunStatus
     */
    'startTime'?: string;
    /**
     * the Run end Date Time
     * @type {string}
     * @memberof RunStatus
     */
    'endTime'?: string;
    /**
     * high-level summary of where the workflow is in its lifecycle
     * @type {string}
     * @memberof RunStatus
     */
    'phase'?: string;
    /**
     * progress to completion
     * @type {string}
     * @memberof RunStatus
     */
    'progress'?: string;
    /**
     * a  human readable message indicating details about why the workflow is in this condition
     * @type {string}
     * @memberof RunStatus
     */
    'message'?: string;
    /**
     * estimatedDuration in seconds
     * @type {number}
     * @memberof RunStatus
     */
    'estimatedDuration'?: number;
    /**
     * status of Run nodes
     * @type {Array<RunStatusNode>}
     * @memberof RunStatus
     */
    'nodes'?: Array<RunStatusNode>;
    /**
     * 
     * @type {RunState}
     * @memberof RunStatus
     */
    'state'?: RunState;
}


/**
 * status of a Run Node
 * @export
 * @interface RunStatusNode
 */
export interface RunStatusNode {
    /**
     * the node id
     * @type {string}
     * @memberof RunStatusNode
     */
    'id'?: string;
    /**
     * the node unique name
     * @type {string}
     * @memberof RunStatusNode
     */
    'name'?: string;
    /**
     * the Run container name
     * @type {string}
     * @memberof RunStatusNode
     */
    'containerName'?: string;
    /**
     * the list of outbound nodes
     * @type {Array<string>}
     * @memberof RunStatusNode
     */
    'outboundNodes'?: Array<string>;
    /**
     * 
     * @type {RunResourceRequested}
     * @memberof RunStatusNode
     */
    'resourcesDuration'?: RunResourceRequested;
    /**
     * estimatedDuration in seconds
     * @type {number}
     * @memberof RunStatusNode
     */
    'estimatedDuration'?: number;
    /**
     * HostNodeName name of the Kubernetes node on which the Pod is running, if applicable
     * @type {string}
     * @memberof RunStatusNode
     */
    'hostNodeName'?: string;
    /**
     * a human readable message indicating details about why the node is in this condition
     * @type {string}
     * @memberof RunStatusNode
     */
    'message'?: string;
    /**
     * high-level summary of where the node is in its lifecycle
     * @type {string}
     * @memberof RunStatusNode
     */
    'phase'?: string;
    /**
     * progress to completion
     * @type {string}
     * @memberof RunStatusNode
     */
    'progress'?: string;
    /**
     * the node start time
     * @type {string}
     * @memberof RunStatusNode
     */
    'startTime'?: string;
    /**
     * the node end time
     * @type {string}
     * @memberof RunStatusNode
     */
    'endTime'?: string;
}
/**
 * A Solution Run Template
 * @export
 * @interface RunTemplate
 */
export interface RunTemplate {
    /**
     * The Solution Run Template id
     * @type {string}
     * @memberof RunTemplate
     */
    'id': string;
    /**
     * The Run Template name
     * @type {string}
     * @memberof RunTemplate
     */
    'name'?: string;
    /**
     * A translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplate
     */
    'labels'?: { [key: string]: string; };
    /**
     * The Run Template description
     * @type {string}
     * @memberof RunTemplate
     */
    'description'?: string;
    /**
     * The list of Run Template tags
     * @type {Array<string>}
     * @memberof RunTemplate
     */
    'tags'?: Array<string>;
    /**
     * The compute size needed for this Run Template
     * @type {string}
     * @memberof RunTemplate
     */
    'computeSize'?: string;
    /**
     * 
     * @type {RunTemplateResourceSizing}
     * @memberof RunTemplate
     */
    'runSizing'?: RunTemplateResourceSizing;
    /**
     * The ordered list of parameters groups for the Run Template
     * @type {Array<string>}
     * @memberof RunTemplate
     */
    'parameterGroups': Array<string>;
    /**
     * An optional duration in seconds in which a workflow is allowed to run
     * @type {number}
     * @memberof RunTemplate
     */
    'executionTimeout'?: number;
}
/**
 * A Solution Run Template Create Request
 * @export
 * @interface RunTemplateCreateRequest
 */
export interface RunTemplateCreateRequest {
    /**
     * The Solution Run Template id
     * @type {string}
     * @memberof RunTemplateCreateRequest
     */
    'id': string;
    /**
     * The Run Template name
     * @type {string}
     * @memberof RunTemplateCreateRequest
     */
    'name'?: string;
    /**
     * A translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateCreateRequest
     */
    'labels'?: { [key: string]: string; };
    /**
     * The Run Template description
     * @type {string}
     * @memberof RunTemplateCreateRequest
     */
    'description'?: string;
    /**
     * The list of Run Template tags
     * @type {Array<string>}
     * @memberof RunTemplateCreateRequest
     */
    'tags'?: Array<string>;
    /**
     * The compute size needed for this Run Template
     * @type {string}
     * @memberof RunTemplateCreateRequest
     */
    'computeSize'?: string;
    /**
     * 
     * @type {RunTemplateResourceSizing}
     * @memberof RunTemplateCreateRequest
     */
    'runSizing'?: RunTemplateResourceSizing;
    /**
     * The ordered list of parameters groups for the Run Template
     * @type {Array<string>}
     * @memberof RunTemplateCreateRequest
     */
    'parameterGroups'?: Array<string>;
    /**
     * An optional duration in seconds in which a workflow is allowed to run
     * @type {number}
     * @memberof RunTemplateCreateRequest
     */
    'executionTimeout'?: number;
}
/**
 * A Run Template Parameter
 * @export
 * @interface RunTemplateParameter
 */
export interface RunTemplateParameter {
    /**
     * The Parameter id
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'id': string;
    /**
     * The parameter description
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'description'?: string;
    /**
     * A translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameter
     */
    'labels'?: { [key: string]: string; };
    /**
     * The variable type for the parameter. Basic types or special type %DATASETID%
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'varType': string;
    /**
     * The default value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'defaultValue'?: string;
    /**
     * The minimum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'minValue'?: string;
    /**
     * The maximum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'maxValue'?: string;
    /**
     * A regex to validate the value
     * @type {string}
     * @memberof RunTemplateParameter
     */
    'regexValidation'?: string;
    /**
     * Freeform options
     * @type {{ [key: string]: any; }}
     * @memberof RunTemplateParameter
     */
    'options'?: { [key: string]: any; };
}
/**
 * A Run Template Parameter for creation
 * @export
 * @interface RunTemplateParameterCreateRequest
 */
export interface RunTemplateParameterCreateRequest {
    /**
     * The Parameter id
     * @type {string}
     * @memberof RunTemplateParameterCreateRequest
     */
    'id': string;
    /**
     * The parameter description
     * @type {string}
     * @memberof RunTemplateParameterCreateRequest
     */
    'description'?: string;
    /**
     * A translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameterCreateRequest
     */
    'labels'?: { [key: string]: string; };
    /**
     * The variable type for the parameter. Basic types or special type %DATASETID%
     * @type {string}
     * @memberof RunTemplateParameterCreateRequest
     */
    'varType': string;
    /**
     * The default value for this parameter
     * @type {string}
     * @memberof RunTemplateParameterCreateRequest
     */
    'defaultValue'?: string;
    /**
     * The minimum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameterCreateRequest
     */
    'minValue'?: string;
    /**
     * The maximum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameterCreateRequest
     */
    'maxValue'?: string;
    /**
     * A regex to validate the value
     * @type {string}
     * @memberof RunTemplateParameterCreateRequest
     */
    'regexValidation'?: string;
    /**
     * Freeform options
     * @type {{ [key: string]: any; }}
     * @memberof RunTemplateParameterCreateRequest
     */
    'options'?: { [key: string]: any; };
}
/**
 * A Parameter Group for a Run Template
 * @export
 * @interface RunTemplateParameterGroup
 */
export interface RunTemplateParameterGroup {
    /**
     * The Parameter Group id
     * @type {string}
     * @memberof RunTemplateParameterGroup
     */
    'id': string;
    /**
     * A description of the parameter group
     * @type {string}
     * @memberof RunTemplateParameterGroup
     */
    'description'?: string;
    /**
     * A translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameterGroup
     */
    'labels'?: { [key: string]: string; };
    /**
     * Does the group define a table
     * @type {boolean}
     * @memberof RunTemplateParameterGroup
     */
    'isTable': boolean;
    /**
     * Freeform options
     * @type {{ [key: string]: any; }}
     * @memberof RunTemplateParameterGroup
     */
    'options'?: { [key: string]: any; };
    /**
     * The Run Template Group parent Id
     * @type {string}
     * @memberof RunTemplateParameterGroup
     */
    'parentId'?: string;
    /**
     * An ordered list of Run Template Parameters
     * @type {Array<string>}
     * @memberof RunTemplateParameterGroup
     */
    'parameters': Array<string>;
}
/**
 * A Parameter Group Create Request for a Run Template
 * @export
 * @interface RunTemplateParameterGroupCreateRequest
 */
export interface RunTemplateParameterGroupCreateRequest {
    /**
     * The Parameter Group id
     * @type {string}
     * @memberof RunTemplateParameterGroupCreateRequest
     */
    'id': string;
    /**
     * A description of the parameter group
     * @type {string}
     * @memberof RunTemplateParameterGroupCreateRequest
     */
    'description'?: string;
    /**
     * A translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameterGroupCreateRequest
     */
    'labels'?: { [key: string]: string; };
    /**
     * Does the group define a table
     * @type {boolean}
     * @memberof RunTemplateParameterGroupCreateRequest
     */
    'isTable'?: boolean;
    /**
     * Freeform options
     * @type {{ [key: string]: any; }}
     * @memberof RunTemplateParameterGroupCreateRequest
     */
    'options'?: { [key: string]: any; };
    /**
     * The Run Template Group parent Id
     * @type {string}
     * @memberof RunTemplateParameterGroupCreateRequest
     */
    'parentId'?: string;
    /**
     * An ordered list of Run Template Parameters
     * @type {Array<string>}
     * @memberof RunTemplateParameterGroupCreateRequest
     */
    'parameters'?: Array<string>;
}
/**
 * A Parameter Group Update Request for a Run Template
 * @export
 * @interface RunTemplateParameterGroupUpdateRequest
 */
export interface RunTemplateParameterGroupUpdateRequest {
    /**
     * A description of the parameter group
     * @type {string}
     * @memberof RunTemplateParameterGroupUpdateRequest
     */
    'description'?: string;
    /**
     * A translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameterGroupUpdateRequest
     */
    'labels'?: { [key: string]: string; };
    /**
     * Does the group define a table
     * @type {boolean}
     * @memberof RunTemplateParameterGroupUpdateRequest
     */
    'isTable'?: boolean;
    /**
     * Freeform options
     * @type {{ [key: string]: any; }}
     * @memberof RunTemplateParameterGroupUpdateRequest
     */
    'options'?: { [key: string]: any; };
    /**
     * The Run Template Group parent Id
     * @type {string}
     * @memberof RunTemplateParameterGroupUpdateRequest
     */
    'parentId'?: string;
    /**
     * An ordered list of Run Template Parameters
     * @type {Array<string>}
     * @memberof RunTemplateParameterGroupUpdateRequest
     */
    'parameters'?: Array<string>;
}
/**
 * A Run Template Parameter for update parameter
 * @export
 * @interface RunTemplateParameterUpdateRequest
 */
export interface RunTemplateParameterUpdateRequest {
    /**
     * The parameter description
     * @type {string}
     * @memberof RunTemplateParameterUpdateRequest
     */
    'description'?: string;
    /**
     * A translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateParameterUpdateRequest
     */
    'labels'?: { [key: string]: string; };
    /**
     * The variable type for the parameter. Basic types or special type %DATASETID%
     * @type {string}
     * @memberof RunTemplateParameterUpdateRequest
     */
    'varType'?: string;
    /**
     * The default value for this parameter
     * @type {string}
     * @memberof RunTemplateParameterUpdateRequest
     */
    'defaultValue'?: string;
    /**
     * The minimum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameterUpdateRequest
     */
    'minValue'?: string;
    /**
     * The maximum value for this parameter
     * @type {string}
     * @memberof RunTemplateParameterUpdateRequest
     */
    'maxValue'?: string;
    /**
     * A regex to validate the value
     * @type {string}
     * @memberof RunTemplateParameterUpdateRequest
     */
    'regexValidation'?: string;
    /**
     * Freeform options
     * @type {{ [key: string]: any; }}
     * @memberof RunTemplateParameterUpdateRequest
     */
    'options'?: { [key: string]: any; };
}
/**
 * the value of Analysis parameter for a Runner for this Run
 * @export
 * @interface RunTemplateParameterValue
 */
export interface RunTemplateParameterValue {
    /**
     * the parameter Id
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'parameterId': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value
     * @type {string}
     * @memberof RunTemplateParameterValue
     */
    'value': string;
}
/**
 * A description object for resource requests and limits
 * @export
 * @interface RunTemplateResourceSizing
 */
export interface RunTemplateResourceSizing {
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunTemplateResourceSizing
     */
    'requests': ResourceSizeInfo;
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunTemplateResourceSizing
     */
    'limits': ResourceSizeInfo;
}
/**
 * A Solution Run Template Create Request
 * @export
 * @interface RunTemplateUpdateRequest
 */
export interface RunTemplateUpdateRequest {
    /**
     * The Run Template name
     * @type {string}
     * @memberof RunTemplateUpdateRequest
     */
    'name'?: string;
    /**
     * A translated label with key as ISO 639-1 code
     * @type {{ [key: string]: string; }}
     * @memberof RunTemplateUpdateRequest
     */
    'labels'?: { [key: string]: string; };
    /**
     * The Run Template description
     * @type {string}
     * @memberof RunTemplateUpdateRequest
     */
    'description'?: string;
    /**
     * The list of Run Template tags
     * @type {Array<string>}
     * @memberof RunTemplateUpdateRequest
     */
    'tags'?: Array<string>;
    /**
     * The compute size needed for this Run Template
     * @type {string}
     * @memberof RunTemplateUpdateRequest
     */
    'computeSize'?: string;
    /**
     * 
     * @type {RunTemplateResourceSizing}
     * @memberof RunTemplateUpdateRequest
     */
    'runSizing'?: RunTemplateResourceSizing;
    /**
     * The ordered list of parameters groups for the Run Template
     * @type {Array<string>}
     * @memberof RunTemplateUpdateRequest
     */
    'parameterGroups'?: Array<string>;
    /**
     * An optional duration in seconds in which a workflow is allowed to run
     * @type {number}
     * @memberof RunTemplateUpdateRequest
     */
    'executionTimeout'?: number;
}
/**
 * a Runner with complete information
 * @export
 * @interface Runner
 */
export interface Runner {
    /**
     * the Runner unique identifier
     * @type {string}
     * @memberof Runner
     */
    'id': string;
    /**
     * the Runner name
     * @type {string}
     * @memberof Runner
     */
    'name': string;
    /**
     * the Runner description
     * @type {string}
     * @memberof Runner
     */
    'description'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof Runner
     */
    'tags'?: Array<string>;
    /**
     * the Runner parent id
     * @type {string}
     * @memberof Runner
     */
    'parentId'?: string;
    /**
     * The details of the Runner creation
     * @type {RunnerEditInfo}
     * @memberof Runner
     */
    'createInfo': RunnerEditInfo;
    /**
     * The details of the Runner last update
     * @type {RunnerEditInfo}
     * @memberof Runner
     */
    'updateInfo': RunnerEditInfo;
    /**
     * the runner root id
     * @type {string}
     * @memberof Runner
     */
    'rootId'?: string;
    /**
     * the Solution Id associated with this Runner
     * @type {string}
     * @memberof Runner
     */
    'solutionId': string;
    /**
     * the Solution Run Template Id associated with this Runner
     * @type {string}
     * @memberof Runner
     */
    'runTemplateId': string;
    /**
     * the associated Organization Id
     * @type {string}
     * @memberof Runner
     */
    'organizationId': string;
    /**
     * the associated Workspace Id
     * @type {string}
     * @memberof Runner
     */
    'workspaceId': string;
    /**
     * the name of the owner
     * @type {string}
     * @memberof Runner
     */
    'ownerName': string;
    /**
     * the Solution name
     * @type {string}
     * @memberof Runner
     */
    'solutionName'?: string;
    /**
     * the Solution Run Template name associated with this Runner
     * @type {string}
     * @memberof Runner
     */
    'runTemplateName'?: string;
    /**
     * 
     * @type {RunnerDatasets}
     * @memberof Runner
     */
    'datasets': RunnerDatasets;
    /**
     * 
     * @type {RunnerResourceSizing}
     * @memberof Runner
     */
    'runSizing'?: RunnerResourceSizing;
    /**
     * the list of Solution Run Template parameters values
     * @type {Array<RunnerRunTemplateParameterValue>}
     * @memberof Runner
     */
    'parametersValues': Array<RunnerRunTemplateParameterValue>;
    /**
     * 
     * @type {LastRunInfo}
     * @memberof Runner
     */
    'lastRunInfo': LastRunInfo;
    /**
     * 
     * @type {RunnerValidationStatus}
     * @memberof Runner
     */
    'validationStatus': RunnerValidationStatus;
    /**
     * 
     * @type {RunnerSecurity}
     * @memberof Runner
     */
    'security': RunnerSecurity;
}


/**
 * a Runner access control item
 * @export
 * @interface RunnerAccessControl
 */
export interface RunnerAccessControl {
    /**
     * the identity id
     * @type {string}
     * @memberof RunnerAccessControl
     */
    'id': string;
    /**
     * a role
     * @type {string}
     * @memberof RunnerAccessControl
     */
    'role': string;
}
/**
 * Request object for creating a new runner
 * @export
 * @interface RunnerCreateRequest
 */
export interface RunnerCreateRequest {
    /**
     * the Runner name
     * @type {string}
     * @memberof RunnerCreateRequest
     */
    'name': string;
    /**
     * the Runner description
     * @type {string}
     * @memberof RunnerCreateRequest
     */
    'description'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof RunnerCreateRequest
     */
    'tags'?: Array<string>;
    /**
     * the Solution Id associated with this Runner
     * @type {string}
     * @memberof RunnerCreateRequest
     */
    'solutionId': string;
    /**
     * the Runner parent id
     * @type {string}
     * @memberof RunnerCreateRequest
     */
    'parentId'?: string;
    /**
     * the Solution Run Template Id associated with this Runner
     * @type {string}
     * @memberof RunnerCreateRequest
     */
    'runTemplateId': string;
    /**
     * the list of Dataset Id associated to this Runner Run Template
     * @type {Array<string>}
     * @memberof RunnerCreateRequest
     */
    'datasetList'?: Array<string>;
    /**
     * 
     * @type {RunnerResourceSizing}
     * @memberof RunnerCreateRequest
     */
    'runSizing'?: RunnerResourceSizing;
    /**
     * the list of Solution Run Template parameters values
     * @type {Array<RunnerRunTemplateParameterValue>}
     * @memberof RunnerCreateRequest
     */
    'parametersValues'?: Array<RunnerRunTemplateParameterValue>;
    /**
     * the name of the owner
     * @type {string}
     * @memberof RunnerCreateRequest
     */
    'ownerName': string;
    /**
     * the Solution name
     * @type {string}
     * @memberof RunnerCreateRequest
     */
    'solutionName'?: string;
    /**
     * the Solution Run Template name associated with this Runner
     * @type {string}
     * @memberof RunnerCreateRequest
     */
    'runTemplateName'?: string;
    /**
     * 
     * @type {RunnerSecurity}
     * @memberof RunnerCreateRequest
     */
    'security'?: RunnerSecurity;
}
/**
 * 
 * @export
 * @interface RunnerDatasets
 */
export interface RunnerDatasets {
    /**
     * a list of Dataset Id used to build the Runner
     * @type {Array<string>}
     * @memberof RunnerDatasets
     */
    'bases': Array<string>;
    /**
     * The dataset id used for dataset parameters on current Runner
     * @type {string}
     * @memberof RunnerDatasets
     */
    'parameter': string;
    /**
     * The dataset parts retrieved from the parameter property (programmatically fulfilled)
     * @type {Array<object>}
     * @memberof RunnerDatasets
     */
    'parameters'?: Array<object>;
}
/**
 * 
 * @export
 * @interface RunnerEditInfo
 */
export interface RunnerEditInfo {
    /**
     * The timestamp of the modification in millisecond
     * @type {number}
     * @memberof RunnerEditInfo
     */
    'timestamp': number;
    /**
     * The id of the user who did the modification
     * @type {string}
     * @memberof RunnerEditInfo
     */
    'userId': string;
}
/**
 * a description object for resource requests and limits (default same configuration as basic sizing)
 * @export
 * @interface RunnerResourceSizing
 */
export interface RunnerResourceSizing {
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunnerResourceSizing
     */
    'requests': ResourceSizeInfo;
    /**
     * 
     * @type {ResourceSizeInfo}
     * @memberof RunnerResourceSizing
     */
    'limits': ResourceSizeInfo;
}
/**
 * the Runner Role
 * @export
 * @interface RunnerRole
 */
export interface RunnerRole {
    /**
     * the Runner Role
     * @type {string}
     * @memberof RunnerRole
     */
    'role': string;
}
/**
 * the value of a Solution Run Template parameter for a Runner
 * @export
 * @interface RunnerRunTemplateParameterValue
 */
export interface RunnerRunTemplateParameterValue {
    /**
     * the parameter Id
     * @type {string}
     * @memberof RunnerRunTemplateParameterValue
     */
    'parameterId': string;
    /**
     * the parameter value type
     * @type {string}
     * @memberof RunnerRunTemplateParameterValue
     */
    'varType'?: string;
    /**
     * the parameter value
     * @type {string}
     * @memberof RunnerRunTemplateParameterValue
     */
    'value': string;
    /**
     * whether or not the value is inherited from parent or has been changed
     * @type {boolean}
     * @memberof RunnerRunTemplateParameterValue
     */
    'isInherited'?: boolean;
}
/**
 * the Runner security information
 * @export
 * @interface RunnerSecurity
 */
export interface RunnerSecurity {
    /**
     * the role by default
     * @type {string}
     * @memberof RunnerSecurity
     */
    'default': string;
    /**
     * the list which can access this Runner with detailed access control information
     * @type {Array<RunnerAccessControl>}
     * @memberof RunnerSecurity
     */
    'accessControlList': Array<RunnerAccessControl>;
}
/**
 * Request object for updating a runner
 * @export
 * @interface RunnerUpdateRequest
 */
export interface RunnerUpdateRequest {
    /**
     * the Runner name
     * @type {string}
     * @memberof RunnerUpdateRequest
     */
    'name'?: string;
    /**
     * the Runner description
     * @type {string}
     * @memberof RunnerUpdateRequest
     */
    'description'?: string;
    /**
     * the list of tags
     * @type {Array<string>}
     * @memberof RunnerUpdateRequest
     */
    'tags'?: Array<string>;
    /**
     * the Solution Run Template Id associated with this Runner
     * @type {string}
     * @memberof RunnerUpdateRequest
     */
    'runTemplateId'?: string;
    /**
     * the list of Dataset Id associated to this Runner Run Template
     * @type {Array<string>}
     * @memberof RunnerUpdateRequest
     */
    'datasetList'?: Array<string>;
    /**
     * 
     * @type {RunnerResourceSizing}
     * @memberof RunnerUpdateRequest
     */
    'runSizing'?: RunnerResourceSizing;
    /**
     * the list of Solution Run Template parameters values
     * @type {Array<RunnerRunTemplateParameterValue>}
     * @memberof RunnerUpdateRequest
     */
    'parametersValues'?: Array<RunnerRunTemplateParameterValue>;
    /**
     * the name of the owner
     * @type {string}
     * @memberof RunnerUpdateRequest
     */
    'ownerName'?: string;
    /**
     * the Solution name
     * @type {string}
     * @memberof RunnerUpdateRequest
     */
    'solutionName'?: string;
    /**
     * the Solution Run Template name associated with this Runner
     * @type {string}
     * @memberof RunnerUpdateRequest
     */
    'runTemplateName'?: string;
}
/**
 * the validation status of the runner
 * @export
 * @enum {string}
 */

export const RunnerValidationStatus = {
    Draft: 'Draft',
    Rejected: 'Rejected',
    Unknown: 'Unknown',
    Validated: 'Validated'
} as const;

export type RunnerValidationStatus = typeof RunnerValidationStatus[keyof typeof RunnerValidationStatus];


/**
 * Run Data to send
 * @export
 * @interface SendRunDataRequest
 */
export interface SendRunDataRequest {
    /**
     * 
     * @type {string}
     * @memberof SendRunDataRequest
     */
    'id': string;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof SendRunDataRequest
     */
    'data': Array<{ [key: string]: any; }>;
}
/**
 * A version of a Solution
 * @export
 * @interface Solution
 */
export interface Solution {
    /**
     * The Solution version unique identifier
     * @type {string}
     * @memberof Solution
     */
    'id': string;
    /**
     * The Organization unique identifier
     * @type {string}
     * @memberof Solution
     */
    'organizationId': string;
    /**
     * The Solution key which groups Solution versions
     * @type {string}
     * @memberof Solution
     */
    'key': string;
    /**
     * The Solution name
     * @type {string}
     * @memberof Solution
     */
    'name': string;
    /**
     * The Solution description
     * @type {string}
     * @memberof Solution
     */
    'description'?: string;
    /**
     * The registry repository containing the image
     * @type {string}
     * @memberof Solution
     */
    'repository': string;
    /**
     * Set to true if the runtemplate wants to always pull the image
     * @type {boolean}
     * @memberof Solution
     */
    'alwaysPull'?: boolean;
    /**
     * The Solution version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof Solution
     */
    'version': string;
    /**
     * The details of the Solution creation
     * @type {SolutionEditInfo}
     * @memberof Solution
     */
    'createInfo': SolutionEditInfo;
    /**
     * The details of the Solution last update
     * @type {SolutionEditInfo}
     * @memberof Solution
     */
    'updateInfo': SolutionEditInfo;
    /**
     * The full SDK version used to build this solution, if available
     * @type {string}
     * @memberof Solution
     */
    'sdkVersion'?: string;
    /**
     * An optional URL link to solution page
     * @type {string}
     * @memberof Solution
     */
    'url'?: string;
    /**
     * The list of tags
     * @type {Array<string>}
     * @memberof Solution
     */
    'tags'?: Array<string>;
    /**
     * The list of Run Template Parameters
     * @type {Array<RunTemplateParameter>}
     * @memberof Solution
     */
    'parameters': Array<RunTemplateParameter>;
    /**
     * The list of parameters groups for the Run Templates
     * @type {Array<RunTemplateParameterGroup>}
     * @memberof Solution
     */
    'parameterGroups': Array<RunTemplateParameterGroup>;
    /**
     * List of Run Templates
     * @type {Array<RunTemplate>}
     * @memberof Solution
     */
    'runTemplates': Array<RunTemplate>;
    /**
     * 
     * @type {SolutionSecurity}
     * @memberof Solution
     */
    'security': SolutionSecurity;
}
/**
 * A Solution access control item
 * @export
 * @interface SolutionAccessControl
 */
export interface SolutionAccessControl {
    /**
     * The identity id
     * @type {string}
     * @memberof SolutionAccessControl
     */
    'id': string;
    /**
     * The assigned role
     * @type {string}
     * @memberof SolutionAccessControl
     */
    'role': string;
}
/**
 * Request object for creating a new solution
 * @export
 * @interface SolutionCreateRequest
 */
export interface SolutionCreateRequest {
    /**
     * Technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof SolutionCreateRequest
     */
    'key': string;
    /**
     * Solution name. This name is displayed in the sample webApp
     * @type {string}
     * @memberof SolutionCreateRequest
     */
    'name': string;
    /**
     * The Solution description
     * @type {string}
     * @memberof SolutionCreateRequest
     */
    'description'?: string;
    /**
     * The registry repository containing the image
     * @type {string}
     * @memberof SolutionCreateRequest
     */
    'repository': string;
    /**
     * The Solution version MAJOR.MINOR.PATCH
     * @type {string}
     * @memberof SolutionCreateRequest
     */
    'version': string;
    /**
     * Set to true if the runtemplate wants to always pull the image
     * @type {boolean}
     * @memberof SolutionCreateRequest
     */
    'alwaysPull'?: boolean;
    /**
     * The list of tags
     * @type {Array<string>}
     * @memberof SolutionCreateRequest
     */
    'tags'?: Array<string>;
    /**
     * The list of Run Template Parameters
     * @type {Array<RunTemplateParameterCreateRequest>}
     * @memberof SolutionCreateRequest
     */
    'parameters'?: Array<RunTemplateParameterCreateRequest>;
    /**
     * The list of parameters groups for the Run Templates
     * @type {Array<RunTemplateParameterGroupCreateRequest>}
     * @memberof SolutionCreateRequest
     */
    'parameterGroups'?: Array<RunTemplateParameterGroupCreateRequest>;
    /**
     * List of Run Templates
     * @type {Array<RunTemplateCreateRequest>}
     * @memberof SolutionCreateRequest
     */
    'runTemplates'?: Array<RunTemplateCreateRequest>;
    /**
     * An optional URL link to solution page
     * @type {string}
     * @memberof SolutionCreateRequest
     */
    'url'?: string;
    /**
     * 
     * @type {SolutionSecurity}
     * @memberof SolutionCreateRequest
     */
    'security'?: SolutionSecurity;
}
/**
 * 
 * @export
 * @interface SolutionEditInfo
 */
export interface SolutionEditInfo {
    /**
     * The timestamp of the modification in millisecond
     * @type {number}
     * @memberof SolutionEditInfo
     */
    'timestamp': number;
    /**
     * The id of the user who did the modification
     * @type {string}
     * @memberof SolutionEditInfo
     */
    'userId': string;
}
/**
 * The Solution Role
 * @export
 * @interface SolutionRole
 */
export interface SolutionRole {
    /**
     * The Solution Role
     * @type {string}
     * @memberof SolutionRole
     */
    'role': string;
}
/**
 * The Solution security information
 * @export
 * @interface SolutionSecurity
 */
export interface SolutionSecurity {
    /**
     * The role by default
     * @type {string}
     * @memberof SolutionSecurity
     */
    'default': string;
    /**
     * The list which can access this Solution with detailed access control information
     * @type {Array<SolutionAccessControl>}
     * @memberof SolutionSecurity
     */
    'accessControlList': Array<SolutionAccessControl>;
}
/**
 * Request object for updating a solution
 * @export
 * @interface SolutionUpdateRequest
 */
export interface SolutionUpdateRequest {
    /**
     * Technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof SolutionUpdateRequest
     */
    'key'?: string;
    /**
     * The Solution name
     * @type {string}
     * @memberof SolutionUpdateRequest
     */
    'name'?: string;
    /**
     * The Solution description
     * @type {string}
     * @memberof SolutionUpdateRequest
     */
    'description'?: string;
    /**
     * The registry repository containing the image
     * @type {string}
     * @memberof SolutionUpdateRequest
     */
    'repository'?: string;
    /**
     * Set to true if the runtemplate wants to always pull the image
     * @type {boolean}
     * @memberof SolutionUpdateRequest
     */
    'alwaysPull'?: boolean;
    /**
     * The Solution version MAJOR.MINOR.PATCH. Must be aligned with an existing repository tag
     * @type {string}
     * @memberof SolutionUpdateRequest
     */
    'version'?: string;
    /**
     * An optional URL link to solution page
     * @type {string}
     * @memberof SolutionUpdateRequest
     */
    'url'?: string;
    /**
     * The list of tags
     * @type {Array<string>}
     * @memberof SolutionUpdateRequest
     */
    'tags'?: Array<string>;
    /**
     * The list of Run Template Parameters
     * @type {Array<RunTemplateParameterCreateRequest>}
     * @memberof SolutionUpdateRequest
     */
    'parameters'?: Array<RunTemplateParameterCreateRequest>;
    /**
     * The list of parameters groups for the Run Templates
     * @type {Array<RunTemplateParameterGroupCreateRequest>}
     * @memberof SolutionUpdateRequest
     */
    'parameterGroups'?: Array<RunTemplateParameterGroupCreateRequest>;
    /**
     * List of Run Templates
     * @type {Array<RunTemplateCreateRequest>}
     * @memberof SolutionUpdateRequest
     */
    'runTemplates'?: Array<RunTemplateCreateRequest>;
}
/**
 * A Workspace
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * Workspace unique identifier generated by the API
     * @type {string}
     * @memberof Workspace
     */
    'id': string;
    /**
     * Organization unique identifier under which the workspace resides
     * @type {string}
     * @memberof Workspace
     */
    'organizationId': string;
    /**
     * Technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof Workspace
     */
    'key': string;
    /**
     * Workspace name. This name is display in the sample webApp
     * @type {string}
     * @memberof Workspace
     */
    'name': string;
    /**
     * The Workspace description
     * @type {string}
     * @memberof Workspace
     */
    'description'?: string;
    /**
     * The Workspace version MAJOR.MINOR.PATCH.
     * @type {string}
     * @memberof Workspace
     */
    'version'?: string;
    /**
     * The list of tags
     * @type {Array<string>}
     * @memberof Workspace
     */
    'tags'?: Array<string>;
    /**
     * The details of the Workspace creation
     * @type {WorkspaceEditInfo}
     * @memberof Workspace
     */
    'createInfo': WorkspaceEditInfo;
    /**
     * The details of the Workspace last update
     * @type {WorkspaceEditInfo}
     * @memberof Workspace
     */
    'updateInfo': WorkspaceEditInfo;
    /**
     * 
     * @type {WorkspaceSolution}
     * @memberof Workspace
     */
    'solution': WorkspaceSolution;
    /**
     * 
     * @type {WorkspaceWebApp}
     * @memberof Workspace
     */
    'webApp'?: WorkspaceWebApp;
    /**
     * Activate the copy of dataset on scenario creation, meaning that each scenario created in this workspace will make this copy. when false, scenario use directly the dataset specified.
     * @type {boolean}
     * @memberof Workspace
     */
    'datasetCopy'?: boolean;
    /**
     * 
     * @type {WorkspaceSecurity}
     * @memberof Workspace
     */
    'security': WorkspaceSecurity;
}
/**
 * A Workspace access control item
 * @export
 * @interface WorkspaceAccessControl
 */
export interface WorkspaceAccessControl {
    /**
     * The identity id
     * @type {string}
     * @memberof WorkspaceAccessControl
     */
    'id': string;
    /**
     * A role
     * @type {string}
     * @memberof WorkspaceAccessControl
     */
    'role': string;
}
/**
 * Request object for creating a new workspace
 * @export
 * @interface WorkspaceCreateRequest
 */
export interface WorkspaceCreateRequest {
    /**
     * Technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof WorkspaceCreateRequest
     */
    'key': string;
    /**
     * Workspace name. This name is displayed in the sample webApp
     * @type {string}
     * @memberof WorkspaceCreateRequest
     */
    'name': string;
    /**
     * The Workspace description
     * @type {string}
     * @memberof WorkspaceCreateRequest
     */
    'description'?: string;
    /**
     * The Workspace version MAJOR.MINOR.PATCH.
     * @type {string}
     * @memberof WorkspaceCreateRequest
     */
    'version'?: string;
    /**
     * The list of tags
     * @type {Array<string>}
     * @memberof WorkspaceCreateRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {WorkspaceSolution}
     * @memberof WorkspaceCreateRequest
     */
    'solution': WorkspaceSolution;
    /**
     * 
     * @type {WorkspaceWebApp}
     * @memberof WorkspaceCreateRequest
     */
    'webApp'?: WorkspaceWebApp;
    /**
     * Activate the copy of dataset on scenario creation
     * @type {boolean}
     * @memberof WorkspaceCreateRequest
     */
    'datasetCopy'?: boolean;
    /**
     * 
     * @type {WorkspaceSecurity}
     * @memberof WorkspaceCreateRequest
     */
    'security'?: WorkspaceSecurity;
}
/**
 * 
 * @export
 * @interface WorkspaceEditInfo
 */
export interface WorkspaceEditInfo {
    /**
     * The timestamp of the modification in millisecond
     * @type {number}
     * @memberof WorkspaceEditInfo
     */
    'timestamp': number;
    /**
     * The id of the user who did the modification
     * @type {string}
     * @memberof WorkspaceEditInfo
     */
    'userId': string;
}
/**
 * A Workspace File resource
 * @export
 * @interface WorkspaceFile
 */
export interface WorkspaceFile {
    /**
     * The Workspace File name
     * @type {string}
     * @memberof WorkspaceFile
     */
    'fileName': string;
}
/**
 * The Workspace Role
 * @export
 * @interface WorkspaceRole
 */
export interface WorkspaceRole {
    /**
     * The Workspace Role
     * @type {string}
     * @memberof WorkspaceRole
     */
    'role': string;
}
/**
 * The workspace security information
 * @export
 * @interface WorkspaceSecurity
 */
export interface WorkspaceSecurity {
    /**
     * The role by default
     * @type {string}
     * @memberof WorkspaceSecurity
     */
    'default': string;
    /**
     * The list which can access this Workspace with detailed access control information
     * @type {Array<WorkspaceAccessControl>}
     * @memberof WorkspaceSecurity
     */
    'accessControlList': Array<WorkspaceAccessControl>;
}
/**
 * The Workspace Solution configuration
 * @export
 * @interface WorkspaceSolution
 */
export interface WorkspaceSolution {
    /**
     * The Solution Id attached to this workspace
     * @type {string}
     * @memberof WorkspaceSolution
     */
    'solutionId': string;
    /**
     * The Dataset Id attached to this workspace. This dataset will be used to store default values for Solution parameters with file\'s varType. 
     * @type {string}
     * @memberof WorkspaceSolution
     */
    'datasetId'?: string;
    /**
     * A map of parameterId/value to set default values for Solution parameters with simple varType (int, string, ...)
     * @type {{ [key: string]: string; }}
     * @memberof WorkspaceSolution
     */
    'defaultParameterValues'?: { [key: string]: string; };
    /**
     * The list of Solution Run Template Id to filter
     * @type {Array<string>}
     * @memberof WorkspaceSolution
     */
    'runTemplateFilter'?: Array<string>;
    /**
     * A map of RunTemplateId/DatasetId to set a default dataset for a Run Template
     * @type {{ [key: string]: any; }}
     * @memberof WorkspaceSolution
     */
    'defaultRunTemplateDataset'?: { [key: string]: any; };
}
/**
 * Request object for updating a workspace
 * @export
 * @interface WorkspaceUpdateRequest
 */
export interface WorkspaceUpdateRequest {
    /**
     * Technical key for resource name convention and version grouping. Must be unique
     * @type {string}
     * @memberof WorkspaceUpdateRequest
     */
    'key'?: string;
    /**
     * Workspace name
     * @type {string}
     * @memberof WorkspaceUpdateRequest
     */
    'name'?: string;
    /**
     * The Workspace description
     * @type {string}
     * @memberof WorkspaceUpdateRequest
     */
    'description'?: string;
    /**
     * The list of tags
     * @type {Array<string>}
     * @memberof WorkspaceUpdateRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {WorkspaceSolution}
     * @memberof WorkspaceUpdateRequest
     */
    'solution'?: WorkspaceSolution;
    /**
     * 
     * @type {WorkspaceWebApp}
     * @memberof WorkspaceUpdateRequest
     */
    'webApp'?: WorkspaceWebApp;
    /**
     * Activate the copy of dataset on scenario creation
     * @type {boolean}
     * @memberof WorkspaceUpdateRequest
     */
    'datasetCopy'?: boolean;
}
/**
 * A Workspace Web Application
 * @export
 * @interface WorkspaceWebApp
 */
export interface WorkspaceWebApp {
    /**
     * The Workspace Web Application URL
     * @type {string}
     * @memberof WorkspaceWebApp
     */
    'url': string;
    /**
     * A map of iframeKey/iframeURL
     * @type {{ [key: string]: any; }}
     * @memberof WorkspaceWebApp
     */
    'iframes'?: { [key: string]: any; };
    /**
     * free form options for Web Application
     * @type {{ [key: string]: any; }}
     * @memberof WorkspaceWebApp
     */
    'options'?: { [key: string]: any; };
}

/**
 * DatasetApi - axios parameter creator
 * @export
 */
export const DatasetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {DatasetCreateRequest} datasetCreateRequest 
         * @param {Array<File>} [files] Notes:   - Each parts defined in dataset should have a file defined in this list   - Please ensure that upload files order match with data parts list defined     - First file uploaded will match with first dataset parts and so on 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset: async (organizationId: string, workspaceId: string, datasetCreateRequest: DatasetCreateRequest, files?: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createDataset', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createDataset', 'workspaceId', workspaceId)
            // verify required parameter 'datasetCreateRequest' is not null or undefined
            assertParamExists('createDataset', 'datasetCreateRequest', datasetCreateRequest)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
            if (datasetCreateRequest !== undefined) { 
                localVarFormParams.append('datasetCreateRequest', new Blob([JSON.stringify(datasetCreateRequest)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a control access to the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatasetAccessControl: async (organizationId: string, workspaceId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createDatasetAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('createDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'datasetAccessControl' is not null or undefined
            assertParamExists('createDatasetAccessControl', 'datasetAccessControl', datasetAccessControl)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a data part of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {File} file Data file to upload
         * @param {DatasetPartCreateRequest} datasetPartCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatasetPart: async (organizationId: string, workspaceId: string, datasetId: string, file: File, datasetPartCreateRequest: DatasetPartCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createDatasetPart', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createDatasetPart', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('createDatasetPart', 'datasetId', datasetId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createDatasetPart', 'file', file)
            // verify required parameter 'datasetPartCreateRequest' is not null or undefined
            assertParamExists('createDatasetPart', 'datasetPartCreateRequest', datasetPartCreateRequest)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/parts`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (datasetPartCreateRequest !== undefined) { 
                localVarFormParams.append('datasetPartCreateRequest', new Blob([JSON.stringify(datasetPartCreateRequest)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a dataset
         * @summary Delete a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset: async (organizationId: string, workspaceId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteDataset', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteDataset', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteDataset', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatasetAccessControl: async (organizationId: string, workspaceId: string, datasetId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteDatasetAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('deleteDatasetAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a dataset part
         * @summary Delete a Dataset part
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatasetPart: async (organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteDatasetPart', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteDatasetPart', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('deleteDatasetPart', 'datasetId', datasetId)
            // verify required parameter 'datasetPartId' is not null or undefined
            assertParamExists('deleteDatasetPart', 'datasetPartId', datasetPartId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/parts/{dataset_part_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"dataset_part_id"}}`, encodeURIComponent(String(datasetPartId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download data from a dataset part
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDatasetPart: async (organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('downloadDatasetPart', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('downloadDatasetPart', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('downloadDatasetPart', 'datasetId', datasetId)
            // verify required parameter 'datasetPartId' is not null or undefined
            assertParamExists('downloadDatasetPart', 'datasetPartId', datasetPartId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/parts/{dataset_part_id}/download`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"dataset_part_id"}}`, encodeURIComponent(String(datasetPartId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a dataset
         * @summary Retrieve a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataset: async (organizationId: string, workspaceId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDataset', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getDataset', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDataset', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetAccessControl: async (organizationId: string, workspaceId: string, datasetId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getDatasetAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getDatasetAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a data part of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetPart: async (organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getDatasetPart', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getDatasetPart', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('getDatasetPart', 'datasetId', datasetId)
            // verify required parameter 'datasetPartId' is not null or undefined
            assertParamExists('getDatasetPart', 'datasetPartId', datasetPartId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/parts/{dataset_part_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"dataset_part_id"}}`, encodeURIComponent(String(datasetPartId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all dataset parts of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatasetParts: async (organizationId: string, workspaceId: string, datasetId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listDatasetParts', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listDatasetParts', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('listDatasetParts', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/parts`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Dataset security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatasetSecurityUsers: async (organizationId: string, workspaceId: string, datasetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listDatasetSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listDatasetSecurityUsers', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('listDatasetSecurityUsers', 'datasetId', datasetId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all datasets
         * @summary Retrieve a list of defined Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatasets: async (organizationId: string, workspaceId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listDatasets', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listDatasets', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get data of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {Array<string>} [filters] Property names that should be part of the response data. You can specify a property name like:  - id  - stock  - quantity  - ... 
         * @param {Array<string>} [sums] Property names to sum by
         * @param {Array<string>} [counts] Property names to count by
         * @param {number} [offset] The query offset
         * @param {number} [limit] The query limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryData: async (organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, filters?: Array<string>, sums?: Array<string>, counts?: Array<string>, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('queryData', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('queryData', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('queryData', 'datasetId', datasetId)
            // verify required parameter 'datasetPartId' is not null or undefined
            assertParamExists('queryData', 'datasetPartId', datasetPartId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/parts/{dataset_part_id}/query`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"dataset_part_id"}}`, encodeURIComponent(String(datasetPartId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (filters) {
                localVarQueryParameter['filters'] = filters;
            }

            if (sums) {
                localVarQueryParameter['sums'] = sums;
            }

            if (counts) {
                localVarQueryParameter['counts'] = counts;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace existing dataset parts of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {File} file Data file to upload
         * @param {DatasetPartUpdateRequest} [datasetPartUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceDatasetPart: async (organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, file: File, datasetPartUpdateRequest?: DatasetPartUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('replaceDatasetPart', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('replaceDatasetPart', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('replaceDatasetPart', 'datasetId', datasetId)
            // verify required parameter 'datasetPartId' is not null or undefined
            assertParamExists('replaceDatasetPart', 'datasetPartId', datasetPartId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('replaceDatasetPart', 'file', file)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/parts/{dataset_part_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"dataset_part_id"}}`, encodeURIComponent(String(datasetPartId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (datasetPartUpdateRequest !== undefined) { 
                localVarFormParams.append('datasetPartUpdateRequest', new Blob([JSON.stringify(datasetPartUpdateRequest)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Dataset parts by tags
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<string>} requestBody the Dataset parts search parameters
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDatasetParts: async (organizationId: string, workspaceId: string, datasetId: string, requestBody: Array<string>, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('searchDatasetParts', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchDatasetParts', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('searchDatasetParts', 'datasetId', datasetId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('searchDatasetParts', 'requestBody', requestBody)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/parts/search`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search Datasets by tags
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Array<string>} requestBody the Dataset search parameters
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDatasets: async (organizationId: string, workspaceId: string, requestBody: Array<string>, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('searchDatasets', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchDatasets', 'workspaceId', workspaceId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('searchDatasets', 'requestBody', requestBody)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/search`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a dataset
         * @summary Update a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetUpdateRequest} datasetUpdateRequest 
         * @param {Array<File>} [files] Notes:   - Each parts defined in dataset should have a file defined in this list   - Please ensure that upload files order match with data parts list defined     - First file uploaded will match with first dataset parts and so on 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset: async (organizationId: string, workspaceId: string, datasetId: string, datasetUpdateRequest: DatasetUpdateRequest, files?: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateDataset', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateDataset', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateDataset', 'datasetId', datasetId)
            // verify required parameter 'datasetUpdateRequest' is not null or undefined
            assertParamExists('updateDataset', 'datasetUpdateRequest', datasetUpdateRequest)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
            if (datasetUpdateRequest !== undefined) { 
                localVarFormParams.append('datasetUpdateRequest', new Blob([JSON.stringify(datasetUpdateRequest)], { type: "application/json", }));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {DatasetRole} datasetRole The new Dataset Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatasetAccessControl: async (organizationId: string, workspaceId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'datasetId', datasetId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'identityId', identityId)
            // verify required parameter 'datasetRole' is not null or undefined
            assertParamExists('updateDatasetAccessControl', 'datasetRole', datasetRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Dataset default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatasetDefaultSecurity: async (organizationId: string, workspaceId: string, datasetId: string, datasetRole: DatasetRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateDatasetDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateDatasetDefaultSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateDatasetDefaultSecurity', 'datasetId', datasetId)
            // verify required parameter 'datasetRole' is not null or undefined
            assertParamExists('updateDatasetDefaultSecurity', 'datasetRole', datasetRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update existing dataset parts information of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {DatasetPartUpdateRequest} datasetPartUpdateRequest Dataset part information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatasetPart: async (organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, datasetPartUpdateRequest: DatasetPartUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateDatasetPart', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateDatasetPart', 'workspaceId', workspaceId)
            // verify required parameter 'datasetId' is not null or undefined
            assertParamExists('updateDatasetPart', 'datasetId', datasetId)
            // verify required parameter 'datasetPartId' is not null or undefined
            assertParamExists('updateDatasetPart', 'datasetPartId', datasetPartId)
            // verify required parameter 'datasetPartUpdateRequest' is not null or undefined
            assertParamExists('updateDatasetPart', 'datasetPartUpdateRequest', datasetPartUpdateRequest)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/datasets/{dataset_id}/parts/{dataset_part_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"dataset_id"}}`, encodeURIComponent(String(datasetId)))
                .replace(`{${"dataset_part_id"}}`, encodeURIComponent(String(datasetPartId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(datasetPartUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetApi - functional programming interface
 * @export
 */
export const DatasetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {DatasetCreateRequest} datasetCreateRequest 
         * @param {Array<File>} [files] Notes:   - Each parts defined in dataset should have a file defined in this list   - Please ensure that upload files order match with data parts list defined     - First file uploaded will match with first dataset parts and so on 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataset(organizationId: string, workspaceId: string, datasetCreateRequest: DatasetCreateRequest, files?: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataset(organizationId, workspaceId, datasetCreateRequest, files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a control access to the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDatasetAccessControl(organizationId: string, workspaceId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDatasetAccessControl(organizationId, workspaceId, datasetId, datasetAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a data part of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {File} file Data file to upload
         * @param {DatasetPartCreateRequest} datasetPartCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDatasetPart(organizationId: string, workspaceId: string, datasetId: string, file: File, datasetPartCreateRequest: DatasetPartCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetPart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDatasetPart(organizationId, workspaceId, datasetId, file, datasetPartCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createDatasetPart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a dataset
         * @summary Delete a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataset(organizationId, workspaceId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.deleteDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDatasetAccessControl(organizationId: string, workspaceId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDatasetAccessControl(organizationId, workspaceId, datasetId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.deleteDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a dataset part
         * @summary Delete a Dataset part
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.deleteDatasetPart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download data from a dataset part
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.downloadDatasetPart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a dataset
         * @summary Retrieve a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataset(organizationId, workspaceId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetAccessControl(organizationId: string, workspaceId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetAccessControl(organizationId, workspaceId, datasetId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a data part of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetPart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.getDatasetPart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve all dataset parts of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatasetParts(organizationId: string, workspaceId: string, datasetId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DatasetPart>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatasetParts(organizationId, workspaceId, datasetId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.listDatasetParts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Dataset security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatasetSecurityUsers(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatasetSecurityUsers(organizationId, workspaceId, datasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.listDatasetSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all datasets
         * @summary Retrieve a list of defined Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDatasets(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDatasets(organizationId, workspaceId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.listDatasets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get data of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {Array<string>} [filters] Property names that should be part of the response data. You can specify a property name like:  - id  - stock  - quantity  - ... 
         * @param {Array<string>} [sums] Property names to sum by
         * @param {Array<string>} [counts] Property names to count by
         * @param {number} [offset] The query offset
         * @param {number} [limit] The query limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryData(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, filters?: Array<string>, sums?: Array<string>, counts?: Array<string>, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryData(organizationId, workspaceId, datasetId, datasetPartId, filters, sums, counts, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.queryData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Replace existing dataset parts of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {File} file Data file to upload
         * @param {DatasetPartUpdateRequest} [datasetPartUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, file: File, datasetPartUpdateRequest?: DatasetPartUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetPart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, file, datasetPartUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.replaceDatasetPart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Dataset parts by tags
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<string>} requestBody the Dataset parts search parameters
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDatasetParts(organizationId: string, workspaceId: string, datasetId: string, requestBody: Array<string>, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DatasetPart>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDatasetParts(organizationId, workspaceId, datasetId, requestBody, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.searchDatasetParts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search Datasets by tags
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Array<string>} requestBody the Dataset search parameters
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDatasets(organizationId: string, workspaceId: string, requestBody: Array<string>, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Dataset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDatasets(organizationId, workspaceId, requestBody, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.searchDatasets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a dataset
         * @summary Update a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetUpdateRequest} datasetUpdateRequest 
         * @param {Array<File>} [files] Notes:   - Each parts defined in dataset should have a file defined in this list   - Please ensure that upload files order match with data parts list defined     - First file uploaded will match with first dataset parts and so on 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataset(organizationId: string, workspaceId: string, datasetId: string, datasetUpdateRequest: DatasetUpdateRequest, files?: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Dataset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataset(organizationId, workspaceId, datasetId, datasetUpdateRequest, files, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateDataset']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {DatasetRole} datasetRole The new Dataset Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDatasetAccessControl(organizationId: string, workspaceId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDatasetAccessControl(organizationId, workspaceId, datasetId, identityId, datasetRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateDatasetAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Dataset default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDatasetDefaultSecurity(organizationId: string, workspaceId: string, datasetId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDatasetDefaultSecurity(organizationId, workspaceId, datasetId, datasetRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateDatasetDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update existing dataset parts information of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {DatasetPartUpdateRequest} datasetPartUpdateRequest Dataset part information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, datasetPartUpdateRequest: DatasetPartUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatasetPart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, datasetPartUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.updateDatasetPart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatasetApi - factory interface
 * @export
 */
export const DatasetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {DatasetCreateRequest} datasetCreateRequest 
         * @param {Array<File>} [files] Notes:   - Each parts defined in dataset should have a file defined in this list   - Please ensure that upload files order match with data parts list defined     - First file uploaded will match with first dataset parts and so on 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataset(organizationId: string, workspaceId: string, datasetCreateRequest: DatasetCreateRequest, files?: Array<File>, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.createDataset(organizationId, workspaceId, datasetCreateRequest, files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a control access to the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatasetAccessControl(organizationId: string, workspaceId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<DatasetAccessControl> {
            return localVarFp.createDatasetAccessControl(organizationId, workspaceId, datasetId, datasetAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a data part of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {File} file Data file to upload
         * @param {DatasetPartCreateRequest} datasetPartCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDatasetPart(organizationId: string, workspaceId: string, datasetId: string, file: File, datasetPartCreateRequest: DatasetPartCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DatasetPart> {
            return localVarFp.createDatasetPart(organizationId, workspaceId, datasetId, file, datasetPartCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a dataset
         * @summary Delete a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDataset(organizationId, workspaceId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatasetAccessControl(organizationId: string, workspaceId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDatasetAccessControl(organizationId, workspaceId, datasetId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a dataset part
         * @summary Delete a Dataset part
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download data from a dataset part
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a dataset
         * @summary Retrieve a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.getDataset(organizationId, workspaceId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetAccessControl(organizationId: string, workspaceId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<DatasetAccessControl> {
            return localVarFp.getDatasetAccessControl(organizationId, workspaceId, datasetId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a data part of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, options?: RawAxiosRequestConfig): AxiosPromise<DatasetPart> {
            return localVarFp.getDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all dataset parts of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatasetParts(organizationId: string, workspaceId: string, datasetId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<DatasetPart>> {
            return localVarFp.listDatasetParts(organizationId, workspaceId, datasetId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Dataset security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatasetSecurityUsers(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listDatasetSecurityUsers(organizationId, workspaceId, datasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all datasets
         * @summary Retrieve a list of defined Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDatasets(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Dataset>> {
            return localVarFp.listDatasets(organizationId, workspaceId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get data of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {Array<string>} [filters] Property names that should be part of the response data. You can specify a property name like:  - id  - stock  - quantity  - ... 
         * @param {Array<string>} [sums] Property names to sum by
         * @param {Array<string>} [counts] Property names to count by
         * @param {number} [offset] The query offset
         * @param {number} [limit] The query limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryData(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, filters?: Array<string>, sums?: Array<string>, counts?: Array<string>, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.queryData(organizationId, workspaceId, datasetId, datasetPartId, filters, sums, counts, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replace existing dataset parts of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {File} file Data file to upload
         * @param {DatasetPartUpdateRequest} [datasetPartUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, file: File, datasetPartUpdateRequest?: DatasetPartUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DatasetPart> {
            return localVarFp.replaceDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, file, datasetPartUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Dataset parts by tags
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {Array<string>} requestBody the Dataset parts search parameters
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDatasetParts(organizationId: string, workspaceId: string, datasetId: string, requestBody: Array<string>, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<DatasetPart>> {
            return localVarFp.searchDatasetParts(organizationId, workspaceId, datasetId, requestBody, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search Datasets by tags
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {Array<string>} requestBody the Dataset search parameters
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDatasets(organizationId: string, workspaceId: string, requestBody: Array<string>, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Dataset>> {
            return localVarFp.searchDatasets(organizationId, workspaceId, requestBody, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a dataset
         * @summary Update a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetUpdateRequest} datasetUpdateRequest 
         * @param {Array<File>} [files] Notes:   - Each parts defined in dataset should have a file defined in this list   - Please ensure that upload files order match with data parts list defined     - First file uploaded will match with first dataset parts and so on 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataset(organizationId: string, workspaceId: string, datasetId: string, datasetUpdateRequest: DatasetUpdateRequest, files?: Array<File>, options?: RawAxiosRequestConfig): AxiosPromise<Dataset> {
            return localVarFp.updateDataset(organizationId, workspaceId, datasetId, datasetUpdateRequest, files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} identityId the User identifier
         * @param {DatasetRole} datasetRole The new Dataset Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatasetAccessControl(organizationId: string, workspaceId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig): AxiosPromise<DatasetAccessControl> {
            return localVarFp.updateDatasetAccessControl(organizationId, workspaceId, datasetId, identityId, datasetRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Dataset default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatasetDefaultSecurity(organizationId: string, workspaceId: string, datasetId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig): AxiosPromise<DatasetSecurity> {
            return localVarFp.updateDatasetDefaultSecurity(organizationId, workspaceId, datasetId, datasetRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update existing dataset parts information of a Dataset
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} datasetId the Dataset identifier
         * @param {string} datasetPartId the Dataset part identifier
         * @param {DatasetPartUpdateRequest} datasetPartUpdateRequest Dataset part information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, datasetPartUpdateRequest: DatasetPartUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DatasetPart> {
            return localVarFp.updateDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, datasetPartUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetApi - object-oriented interface
 * @export
 * @class DatasetApi
 * @extends {BaseAPI}
 */
export class DatasetApi extends BaseAPI {
    /**
     * 
     * @summary Create a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {DatasetCreateRequest} datasetCreateRequest 
     * @param {Array<File>} [files] Notes:   - Each parts defined in dataset should have a file defined in this list   - Please ensure that upload files order match with data parts list defined     - First file uploaded will match with first dataset parts and so on 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createDataset(organizationId: string, workspaceId: string, datasetCreateRequest: DatasetCreateRequest, files?: Array<File>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createDataset(organizationId, workspaceId, datasetCreateRequest, files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a control access to the Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {DatasetAccessControl} datasetAccessControl the new Dataset security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createDatasetAccessControl(organizationId: string, workspaceId: string, datasetId: string, datasetAccessControl: DatasetAccessControl, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createDatasetAccessControl(organizationId, workspaceId, datasetId, datasetAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a data part of a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {File} file Data file to upload
     * @param {DatasetPartCreateRequest} datasetPartCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createDatasetPart(organizationId: string, workspaceId: string, datasetId: string, file: File, datasetPartCreateRequest: DatasetPartCreateRequest, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createDatasetPart(organizationId, workspaceId, datasetId, file, datasetPartCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a dataset
     * @summary Delete a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteDataset(organizationId, workspaceId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteDatasetAccessControl(organizationId: string, workspaceId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteDatasetAccessControl(organizationId, workspaceId, datasetId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a dataset part
     * @summary Delete a Dataset part
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} datasetPartId the Dataset part identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download data from a dataset part
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} datasetPartId the Dataset part identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public downloadDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).downloadDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a dataset
     * @summary Retrieve a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDataset(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDataset(organizationId, workspaceId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetAccessControl(organizationId: string, workspaceId: string, datasetId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetAccessControl(organizationId, workspaceId, datasetId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a data part of a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} datasetPartId the Dataset part identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public getDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).getDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all dataset parts of a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {number} [page] Page number to query (first page is at index 0)
     * @param {number} [size] Amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public listDatasetParts(organizationId: string, workspaceId: string, datasetId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).listDatasetParts(organizationId, workspaceId, datasetId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Dataset security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public listDatasetSecurityUsers(organizationId: string, workspaceId: string, datasetId: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).listDatasetSecurityUsers(organizationId, workspaceId, datasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all datasets
     * @summary Retrieve a list of defined Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {number} [page] Page number to query (first page is at index 0)
     * @param {number} [size] Amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public listDatasets(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).listDatasets(organizationId, workspaceId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get data of a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} datasetPartId the Dataset part identifier
     * @param {Array<string>} [filters] Property names that should be part of the response data. You can specify a property name like:  - id  - stock  - quantity  - ... 
     * @param {Array<string>} [sums] Property names to sum by
     * @param {Array<string>} [counts] Property names to count by
     * @param {number} [offset] The query offset
     * @param {number} [limit] The query limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public queryData(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, filters?: Array<string>, sums?: Array<string>, counts?: Array<string>, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).queryData(organizationId, workspaceId, datasetId, datasetPartId, filters, sums, counts, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Replace existing dataset parts of a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} datasetPartId the Dataset part identifier
     * @param {File} file Data file to upload
     * @param {DatasetPartUpdateRequest} [datasetPartUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public replaceDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, file: File, datasetPartUpdateRequest?: DatasetPartUpdateRequest, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).replaceDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, file, datasetPartUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Dataset parts by tags
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {Array<string>} requestBody the Dataset parts search parameters
     * @param {number} [page] Page number to query (first page is at index 0)
     * @param {number} [size] Amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public searchDatasetParts(organizationId: string, workspaceId: string, datasetId: string, requestBody: Array<string>, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).searchDatasetParts(organizationId, workspaceId, datasetId, requestBody, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search Datasets by tags
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {Array<string>} requestBody the Dataset search parameters
     * @param {number} [page] Page number to query (first page is at index 0)
     * @param {number} [size] Amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public searchDatasets(organizationId: string, workspaceId: string, requestBody: Array<string>, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).searchDatasets(organizationId, workspaceId, requestBody, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a dataset
     * @summary Update a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {DatasetUpdateRequest} datasetUpdateRequest 
     * @param {Array<File>} [files] Notes:   - Each parts defined in dataset should have a file defined in this list   - Please ensure that upload files order match with data parts list defined     - First file uploaded will match with first dataset parts and so on 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateDataset(organizationId: string, workspaceId: string, datasetId: string, datasetUpdateRequest: DatasetUpdateRequest, files?: Array<File>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateDataset(organizationId, workspaceId, datasetId, datasetUpdateRequest, files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} identityId the User identifier
     * @param {DatasetRole} datasetRole The new Dataset Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateDatasetAccessControl(organizationId: string, workspaceId: string, datasetId: string, identityId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateDatasetAccessControl(organizationId, workspaceId, datasetId, identityId, datasetRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Dataset default security
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {DatasetRole} datasetRole This change the dataset default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the dataset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateDatasetDefaultSecurity(organizationId: string, workspaceId: string, datasetId: string, datasetRole: DatasetRole, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateDatasetDefaultSecurity(organizationId, workspaceId, datasetId, datasetRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update existing dataset parts information of a Dataset
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} datasetId the Dataset identifier
     * @param {string} datasetPartId the Dataset part identifier
     * @param {DatasetPartUpdateRequest} datasetPartUpdateRequest Dataset part information to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public updateDatasetPart(organizationId: string, workspaceId: string, datasetId: string, datasetPartId: string, datasetPartUpdateRequest: DatasetPartUpdateRequest, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).updateDatasetPart(organizationId, workspaceId, datasetId, datasetPartId, datasetPartUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetaApi - axios parameter creator
 * @export
 */
export const MetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get various information about the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        about: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/about`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetaApi - functional programming interface
 * @export
 */
export const MetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get various information about the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async about(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AboutInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.about(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaApi.about']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetaApi - factory interface
 * @export
 */
export const MetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetaApiFp(configuration)
    return {
        /**
         * 
         * @summary Get various information about the API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        about(options?: RawAxiosRequestConfig): AxiosPromise<AboutInfo> {
            return localVarFp.about(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetaApi - object-oriented interface
 * @export
 * @class MetaApi
 * @extends {BaseAPI}
 */
export class MetaApi extends BaseAPI {
    /**
     * 
     * @summary Get various information about the API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public about(options?: RawAxiosRequestConfig) {
        return MetaApiFp(this.configuration).about(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationApi - axios parameter creator
 * @export
 */
export const OrganizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new organization
         * @param {OrganizationCreateRequest} organizationCreateRequest The Organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (organizationCreateRequest: OrganizationCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationCreateRequest' is not null or undefined
            assertParamExists('createOrganization', 'organizationCreateRequest', organizationCreateRequest)
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId The Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl The new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationAccessControl: async (organizationId: string, organizationAccessControl: OrganizationAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'organizationAccessControl' is not null or undefined
            assertParamExists('createOrganizationAccessControl', 'organizationAccessControl', organizationAccessControl)
            const localVarPath = `/organizations/{organization_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an organization
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId The Organization identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationAccessControl: async (organizationId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('deleteOrganizationAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganization', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId The Organization identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAccessControl: async (organizationId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getOrganizationAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId The Organization identifier
         * @param {string} role The Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationPermissions: async (organizationId: string, role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationPermissions', 'organizationId', organizationId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('getOrganizationPermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurity: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getOrganizationSecurity', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationSecurityUsers: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listOrganizationSecurityUsers', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organizations/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId The Organization identifier
         * @param {OrganizationUpdateRequest} organizationUpdateRequest The new Organization details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (organizationId: string, organizationUpdateRequest: OrganizationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganization', 'organizationId', organizationId)
            // verify required parameter 'organizationUpdateRequest' is not null or undefined
            assertParamExists('updateOrganization', 'organizationUpdateRequest', organizationUpdateRequest)
            const localVarPath = `/organizations/{organization_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId The Organization identifier
         * @param {string} identityId The User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationAccessControl: async (organizationId: string, identityId: string, organizationRole: OrganizationRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'organizationId', organizationId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'identityId', identityId)
            // verify required parameter 'organizationRole' is not null or undefined
            assertParamExists('updateOrganizationAccessControl', 'organizationRole', organizationRole)
            const localVarPath = `/organizations/{organization_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the Organization default security
         * @param {string} organizationId The Organization identifier
         * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationDefaultSecurity: async (organizationId: string, organizationRole: OrganizationRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateOrganizationDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'organizationRole' is not null or undefined
            assertParamExists('updateOrganizationDefaultSecurity', 'organizationRole', organizationRole)
            const localVarPath = `/organizations/{organization_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(organizationRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new organization
         * @param {OrganizationCreateRequest} organizationCreateRequest The Organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(organizationCreateRequest: OrganizationCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganization(organizationCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.createOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId The Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl The new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganizationAccessControl(organizationId, organizationAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.createOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an organization
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganization(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganization(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.deleteOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId The Organization identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrganizationAccessControl(organizationId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.deleteOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganization(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganization(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId The Organization identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationAccessControl(organizationId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId The Organization identifier
         * @param {string} role The Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationPermissions(organizationId: string, role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationPermissions(organizationId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationSecurity(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationSecurity(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.getOrganizationSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizationSecurityUsers(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizationSecurityUsers(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.listOrganizationSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizations(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizations(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.listOrganizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ComponentRolePermissions>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.listPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId The Organization identifier
         * @param {OrganizationUpdateRequest} organizationUpdateRequest The new Organization details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(organizationId: string, organizationUpdateRequest: OrganizationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(organizationId, organizationUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId The Organization identifier
         * @param {string} identityId The User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationAccessControl(organizationId, identityId, organizationRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateOrganizationAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the Organization default security
         * @param {string} organizationId The Organization identifier
         * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrganizationSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganizationDefaultSecurity(organizationId, organizationRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationApi.updateOrganizationDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new organization
         * @param {OrganizationCreateRequest} organizationCreateRequest The Organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organizationCreateRequest: OrganizationCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.createOrganization(organizationCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a control access to the Organization
         * @param {string} organizationId The Organization identifier
         * @param {OrganizationAccessControl} organizationAccessControl The new Organization security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.createOrganizationAccessControl(organizationId, organizationAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an organization
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Organization
         * @param {string} organizationId The Organization identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOrganizationAccessControl(organizationId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of an Organization
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.getOrganization(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Organization
         * @param {string} organizationId The Organization identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.getOrganizationAccessControl(organizationId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization permissions by given role
         * @param {string} organizationId The Organization identifier
         * @param {string} role The Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationPermissions(organizationId: string, role: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getOrganizationPermissions(organizationId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization security information
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationSecurity(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationSecurity> {
            return localVarFp.getOrganizationSecurity(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Organization security users list
         * @param {string} organizationId The Organization identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizationSecurityUsers(organizationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listOrganizationSecurityUsers(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Organizations
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Organization>> {
            return localVarFp.listOrganizations(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all permissions per components
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPermissions(options?: RawAxiosRequestConfig): AxiosPromise<Array<ComponentRolePermissions>> {
            return localVarFp.listPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an Organization
         * @param {string} organizationId The Organization identifier
         * @param {OrganizationUpdateRequest} organizationUpdateRequest The new Organization details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organizationId: string, organizationUpdateRequest: OrganizationUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Organization> {
            return localVarFp.updateOrganization(organizationId, organizationUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for an Organization
         * @param {string} organizationId The Organization identifier
         * @param {string} identityId The User identifier
         * @param {OrganizationRole} organizationRole The new Organization Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationAccessControl> {
            return localVarFp.updateOrganizationAccessControl(organizationId, identityId, organizationRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the Organization default security
         * @param {string} organizationId The Organization identifier
         * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig): AxiosPromise<OrganizationSecurity> {
            return localVarFp.updateOrganizationDefaultSecurity(organizationId, organizationRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI {
    /**
     * 
     * @summary Create a new organization
     * @param {OrganizationCreateRequest} organizationCreateRequest The Organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrganization(organizationCreateRequest: OrganizationCreateRequest, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).createOrganization(organizationCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a control access to the Organization
     * @param {string} organizationId The Organization identifier
     * @param {OrganizationAccessControl} organizationAccessControl The new Organization security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrganizationAccessControl(organizationId: string, organizationAccessControl: OrganizationAccessControl, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).createOrganizationAccessControl(organizationId, organizationAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an organization
     * @param {string} organizationId The Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteOrganization(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).deleteOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Organization
     * @param {string} organizationId The Organization identifier
     * @param {string} identityId The User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public deleteOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).deleteOrganizationAccessControl(organizationId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of an Organization
     * @param {string} organizationId The Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganization(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganization(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Organization
     * @param {string} organizationId The Organization identifier
     * @param {string} identityId The User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationAccessControl(organizationId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationAccessControl(organizationId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization permissions by given role
     * @param {string} organizationId The Organization identifier
     * @param {string} role The Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationPermissions(organizationId: string, role: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationPermissions(organizationId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization security information
     * @param {string} organizationId The Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getOrganizationSecurity(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).getOrganizationSecurity(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Organization security users list
     * @param {string} organizationId The Organization identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public listOrganizationSecurityUsers(organizationId: string, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).listOrganizationSecurityUsers(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Organizations
     * @param {number} [page] Page number to query (first page is at index 0)
     * @param {number} [size] Amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public listOrganizations(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).listOrganizations(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all permissions per components
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public listPermissions(options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).listPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an Organization
     * @param {string} organizationId The Organization identifier
     * @param {OrganizationUpdateRequest} organizationUpdateRequest The new Organization details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganization(organizationId: string, organizationUpdateRequest: OrganizationUpdateRequest, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganization(organizationId, organizationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for an Organization
     * @param {string} organizationId The Organization identifier
     * @param {string} identityId The User identifier
     * @param {OrganizationRole} organizationRole The new Organization Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganizationAccessControl(organizationId: string, identityId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganizationAccessControl(organizationId, identityId, organizationRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the Organization default security
     * @param {string} organizationId The Organization identifier
     * @param {OrganizationRole} organizationRole This change the organization default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateOrganizationDefaultSecurity(organizationId: string, organizationRole: OrganizationRole, options?: RawAxiosRequestConfig) {
        return OrganizationApiFp(this.configuration).updateOrganizationDefaultSecurity(organizationId, organizationRole, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RunApi - axios parameter creator
 * @export
 */
export const RunApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('deleteRun', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('deleteRun', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRun', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRun', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the logs for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogs: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunLogs', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunLogs', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunLogs', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRunLogs', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/logs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the status for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatus: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunStatus', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunStatus', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunStatus', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('getRunStatus', 'runId', runId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/status`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get the list of Runs for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns: async (organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listRuns', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listRuns', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('listRuns', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary query the run data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {RunDataQuery} runDataQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryRunData: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('queryRunData', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('queryRunData', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('queryRunData', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('queryRunData', 'runId', runId)
            // verify required parameter 'runDataQuery' is not null or undefined
            assertParamExists('queryRunData', 'runDataQuery', runDataQuery)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/data/query`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runDataQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send data associated to a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRunData: async (organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('sendRunData', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('sendRunData', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('sendRunData', 'runnerId', runnerId)
            // verify required parameter 'runId' is not null or undefined
            assertParamExists('sendRunData', 'runId', runId)
            // verify required parameter 'sendRunDataRequest' is not null or undefined
            assertParamExists('sendRunData', 'sendRunDataRequest', sendRunDataRequest)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/runs/{run_id}/data/send`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"run_id"}}`, encodeURIComponent(String(runId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendRunDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunApi - functional programming interface
 * @export
 */
export const RunApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRun(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.deleteRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Run>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRun(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.getRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the logs for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunLogs(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunLogs(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.getRunLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the status for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunStatus(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunStatus(organizationId, workspaceId, runnerId, runId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.getRunStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary get the list of Runs for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRuns(organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Run>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRuns(organizationId, workspaceId, runnerId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.listRuns']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary query the run data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {RunDataQuery} runDataQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queryRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.queryRunData(organizationId, workspaceId, runnerId, runId, runDataQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.queryRunData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send data associated to a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendRunData(organizationId, workspaceId, runnerId, runId, sendRunDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunApi.sendRunData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RunApi - factory interface
 * @export
 */
export const RunApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): AxiosPromise<Run> {
            return localVarFp.getRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the logs for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunLogs(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getRunLogs(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the status for the Run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunStatus(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunStatus> {
            return localVarFp.getRunStatus(organizationId, workspaceId, runnerId, runId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get the list of Runs for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRuns(organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Run>> {
            return localVarFp.listRuns(organizationId, workspaceId, runnerId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary query the run data
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {RunDataQuery} runDataQuery the query to run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options?: RawAxiosRequestConfig): AxiosPromise<QueryResult> {
            return localVarFp.queryRunData(organizationId, workspaceId, runnerId, runId, runDataQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send data associated to a run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} runId the Run identifier
         * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunData> {
            return localVarFp.sendRunData(organizationId, workspaceId, runnerId, runId, sendRunDataRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunApi - object-oriented interface
 * @export
 * @class RunApi
 * @extends {BaseAPI}
 */
export class RunApi extends BaseAPI {
    /**
     * 
     * @summary Delete a run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public deleteRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).deleteRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public getRun(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).getRun(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the logs for the Run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public getRunLogs(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).getRunLogs(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the status for the Run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public getRunStatus(organizationId: string, workspaceId: string, runnerId: string, runId: string, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).getRunStatus(organizationId, workspaceId, runnerId, runId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get the list of Runs for the Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public listRuns(organizationId: string, workspaceId: string, runnerId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).listRuns(organizationId, workspaceId, runnerId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary query the run data
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {RunDataQuery} runDataQuery the query to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public queryRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, runDataQuery: RunDataQuery, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).queryRunData(organizationId, workspaceId, runnerId, runId, runDataQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send data associated to a run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} runId the Run identifier
     * @param {SendRunDataRequest} sendRunDataRequest Custom data to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public sendRunData(organizationId: string, workspaceId: string, runnerId: string, runId: string, sendRunDataRequest: SendRunDataRequest, options?: RawAxiosRequestConfig) {
        return RunApiFp(this.configuration).sendRunData(organizationId, workspaceId, runnerId, runId, sendRunDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RunnerApi - axios parameter creator
 * @export
 */
export const RunnerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {RunnerCreateRequest} runnerCreateRequest the Runner to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunner: async (organizationId: string, workspaceId: string, runnerCreateRequest: RunnerCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runnerCreateRequest' is not null or undefined
            assertParamExists('createRunner', 'runnerCreateRequest', runnerCreateRequest)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a control access to the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('createRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'runnerAccessControl' is not null or undefined
            assertParamExists('createRunnerAccessControl', 'runnerAccessControl', runnerAccessControl)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunner: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('deleteRunner', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('deleteRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('deleteRunnerAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunner: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunner', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getRunnerAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Runner security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerSecurity: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunnerSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getRunnerSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('getRunnerSecurity', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Runner permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunnerPermissions: async (organizationId: string, workspaceId: string, runnerId: string, role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listRunnerPermissions', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listRunnerPermissions', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('listRunnerPermissions', 'runnerId', runnerId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('listRunnerPermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Runner security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunnerSecurityUsers: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listRunnerSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listRunnerSecurityUsers', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('listRunnerSecurityUsers', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Runners
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunners: async (organizationId: string, workspaceId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listRunners', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listRunners', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start a run with runner parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRun: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('startRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('startRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('startRun', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/start`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop the last run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun: async (organizationId: string, workspaceId: string, runnerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('stopRun', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('stopRun', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('stopRun', 'runnerId', runnerId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/stop`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerUpdateRequest} runnerUpdateRequest the new Runner details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunner: async (organizationId: string, workspaceId: string, runnerId: string, runnerUpdateRequest: RunnerUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateRunner', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateRunner', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('updateRunner', 'runnerId', runnerId)
            // verify required parameter 'runnerUpdateRequest' is not null or undefined
            assertParamExists('updateRunner', 'runnerUpdateRequest', runnerUpdateRequest)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {RunnerRole} runnerRole The new Runner Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunnerAccessControl: async (organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'runnerId', runnerId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'identityId', identityId)
            // verify required parameter 'runnerRole' is not null or undefined
            assertParamExists('updateRunnerAccessControl', 'runnerRole', runnerRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the Runner default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunnerDefaultSecurity: async (organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateRunnerDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateRunnerDefaultSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'runnerId' is not null or undefined
            assertParamExists('updateRunnerDefaultSecurity', 'runnerId', runnerId)
            // verify required parameter 'runnerRole' is not null or undefined
            assertParamExists('updateRunnerDefaultSecurity', 'runnerRole', runnerRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/runners/{runner_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"runner_id"}}`, encodeURIComponent(String(runnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runnerRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunnerApi - functional programming interface
 * @export
 */
export const RunnerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RunnerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {RunnerCreateRequest} runnerCreateRequest the Runner to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRunner(organizationId: string, workspaceId: string, runnerCreateRequest: RunnerCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Runner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRunner(organizationId, workspaceId, runnerCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.createRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a control access to the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRunnerAccessControl(organizationId, workspaceId, runnerId, runnerAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.createRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRunner(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.deleteRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.deleteRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Runner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunner(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Runner security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunnerSecurity(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunnerSecurity(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.getRunnerSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Runner permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRunnerPermissions(organizationId: string, workspaceId: string, runnerId: string, role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRunnerPermissions(organizationId, workspaceId, runnerId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.listRunnerPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Runner security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRunnerSecurityUsers(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRunnerSecurityUsers(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.listRunnerSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Runners
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRunners(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Runner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRunners(organizationId, workspaceId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.listRunners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Start a run with runner parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatedRun>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startRun(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.startRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stop the last run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopRun(organizationId, workspaceId, runnerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.stopRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerUpdateRequest} runnerUpdateRequest the new Runner details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRunner(organizationId: string, workspaceId: string, runnerId: string, runnerUpdateRequest: RunnerUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Runner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRunner(organizationId, workspaceId, runnerId, runnerUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.updateRunner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {RunnerRole} runnerRole The new Runner Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, runnerRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.updateRunnerAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the Runner default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRunnerDefaultSecurity(organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunnerSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRunnerDefaultSecurity(organizationId, workspaceId, runnerId, runnerRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RunnerApi.updateRunnerDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RunnerApi - factory interface
 * @export
 */
export const RunnerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RunnerApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {RunnerCreateRequest} runnerCreateRequest the Runner to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunner(organizationId: string, workspaceId: string, runnerCreateRequest: RunnerCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Runner> {
            return localVarFp.createRunner(organizationId, workspaceId, runnerCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a control access to the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<RunnerAccessControl> {
            return localVarFp.createRunnerAccessControl(organizationId, workspaceId, runnerId, runnerAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRunner(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<Runner> {
            return localVarFp.getRunner(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunnerAccessControl> {
            return localVarFp.getRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Runner security information
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunnerSecurity(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunnerSecurity> {
            return localVarFp.getRunnerSecurity(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Runner permission by given role
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} role the Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunnerPermissions(organizationId: string, workspaceId: string, runnerId: string, role: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listRunnerPermissions(organizationId, workspaceId, runnerId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Runner security users list
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunnerSecurityUsers(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listRunnerSecurityUsers(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Runners
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunners(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Runner>> {
            return localVarFp.listRunners(organizationId, workspaceId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start a run with runner parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<CreatedRun> {
            return localVarFp.startRun(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop the last run
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.stopRun(organizationId, workspaceId, runnerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerUpdateRequest} runnerUpdateRequest the new Runner details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunner(organizationId: string, workspaceId: string, runnerId: string, runnerUpdateRequest: RunnerUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Runner> {
            return localVarFp.updateRunner(organizationId, workspaceId, runnerId, runnerUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Runner
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {string} identityId the User identifier
         * @param {RunnerRole} runnerRole The new Runner Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig): AxiosPromise<RunnerAccessControl> {
            return localVarFp.updateRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, runnerRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the Runner default security
         * @param {string} organizationId the Organization identifier
         * @param {string} workspaceId the Workspace identifier
         * @param {string} runnerId the Runner identifier
         * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRunnerDefaultSecurity(organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig): AxiosPromise<RunnerSecurity> {
            return localVarFp.updateRunnerDefaultSecurity(organizationId, workspaceId, runnerId, runnerRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunnerApi - object-oriented interface
 * @export
 * @class RunnerApi
 * @extends {BaseAPI}
 */
export class RunnerApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {RunnerCreateRequest} runnerCreateRequest the Runner to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public createRunner(organizationId: string, workspaceId: string, runnerCreateRequest: RunnerCreateRequest, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).createRunner(organizationId, workspaceId, runnerCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a control access to the Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {RunnerAccessControl} runnerAccessControl the new Runner security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public createRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, runnerAccessControl: RunnerAccessControl, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).createRunnerAccessControl(organizationId, workspaceId, runnerId, runnerAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public deleteRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).deleteRunner(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public deleteRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).deleteRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunner(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunner(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} identityId the User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Runner security information
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public getRunnerSecurity(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).getRunnerSecurity(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Runner permission by given role
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} role the Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public listRunnerPermissions(organizationId: string, workspaceId: string, runnerId: string, role: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).listRunnerPermissions(organizationId, workspaceId, runnerId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Runner security users list
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public listRunnerSecurityUsers(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).listRunnerSecurityUsers(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Runners
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {number} [page] Page number to query (first page is at index 0)
     * @param {number} [size] Amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public listRunners(organizationId: string, workspaceId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).listRunners(organizationId, workspaceId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start a run with runner parameters
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public startRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).startRun(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop the last run
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public stopRun(organizationId: string, workspaceId: string, runnerId: string, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).stopRun(organizationId, workspaceId, runnerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {RunnerUpdateRequest} runnerUpdateRequest the new Runner details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public updateRunner(organizationId: string, workspaceId: string, runnerId: string, runnerUpdateRequest: RunnerUpdateRequest, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).updateRunner(organizationId, workspaceId, runnerId, runnerUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Runner
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {string} identityId the User identifier
     * @param {RunnerRole} runnerRole The new Runner Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public updateRunnerAccessControl(organizationId: string, workspaceId: string, runnerId: string, identityId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).updateRunnerAccessControl(organizationId, workspaceId, runnerId, identityId, runnerRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the Runner default security
     * @param {string} organizationId the Organization identifier
     * @param {string} workspaceId the Workspace identifier
     * @param {string} runnerId the Runner identifier
     * @param {RunnerRole} runnerRole This change the runner default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the runner.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunnerApi
     */
    public updateRunnerDefaultSecurity(organizationId: string, workspaceId: string, runnerId: string, runnerRole: RunnerRole, options?: RawAxiosRequestConfig) {
        return RunnerApiFp(this.configuration).updateRunnerDefaultSecurity(organizationId, workspaceId, runnerId, runnerRole, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SolutionApi - axios parameter creator
 * @export
 */
export const SolutionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new solution
         * @param {string} organizationId the Organization identifier
         * @param {SolutionCreateRequest} solutionCreateRequest The Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolution: async (organizationId: string, solutionCreateRequest: SolutionCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionCreateRequest' is not null or undefined
            assertParamExists('createSolution', 'solutionCreateRequest', solutionCreateRequest)
            const localVarPath = `/organizations/{organization_id}/solutions`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionAccessControl} solutionAccessControl Access control to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolutionAccessControl: async (organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('createSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'solutionAccessControl' is not null or undefined
            assertParamExists('createSolutionAccessControl', 'solutionAccessControl', solutionAccessControl)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create solution parameter for a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {RunTemplateParameterCreateRequest} runTemplateParameterCreateRequest Parameter to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolutionParameter: async (organizationId: string, solutionId: string, runTemplateParameterCreateRequest: RunTemplateParameterCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSolutionParameter', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('createSolutionParameter', 'solutionId', solutionId)
            // verify required parameter 'runTemplateParameterCreateRequest' is not null or undefined
            assertParamExists('createSolutionParameter', 'runTemplateParameterCreateRequest', runTemplateParameterCreateRequest)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateParameterCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a solution parameter group
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {RunTemplateParameterGroupCreateRequest} runTemplateParameterGroupCreateRequest Parameter group to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolutionParameterGroup: async (organizationId: string, solutionId: string, runTemplateParameterGroupCreateRequest: RunTemplateParameterGroupCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSolutionParameterGroup', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('createSolutionParameterGroup', 'solutionId', solutionId)
            // verify required parameter 'runTemplateParameterGroupCreateRequest' is not null or undefined
            assertParamExists('createSolutionParameterGroup', 'runTemplateParameterGroupCreateRequest', runTemplateParameterGroupCreateRequest)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateParameterGroupCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a solution run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {RunTemplateCreateRequest} runTemplateCreateRequest Run template to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolutionRunTemplate: async (organizationId: string, solutionId: string, runTemplateCreateRequest: RunTemplateCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createSolutionRunTemplate', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('createSolutionRunTemplate', 'solutionId', solutionId)
            // verify required parameter 'runTemplateCreateRequest' is not null or undefined
            assertParamExists('createSolutionRunTemplate', 'runTemplateCreateRequest', runTemplateCreateRequest)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolution: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolution', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionAccessControl: async (organizationId: string, solutionId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('deleteSolutionAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete specific parameter from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterId The solution parameter identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionParameter: async (organizationId: string, solutionId: string, parameterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolutionParameter', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolutionParameter', 'solutionId', solutionId)
            // verify required parameter 'parameterId' is not null or undefined
            assertParamExists('deleteSolutionParameter', 'parameterId', parameterId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters/{parameter_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"parameter_id"}}`, encodeURIComponent(String(parameterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a parameter group from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterGroupId The parameter group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionParameterGroup: async (organizationId: string, solutionId: string, parameterGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolutionParameterGroup', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolutionParameterGroup', 'solutionId', solutionId)
            // verify required parameter 'parameterGroupId' is not null or undefined
            assertParamExists('deleteSolutionParameterGroup', 'parameterGroupId', parameterGroupId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups/{parameter_group_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"parameter_group_id"}}`, encodeURIComponent(String(parameterGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId The Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionRunTemplate: async (organizationId: string, solutionId: string, runTemplateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('deleteSolutionRunTemplate', 'runTemplateId', runTemplateId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates/{run_template_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a solution run templates
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId The Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunTemplate: async (organizationId: string, solutionId: string, runTemplateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getRunTemplate', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getRunTemplate', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('getRunTemplate', 'runTemplateId', runTemplateId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates/{run_template_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolution: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getSolution', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionAccessControl: async (organizationId: string, solutionId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getSolutionAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a solution parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterId The solution parameter identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionParameter: async (organizationId: string, solutionId: string, parameterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getSolutionParameter', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getSolutionParameter', 'solutionId', solutionId)
            // verify required parameter 'parameterId' is not null or undefined
            assertParamExists('getSolutionParameter', 'parameterId', parameterId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters/{parameter_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"parameter_id"}}`, encodeURIComponent(String(parameterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details of a solution parameter group
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterGroupId The parameter group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionParameterGroup: async (organizationId: string, solutionId: string, parameterGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getSolutionParameterGroup', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getSolutionParameterGroup', 'solutionId', solutionId)
            // verify required parameter 'parameterGroupId' is not null or undefined
            assertParamExists('getSolutionParameterGroup', 'parameterGroupId', parameterGroupId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups/{parameter_group_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"parameter_group_id"}}`, encodeURIComponent(String(parameterGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get solution security information
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionSecurity: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getSolutionSecurity', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('getSolutionSecurity', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all solution run templates
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunTemplates: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listRunTemplates', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('listRunTemplates', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all solution parameter groups
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSolutionParameterGroups: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listSolutionParameterGroups', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('listSolutionParameterGroups', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all solution parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSolutionParameters: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listSolutionParameters', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('listSolutionParameters', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List solution security users
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSolutionSecurityUsers: async (organizationId: string, solutionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listSolutionSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('listSolutionSecurityUsers', 'solutionId', solutionId)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSolutions: async (organizationId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listSolutions', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/solutions`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionUpdateRequest} solutionUpdateRequest The new Solution details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolution: async (organizationId: string, solutionId: string, solutionUpdateRequest: SolutionUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolution', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolution', 'solutionId', solutionId)
            // verify required parameter 'solutionUpdateRequest' is not null or undefined
            assertParamExists('updateSolution', 'solutionUpdateRequest', solutionUpdateRequest)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId The User identifier
         * @param {SolutionRole} solutionRole Access control updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionAccessControl: async (organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'solutionId', solutionId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'identityId', identityId)
            // verify required parameter 'solutionRole' is not null or undefined
            assertParamExists('updateSolutionAccessControl', 'solutionRole', solutionRole)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update solution default security
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionRole} solutionRole This changes the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionDefaultSecurity: async (organizationId: string, solutionId: string, solutionRole: SolutionRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionDefaultSecurity', 'solutionId', solutionId)
            // verify required parameter 'solutionRole' is not null or undefined
            assertParamExists('updateSolutionDefaultSecurity', 'solutionRole', solutionRole)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(solutionRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update solution parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterId The solution parameter identifier
         * @param {RunTemplateParameterUpdateRequest} runTemplateParameterUpdateRequest Parameter to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionParameter: async (organizationId: string, solutionId: string, parameterId: string, runTemplateParameterUpdateRequest: RunTemplateParameterUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionParameter', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionParameter', 'solutionId', solutionId)
            // verify required parameter 'parameterId' is not null or undefined
            assertParamExists('updateSolutionParameter', 'parameterId', parameterId)
            // verify required parameter 'runTemplateParameterUpdateRequest' is not null or undefined
            assertParamExists('updateSolutionParameter', 'runTemplateParameterUpdateRequest', runTemplateParameterUpdateRequest)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameters/{parameter_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"parameter_id"}}`, encodeURIComponent(String(parameterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateParameterUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a solution parameter group
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterGroupId The parameter group identifier
         * @param {RunTemplateParameterGroupUpdateRequest} runTemplateParameterGroupUpdateRequest Parameter groups to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionParameterGroup: async (organizationId: string, solutionId: string, parameterGroupId: string, runTemplateParameterGroupUpdateRequest: RunTemplateParameterGroupUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionParameterGroup', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionParameterGroup', 'solutionId', solutionId)
            // verify required parameter 'parameterGroupId' is not null or undefined
            assertParamExists('updateSolutionParameterGroup', 'parameterGroupId', parameterGroupId)
            // verify required parameter 'runTemplateParameterGroupUpdateRequest' is not null or undefined
            assertParamExists('updateSolutionParameterGroup', 'runTemplateParameterGroupUpdateRequest', runTemplateParameterGroupUpdateRequest)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/parameterGroups/{parameter_group_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"parameter_group_id"}}`, encodeURIComponent(String(parameterGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateParameterGroupUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a specific run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId The Run Template identifier
         * @param {RunTemplateUpdateRequest} runTemplateUpdateRequest Run template updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionRunTemplate: async (organizationId: string, solutionId: string, runTemplateId: string, runTemplateUpdateRequest: RunTemplateUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'organizationId', organizationId)
            // verify required parameter 'solutionId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'solutionId', solutionId)
            // verify required parameter 'runTemplateId' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'runTemplateId', runTemplateId)
            // verify required parameter 'runTemplateUpdateRequest' is not null or undefined
            assertParamExists('updateSolutionRunTemplate', 'runTemplateUpdateRequest', runTemplateUpdateRequest)
            const localVarPath = `/organizations/{organization_id}/solutions/{solution_id}/runTemplates/{run_template_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"solution_id"}}`, encodeURIComponent(String(solutionId)))
                .replace(`{${"run_template_id"}}`, encodeURIComponent(String(runTemplateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(runTemplateUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SolutionApi - functional programming interface
 * @export
 */
export const SolutionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SolutionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new solution
         * @param {string} organizationId the Organization identifier
         * @param {SolutionCreateRequest} solutionCreateRequest The Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSolution(organizationId: string, solutionCreateRequest: SolutionCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSolution(organizationId, solutionCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.createSolution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionAccessControl} solutionAccessControl Access control to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSolutionAccessControl(organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSolutionAccessControl(organizationId, solutionId, solutionAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.createSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create solution parameter for a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {RunTemplateParameterCreateRequest} runTemplateParameterCreateRequest Parameter to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSolutionParameter(organizationId: string, solutionId: string, runTemplateParameterCreateRequest: RunTemplateParameterCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunTemplateParameter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSolutionParameter(organizationId, solutionId, runTemplateParameterCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.createSolutionParameter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a solution parameter group
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {RunTemplateParameterGroupCreateRequest} runTemplateParameterGroupCreateRequest Parameter group to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSolutionParameterGroup(organizationId: string, solutionId: string, runTemplateParameterGroupCreateRequest: RunTemplateParameterGroupCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunTemplateParameterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSolutionParameterGroup(organizationId, solutionId, runTemplateParameterGroupCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.createSolutionParameterGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a solution run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {RunTemplateCreateRequest} runTemplateCreateRequest Run template to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateCreateRequest: RunTemplateCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSolutionRunTemplate(organizationId, solutionId, runTemplateCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.createSolutionRunTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolution(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolutionAccessControl(organizationId, solutionId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete specific parameter from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterId The solution parameter identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolutionParameter(organizationId: string, solutionId: string, parameterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolutionParameter(organizationId, solutionId, parameterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolutionParameter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a parameter group from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterGroupId The parameter group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolutionParameterGroup(organizationId: string, solutionId: string, parameterGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolutionParameterGroup(organizationId, solutionId, parameterGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolutionParameterGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId The Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.deleteSolutionRunTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a solution run templates
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId The Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRunTemplate(organizationId, solutionId, runTemplateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getRunTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolution(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getSolution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolutionAccessControl(organizationId, solutionId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a solution parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterId The solution parameter identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolutionParameter(organizationId: string, solutionId: string, parameterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunTemplateParameter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolutionParameter(organizationId, solutionId, parameterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getSolutionParameter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details of a solution parameter group
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterGroupId The parameter group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolutionParameterGroup(organizationId: string, solutionId: string, parameterGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunTemplateParameterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolutionParameterGroup(organizationId, solutionId, parameterGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getSolutionParameterGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get solution security information
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSolutionSecurity(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSolutionSecurity(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.getSolutionSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all solution run templates
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRunTemplates(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRunTemplates(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.listRunTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all solution parameter groups
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSolutionParameterGroups(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplateParameterGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSolutionParameterGroups(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.listSolutionParameterGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all solution parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSolutionParameters(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunTemplateParameter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSolutionParameters(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.listSolutionParameters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List solution security users
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSolutionSecurityUsers(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSolutionSecurityUsers(organizationId, solutionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.listSolutionSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSolutions(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Solution>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSolutions(organizationId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.listSolutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionUpdateRequest} solutionUpdateRequest The new Solution details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolution(organizationId: string, solutionId: string, solutionUpdateRequest: SolutionUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Solution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolution(organizationId, solutionId, solutionUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId The User identifier
         * @param {SolutionRole} solutionRole Access control updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionAccessControl(organizationId, solutionId, identityId, solutionRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update solution default security
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionRole} solutionRole This changes the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionDefaultSecurity(organizationId: string, solutionId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SolutionSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionDefaultSecurity(organizationId, solutionId, solutionRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update solution parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterId The solution parameter identifier
         * @param {RunTemplateParameterUpdateRequest} runTemplateParameterUpdateRequest Parameter to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionParameter(organizationId: string, solutionId: string, parameterId: string, runTemplateParameterUpdateRequest: RunTemplateParameterUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunTemplateParameter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionParameter(organizationId, solutionId, parameterId, runTemplateParameterUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionParameter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a solution parameter group
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterGroupId The parameter group identifier
         * @param {RunTemplateParameterGroupUpdateRequest} runTemplateParameterGroupUpdateRequest Parameter groups to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionParameterGroup(organizationId: string, solutionId: string, parameterGroupId: string, runTemplateParameterGroupUpdateRequest: RunTemplateParameterGroupUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunTemplateParameterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionParameterGroup(organizationId, solutionId, parameterGroupId, runTemplateParameterGroupUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionParameterGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a specific run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId The Run Template identifier
         * @param {RunTemplateUpdateRequest} runTemplateUpdateRequest Run template updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplateUpdateRequest: RunTemplateUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplateUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SolutionApi.updateSolutionRunTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SolutionApi - factory interface
 * @export
 */
export const SolutionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SolutionApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new solution
         * @param {string} organizationId the Organization identifier
         * @param {SolutionCreateRequest} solutionCreateRequest The Solution to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolution(organizationId: string, solutionCreateRequest: SolutionCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Solution> {
            return localVarFp.createSolution(organizationId, solutionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionAccessControl} solutionAccessControl Access control to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolutionAccessControl(organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<SolutionAccessControl> {
            return localVarFp.createSolutionAccessControl(organizationId, solutionId, solutionAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create solution parameter for a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {RunTemplateParameterCreateRequest} runTemplateParameterCreateRequest Parameter to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolutionParameter(organizationId: string, solutionId: string, runTemplateParameterCreateRequest: RunTemplateParameterCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunTemplateParameter> {
            return localVarFp.createSolutionParameter(organizationId, solutionId, runTemplateParameterCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a solution parameter group
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {RunTemplateParameterGroupCreateRequest} runTemplateParameterGroupCreateRequest Parameter group to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolutionParameterGroup(organizationId: string, solutionId: string, runTemplateParameterGroupCreateRequest: RunTemplateParameterGroupCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunTemplateParameterGroup> {
            return localVarFp.createSolutionParameterGroup(organizationId, solutionId, runTemplateParameterGroupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a solution run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {RunTemplateCreateRequest} runTemplateCreateRequest Run template to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateCreateRequest: RunTemplateCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunTemplate> {
            return localVarFp.createSolutionRunTemplate(organizationId, solutionId, runTemplateCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSolution(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete specific parameter from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterId The solution parameter identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionParameter(organizationId: string, solutionId: string, parameterId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSolutionParameter(organizationId, solutionId, parameterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a parameter group from the solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterGroupId The parameter group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionParameterGroup(organizationId: string, solutionId: string, parameterGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSolutionParameterGroup(organizationId, solutionId, parameterGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId The Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a solution run templates
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId The Run Template identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunTemplate> {
            return localVarFp.getRunTemplate(organizationId, solutionId, runTemplateId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Solution> {
            return localVarFp.getSolution(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<SolutionAccessControl> {
            return localVarFp.getSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a solution parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterId The solution parameter identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionParameter(organizationId: string, solutionId: string, parameterId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunTemplateParameter> {
            return localVarFp.getSolutionParameter(organizationId, solutionId, parameterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details of a solution parameter group
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterGroupId The parameter group identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionParameterGroup(organizationId: string, solutionId: string, parameterGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<RunTemplateParameterGroup> {
            return localVarFp.getSolutionParameterGroup(organizationId, solutionId, parameterGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get solution security information
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSolutionSecurity(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<SolutionSecurity> {
            return localVarFp.getSolutionSecurity(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all solution run templates
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRunTemplates(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunTemplate>> {
            return localVarFp.listRunTemplates(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all solution parameter groups
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSolutionParameterGroups(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunTemplateParameterGroup>> {
            return localVarFp.listSolutionParameterGroups(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all solution parameters
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSolutionParameters(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RunTemplateParameter>> {
            return localVarFp.listSolutionParameters(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List solution security users
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSolutionSecurityUsers(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listSolutionSecurityUsers(organizationId, solutionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Solutions
         * @param {string} organizationId the Organization identifier
         * @param {number} [page] Page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSolutions(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Solution>> {
            return localVarFp.listSolutions(organizationId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a solution
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionUpdateRequest} solutionUpdateRequest The new Solution details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolution(organizationId: string, solutionId: string, solutionUpdateRequest: SolutionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Solution> {
            return localVarFp.updateSolution(organizationId, solutionId, solutionUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update solution access control
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} identityId The User identifier
         * @param {SolutionRole} solutionRole Access control updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig): AxiosPromise<SolutionAccessControl> {
            return localVarFp.updateSolutionAccessControl(organizationId, solutionId, identityId, solutionRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update solution default security
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {SolutionRole} solutionRole This changes the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionDefaultSecurity(organizationId: string, solutionId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig): AxiosPromise<SolutionSecurity> {
            return localVarFp.updateSolutionDefaultSecurity(organizationId, solutionId, solutionRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update solution parameter
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterId The solution parameter identifier
         * @param {RunTemplateParameterUpdateRequest} runTemplateParameterUpdateRequest Parameter to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionParameter(organizationId: string, solutionId: string, parameterId: string, runTemplateParameterUpdateRequest: RunTemplateParameterUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunTemplateParameter> {
            return localVarFp.updateSolutionParameter(organizationId, solutionId, parameterId, runTemplateParameterUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a solution parameter group
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} parameterGroupId The parameter group identifier
         * @param {RunTemplateParameterGroupUpdateRequest} runTemplateParameterGroupUpdateRequest Parameter groups to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionParameterGroup(organizationId: string, solutionId: string, parameterGroupId: string, runTemplateParameterGroupUpdateRequest: RunTemplateParameterGroupUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunTemplateParameterGroup> {
            return localVarFp.updateSolutionParameterGroup(organizationId, solutionId, parameterGroupId, runTemplateParameterGroupUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a specific run template
         * @param {string} organizationId the Organization identifier
         * @param {string} solutionId the Solution identifier
         * @param {string} runTemplateId The Run Template identifier
         * @param {RunTemplateUpdateRequest} runTemplateUpdateRequest Run template updates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplateUpdateRequest: RunTemplateUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<RunTemplate> {
            return localVarFp.updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplateUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SolutionApi - object-oriented interface
 * @export
 * @class SolutionApi
 * @extends {BaseAPI}
 */
export class SolutionApi extends BaseAPI {
    /**
     * 
     * @summary Create a new solution
     * @param {string} organizationId the Organization identifier
     * @param {SolutionCreateRequest} solutionCreateRequest The Solution to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public createSolution(organizationId: string, solutionCreateRequest: SolutionCreateRequest, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).createSolution(organizationId, solutionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create solution access control
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {SolutionAccessControl} solutionAccessControl Access control to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public createSolutionAccessControl(organizationId: string, solutionId: string, solutionAccessControl: SolutionAccessControl, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).createSolutionAccessControl(organizationId, solutionId, solutionAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create solution parameter for a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {RunTemplateParameterCreateRequest} runTemplateParameterCreateRequest Parameter to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public createSolutionParameter(organizationId: string, solutionId: string, runTemplateParameterCreateRequest: RunTemplateParameterCreateRequest, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).createSolutionParameter(organizationId, solutionId, runTemplateParameterCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a solution parameter group
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {RunTemplateParameterGroupCreateRequest} runTemplateParameterGroupCreateRequest Parameter group to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public createSolutionParameterGroup(organizationId: string, solutionId: string, runTemplateParameterGroupCreateRequest: RunTemplateParameterGroupCreateRequest, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).createSolutionParameterGroup(organizationId, solutionId, runTemplateParameterGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a solution run template
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {RunTemplateCreateRequest} runTemplateCreateRequest Run template to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public createSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateCreateRequest: RunTemplateCreateRequest, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).createSolutionRunTemplate(organizationId, solutionId, runTemplateCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolution(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete solution access control
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} identityId The User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete specific parameter from the solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} parameterId The solution parameter identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolutionParameter(organizationId: string, solutionId: string, parameterId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolutionParameter(organizationId, solutionId, parameterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a parameter group from the solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} parameterGroupId The parameter group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolutionParameterGroup(organizationId: string, solutionId: string, parameterGroupId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolutionParameterGroup(organizationId, solutionId, parameterGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific run template
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId The Run Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public deleteSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).deleteSolutionRunTemplate(organizationId, solutionId, runTemplateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a solution run templates
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId The Run Template identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getRunTemplate(organizationId, solutionId, runTemplateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getSolution(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getSolution(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get solution access control
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} identityId The User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getSolutionAccessControl(organizationId, solutionId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a solution parameter
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} parameterId The solution parameter identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getSolutionParameter(organizationId: string, solutionId: string, parameterId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getSolutionParameter(organizationId, solutionId, parameterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details of a solution parameter group
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} parameterGroupId The parameter group identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getSolutionParameterGroup(organizationId: string, solutionId: string, parameterGroupId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getSolutionParameterGroup(organizationId, solutionId, parameterGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get solution security information
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public getSolutionSecurity(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).getSolutionSecurity(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all solution run templates
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public listRunTemplates(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).listRunTemplates(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all solution parameter groups
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public listSolutionParameterGroups(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).listSolutionParameterGroups(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all solution parameters
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public listSolutionParameters(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).listSolutionParameters(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List solution security users
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public listSolutionSecurityUsers(organizationId: string, solutionId: string, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).listSolutionSecurityUsers(organizationId, solutionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Solutions
     * @param {string} organizationId the Organization identifier
     * @param {number} [page] Page number to query (first page is at index 0)
     * @param {number} [size] Amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public listSolutions(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).listSolutions(organizationId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a solution
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {SolutionUpdateRequest} solutionUpdateRequest The new Solution details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolution(organizationId: string, solutionId: string, solutionUpdateRequest: SolutionUpdateRequest, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolution(organizationId, solutionId, solutionUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update solution access control
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} identityId The User identifier
     * @param {SolutionRole} solutionRole Access control updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionAccessControl(organizationId: string, solutionId: string, identityId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionAccessControl(organizationId, solutionId, identityId, solutionRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update solution default security
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {SolutionRole} solutionRole This changes the solution default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the solution.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionDefaultSecurity(organizationId: string, solutionId: string, solutionRole: SolutionRole, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionDefaultSecurity(organizationId, solutionId, solutionRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update solution parameter
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} parameterId The solution parameter identifier
     * @param {RunTemplateParameterUpdateRequest} runTemplateParameterUpdateRequest Parameter to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionParameter(organizationId: string, solutionId: string, parameterId: string, runTemplateParameterUpdateRequest: RunTemplateParameterUpdateRequest, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionParameter(organizationId, solutionId, parameterId, runTemplateParameterUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a solution parameter group
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} parameterGroupId The parameter group identifier
     * @param {RunTemplateParameterGroupUpdateRequest} runTemplateParameterGroupUpdateRequest Parameter groups to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionParameterGroup(organizationId: string, solutionId: string, parameterGroupId: string, runTemplateParameterGroupUpdateRequest: RunTemplateParameterGroupUpdateRequest, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionParameterGroup(organizationId, solutionId, parameterGroupId, runTemplateParameterGroupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a specific run template
     * @param {string} organizationId the Organization identifier
     * @param {string} solutionId the Solution identifier
     * @param {string} runTemplateId The Run Template identifier
     * @param {RunTemplateUpdateRequest} runTemplateUpdateRequest Run template updates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SolutionApi
     */
    public updateSolutionRunTemplate(organizationId: string, solutionId: string, runTemplateId: string, runTemplateUpdateRequest: RunTemplateUpdateRequest, options?: RawAxiosRequestConfig) {
        return SolutionApiFp(this.configuration).updateSolutionRunTemplate(organizationId, solutionId, runTemplateId, runTemplateUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WorkspaceApi - axios parameter creator
 * @export
 */
export const WorkspaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId The Organization identifier
         * @param {WorkspaceCreateRequest} workspaceCreateRequest The Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace: async (organizationId: string, workspaceCreateRequest: WorkspaceCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceCreateRequest' is not null or undefined
            assertParamExists('createWorkspace', 'workspaceCreateRequest', workspaceCreateRequest)
            const localVarPath = `/organizations/{organization_id}/workspaces`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl The new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceAccessControl: async (organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceAccessControl' is not null or undefined
            assertParamExists('createWorkspaceAccessControl', 'workspaceAccessControl', workspaceAccessControl)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceAccessControl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {File} file The file to upload
         * @param {boolean} [overwrite] Whether to overwrite an existing file
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceFile: async (organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('createWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createWorkspaceFile', 'file', file)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


            if (overwrite !== undefined) { 
                localVarFormParams.append('overwrite', String(overwrite) as any);
            }
    
            if (destination !== undefined) { 
                localVarFormParams.append('destination', destination as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove the specified access from the given Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('deleteWorkspaceAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} fileName The file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFile: async (organizationId: string, workspaceId: string, fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('deleteWorkspaceFile', 'fileName', fileName)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files/delete`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFiles: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('deleteWorkspaceFiles', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteWorkspaceFiles', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details of a workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspace', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('getWorkspaceAccessControl', 'identityId', identityId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} fileName The file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceFile: async (organizationId: string, workspaceId: string, fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceFile', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceFile', 'workspaceId', workspaceId)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getWorkspaceFile', 'fileName', fileName)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files/download`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (fileName !== undefined) {
                localVarQueryParameter['file_name'] = fileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurity: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('getWorkspaceSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getWorkspaceSecurity', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceFiles: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listWorkspaceFiles', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listWorkspaceFiles', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/files`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} role The Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceRolePermissions: async (organizationId: string, workspaceId: string, role: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listWorkspaceRolePermissions', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listWorkspaceRolePermissions', 'workspaceId', workspaceId)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('listWorkspaceRolePermissions', 'role', role)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/permissions/{role}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceSecurityUsers: async (organizationId: string, workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listWorkspaceSecurityUsers', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listWorkspaceSecurityUsers', 'workspaceId', workspaceId)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/users`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId The Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces: async (organizationId: string, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('listWorkspaces', 'organizationId', organizationId)
            const localVarPath = `/organizations/{organization_id}/workspaces`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest The new Workspace details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace: async (organizationId: string, workspaceId: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateWorkspace', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceUpdateRequest' is not null or undefined
            assertParamExists('updateWorkspace', 'workspaceUpdateRequest', workspaceUpdateRequest)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} identityId The User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceAccessControl: async (organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'workspaceId', workspaceId)
            // verify required parameter 'identityId' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'identityId', identityId)
            // verify required parameter 'workspaceRole' is not null or undefined
            assertParamExists('updateWorkspaceAccessControl', 'workspaceRole', workspaceRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/access/{identity_id}`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"identity_id"}}`, encodeURIComponent(String(identityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the Workspace default security
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceDefaultSecurity: async (organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('updateWorkspaceDefaultSecurity', 'organizationId', organizationId)
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateWorkspaceDefaultSecurity', 'workspaceId', workspaceId)
            // verify required parameter 'workspaceRole' is not null or undefined
            assertParamExists('updateWorkspaceDefaultSecurity', 'workspaceRole', workspaceRole)
            const localVarPath = `/organizations/{organization_id}/workspaces/{workspace_id}/security/default`
                .replace(`{${"organization_id"}}`, encodeURIComponent(String(organizationId)))
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuth2AuthCode required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "oAuth2AuthCode", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workspaceRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkspaceApi - functional programming interface
 * @export
 */
export const WorkspaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WorkspaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId The Organization identifier
         * @param {WorkspaceCreateRequest} workspaceCreateRequest The Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspace(organizationId: string, workspaceCreateRequest: WorkspaceCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspace(organizationId, workspaceCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.createWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl The new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.createWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {File} file The file to upload
         * @param {boolean} [overwrite] Whether to overwrite an existing file
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspaceFile(organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.createWorkspaceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspace(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove the specified access from the given Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceAccessControl(organizationId, workspaceId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} fileName The file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceFile(organizationId, workspaceId, fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteWorkspaceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkspaceFiles(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.deleteWorkspaceFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details of a workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspace(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceAccessControl(organizationId, workspaceId, identityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} fileName The file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceFile(organizationId, workspaceId, fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspaceFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceSecurity(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.getWorkspaceSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WorkspaceFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaceFiles(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.listWorkspaceFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} role The Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkspaceRolePermissions(organizationId: string, workspaceId: string, role: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaceRolePermissions(organizationId, workspaceId, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.listWorkspaceRolePermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaceSecurityUsers(organizationId, workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.listWorkspaceSecurityUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId The Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkspaces(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workspace>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaces(organizationId, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.listWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest The new Workspace details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspace(organizationId: string, workspaceId: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Workspace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspace(organizationId, workspaceId, workspaceUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.updateWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} identityId The User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceAccessControl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.updateWorkspaceAccessControl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the Workspace default security
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkspaceSecurity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WorkspaceApi.updateWorkspaceDefaultSecurity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WorkspaceApi - factory interface
 * @export
 */
export const WorkspaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WorkspaceApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new workspace
         * @param {string} organizationId The Organization identifier
         * @param {WorkspaceCreateRequest} workspaceCreateRequest The Workspace to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(organizationId: string, workspaceCreateRequest: WorkspaceCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Workspace> {
            return localVarFp.createWorkspace(organizationId, workspaceCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a control access to the Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {WorkspaceAccessControl} workspaceAccessControl The new Workspace security access to add.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.createWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a file for the Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {File} file The file to upload
         * @param {boolean} [overwrite] Whether to overwrite an existing file
         * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspaceFile(organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceFile> {
            return localVarFp.createWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkspace(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove the specified access from the given Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a workspace file
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} fileName The file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete all Workspace files
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details of a workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Workspace> {
            return localVarFp.getWorkspace(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a control access for the Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} identityId The User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.getWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download the Workspace File specified
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} fileName The file name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace security information
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSecurity> {
            return localVarFp.getWorkspaceSecurity(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Workspace files
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<WorkspaceFile>> {
            return localVarFp.listWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace permission by given role
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} role The Role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceRolePermissions(organizationId: string, workspaceId: string, role: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listWorkspaceRolePermissions(organizationId, workspaceId, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Workspace security users list
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listWorkspaceSecurityUsers(organizationId, workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Workspaces
         * @param {string} organizationId The Organization identifier
         * @param {number} [page] page number to query (first page is at index 0)
         * @param {number} [size] Amount of result by page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Workspace>> {
            return localVarFp.listWorkspaces(organizationId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {WorkspaceUpdateRequest} workspaceUpdateRequest The new Workspace details. This endpoint can\&#39;t be used to update security
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(organizationId: string, workspaceId: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Workspace> {
            return localVarFp.updateWorkspace(organizationId, workspaceId, workspaceUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the specified access to User for a Workspace
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {string} identityId The User identifier
         * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceAccessControl> {
            return localVarFp.updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the Workspace default security
         * @param {string} organizationId The Organization identifier
         * @param {string} workspaceId The Workspace identifier
         * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig): AxiosPromise<WorkspaceSecurity> {
            return localVarFp.updateWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkspaceApi - object-oriented interface
 * @export
 * @class WorkspaceApi
 * @extends {BaseAPI}
 */
export class WorkspaceApi extends BaseAPI {
    /**
     * 
     * @summary Create a new workspace
     * @param {string} organizationId The Organization identifier
     * @param {WorkspaceCreateRequest} workspaceCreateRequest The Workspace to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createWorkspace(organizationId: string, workspaceCreateRequest: WorkspaceCreateRequest, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createWorkspace(organizationId, workspaceCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a control access to the Workspace
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {WorkspaceAccessControl} workspaceAccessControl The new Workspace security access to add.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createWorkspaceAccessControl(organizationId: string, workspaceId: string, workspaceAccessControl: WorkspaceAccessControl, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createWorkspaceAccessControl(organizationId, workspaceId, workspaceAccessControl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a file for the Workspace
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {File} file The file to upload
     * @param {boolean} [overwrite] Whether to overwrite an existing file
     * @param {string} [destination] Destination path. Must end with a \\\&#39;/\\\&#39; if specifying a folder. Note that paths may or may not start with a \\\&#39;/\\\&#39;, but they are always treated as relative to the Workspace root location. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public createWorkspaceFile(organizationId: string, workspaceId: string, file: File, overwrite?: boolean, destination?: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).createWorkspaceFile(organizationId, workspaceId, file, overwrite, destination, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspace(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove the specified access from the given Workspace
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {string} identityId The User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a workspace file
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {string} fileName The file name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete all Workspace files
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public deleteWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).deleteWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details of a workspace
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspace(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspace(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a control access for the Workspace
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {string} identityId The User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceAccessControl(organizationId, workspaceId, identityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download the Workspace File specified
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {string} fileName The file name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceFile(organizationId: string, workspaceId: string, fileName: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceFile(organizationId, workspaceId, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace security information
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public getWorkspaceSecurity(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).getWorkspaceSecurity(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Workspace files
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public listWorkspaceFiles(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).listWorkspaceFiles(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace permission by given role
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {string} role The Role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public listWorkspaceRolePermissions(organizationId: string, workspaceId: string, role: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).listWorkspaceRolePermissions(organizationId, workspaceId, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Workspace security users list
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public listWorkspaceSecurityUsers(organizationId: string, workspaceId: string, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).listWorkspaceSecurityUsers(organizationId, workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Workspaces
     * @param {string} organizationId The Organization identifier
     * @param {number} [page] page number to query (first page is at index 0)
     * @param {number} [size] Amount of result by page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public listWorkspaces(organizationId: string, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).listWorkspaces(organizationId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a workspace
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {WorkspaceUpdateRequest} workspaceUpdateRequest The new Workspace details. This endpoint can\&#39;t be used to update security
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspace(organizationId: string, workspaceId: string, workspaceUpdateRequest: WorkspaceUpdateRequest, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspace(organizationId, workspaceId, workspaceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the specified access to User for a Workspace
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {string} identityId The User identifier
     * @param {WorkspaceRole} workspaceRole The new Workspace Access Control
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspaceAccessControl(organizationId: string, workspaceId: string, identityId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspaceAccessControl(organizationId, workspaceId, identityId, workspaceRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the Workspace default security
     * @param {string} organizationId The Organization identifier
     * @param {string} workspaceId The Workspace identifier
     * @param {WorkspaceRole} workspaceRole This change the workspace default security. The default security is the role assigned to any person not on the Access Control List. If the default security is None, then nobody outside of the ACL can access the workspace.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkspaceApi
     */
    public updateWorkspaceDefaultSecurity(organizationId: string, workspaceId: string, workspaceRole: WorkspaceRole, options?: RawAxiosRequestConfig) {
        return WorkspaceApiFp(this.configuration).updateWorkspaceDefaultSecurity(organizationId, workspaceId, workspaceRole, options).then((request) => request(this.axios, this.basePath));
    }
}



